import './style.css';
var eE = Object.defineProperty;
var tE = (e, t, n) => t in e ? eE(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var al = (e, t, n) => tE(e, typeof t != "symbol" ? t + "" : t, n);
import * as k from "react";
import Ne, { forwardRef as Ot, createElement as Yu, useState as ge, useRef as Ve, useEffect as ft, createContext as Iy, useContext as li, useCallback as Oe, useId as nE, useLayoutEffect as ui, useMemo as ut, memo as fs, useImperativeHandle as rE, Fragment as iE, useReducer as oE } from "react";
import * as Ry from "react-dom";
import { createPortal as aE } from "react-dom";
var an = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ce(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Xu = { exports: {} }, Ci = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gp;
function sE() {
  if (gp) return Ci;
  gp = 1;
  var e = Ne, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, f = {}, p = null, d = null;
    u !== void 0 && (p = "" + u), l.key !== void 0 && (p = "" + l.key), l.ref !== void 0 && (d = l.ref);
    for (c in l) r.call(l, c) && !o.hasOwnProperty(c) && (f[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) f[c] === void 0 && (f[c] = l[c]);
    return { $$typeof: t, type: s, key: p, ref: d, props: f, _owner: i.current };
  }
  return Ci.Fragment = n, Ci.jsx = a, Ci.jsxs = a, Ci;
}
var $i = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yp;
function lE() {
  return yp || (yp = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ne, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), d = Symbol.for("react.offscreen"), v = Symbol.iterator, h = "@@iterator";
    function g(R) {
      if (R === null || typeof R != "object")
        return null;
      var ee = v && R[v] || R[h];
      return typeof ee == "function" ? ee : null;
    }
    var m = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function b(R) {
      {
        for (var ee = arguments.length, le = new Array(ee > 1 ? ee - 1 : 0), pe = 1; pe < ee; pe++)
          le[pe - 1] = arguments[pe];
        x("error", R, le);
      }
    }
    function x(R, ee, le) {
      {
        var pe = m.ReactDebugCurrentFrame, De = pe.getStackAddendum();
        De !== "" && (ee += "%s", le = le.concat([De]));
        var Fe = le.map(function(Se) {
          return String(Se);
        });
        Fe.unshift("Warning: " + ee), Function.prototype.apply.call(console[R], console, Fe);
      }
    }
    var C = !1, S = !1, E = !1, T = !1, N = !1, j;
    j = Symbol.for("react.module.reference");
    function O(R) {
      return !!(typeof R == "string" || typeof R == "function" || R === r || R === o || N || R === i || R === u || R === c || T || R === d || C || S || E || typeof R == "object" && R !== null && (R.$$typeof === p || R.$$typeof === f || R.$$typeof === a || R.$$typeof === s || R.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      R.$$typeof === j || R.getModuleId !== void 0));
    }
    function _(R, ee, le) {
      var pe = R.displayName;
      if (pe)
        return pe;
      var De = ee.displayName || ee.name || "";
      return De !== "" ? le + "(" + De + ")" : le;
    }
    function V(R) {
      return R.displayName || "Context";
    }
    function L(R) {
      if (R == null)
        return null;
      if (typeof R.tag == "number" && b("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof R == "function")
        return R.displayName || R.name || null;
      if (typeof R == "string")
        return R;
      switch (R) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof R == "object")
        switch (R.$$typeof) {
          case s:
            var ee = R;
            return V(ee) + ".Consumer";
          case a:
            var le = R;
            return V(le._context) + ".Provider";
          case l:
            return _(R, R.render, "ForwardRef");
          case f:
            var pe = R.displayName || null;
            return pe !== null ? pe : L(R.type) || "Memo";
          case p: {
            var De = R, Fe = De._payload, Se = De._init;
            try {
              return L(Se(Fe));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var I = Object.assign, A = 0, M, q, W, P, y, D, B;
    function w() {
    }
    w.__reactDisabledLog = !0;
    function U() {
      {
        if (A === 0) {
          M = console.log, q = console.info, W = console.warn, P = console.error, y = console.group, D = console.groupCollapsed, B = console.groupEnd;
          var R = {
            configurable: !0,
            enumerable: !0,
            value: w,
            writable: !0
          };
          Object.defineProperties(console, {
            info: R,
            log: R,
            warn: R,
            error: R,
            group: R,
            groupCollapsed: R,
            groupEnd: R
          });
        }
        A++;
      }
    }
    function Y() {
      {
        if (A--, A === 0) {
          var R = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: I({}, R, {
              value: M
            }),
            info: I({}, R, {
              value: q
            }),
            warn: I({}, R, {
              value: W
            }),
            error: I({}, R, {
              value: P
            }),
            group: I({}, R, {
              value: y
            }),
            groupCollapsed: I({}, R, {
              value: D
            }),
            groupEnd: I({}, R, {
              value: B
            })
          });
        }
        A < 0 && b("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var K = m.ReactCurrentDispatcher, G;
    function Z(R, ee, le) {
      {
        if (G === void 0)
          try {
            throw Error();
          } catch (De) {
            var pe = De.stack.trim().match(/\n( *(at )?)/);
            G = pe && pe[1] || "";
          }
        return `
` + G + R;
      }
    }
    var Q = !1, X;
    {
      var J = typeof WeakMap == "function" ? WeakMap : Map;
      X = new J();
    }
    function H(R, ee) {
      if (!R || Q)
        return "";
      {
        var le = X.get(R);
        if (le !== void 0)
          return le;
      }
      var pe;
      Q = !0;
      var De = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Fe;
      Fe = K.current, K.current = null, U();
      try {
        if (ee) {
          var Se = function() {
            throw Error();
          };
          if (Object.defineProperty(Se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Se, []);
            } catch (_t) {
              pe = _t;
            }
            Reflect.construct(R, [], Se);
          } else {
            try {
              Se.call();
            } catch (_t) {
              pe = _t;
            }
            R.call(Se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (_t) {
            pe = _t;
          }
          R();
        }
      } catch (_t) {
        if (_t && pe && typeof _t.stack == "string") {
          for (var xe = _t.stack.split(`
`), Pt = pe.stack.split(`
`), tt = xe.length - 1, ot = Pt.length - 1; tt >= 1 && ot >= 0 && xe[tt] !== Pt[ot]; )
            ot--;
          for (; tt >= 1 && ot >= 0; tt--, ot--)
            if (xe[tt] !== Pt[ot]) {
              if (tt !== 1 || ot !== 1)
                do
                  if (tt--, ot--, ot < 0 || xe[tt] !== Pt[ot]) {
                    var Gt = `
` + xe[tt].replace(" at new ", " at ");
                    return R.displayName && Gt.includes("<anonymous>") && (Gt = Gt.replace("<anonymous>", R.displayName)), typeof R == "function" && X.set(R, Gt), Gt;
                  }
                while (tt >= 1 && ot >= 0);
              break;
            }
        }
      } finally {
        Q = !1, K.current = Fe, Y(), Error.prepareStackTrace = De;
      }
      var Cr = R ? R.displayName || R.name : "", lr = Cr ? Z(Cr) : "";
      return typeof R == "function" && X.set(R, lr), lr;
    }
    function re(R, ee, le) {
      return H(R, !1);
    }
    function se(R) {
      var ee = R.prototype;
      return !!(ee && ee.isReactComponent);
    }
    function fe(R, ee, le) {
      if (R == null)
        return "";
      if (typeof R == "function")
        return H(R, se(R));
      if (typeof R == "string")
        return Z(R);
      switch (R) {
        case u:
          return Z("Suspense");
        case c:
          return Z("SuspenseList");
      }
      if (typeof R == "object")
        switch (R.$$typeof) {
          case l:
            return re(R.render);
          case f:
            return fe(R.type, ee, le);
          case p: {
            var pe = R, De = pe._payload, Fe = pe._init;
            try {
              return fe(Fe(De), ee, le);
            } catch {
            }
          }
        }
      return "";
    }
    var oe = Object.prototype.hasOwnProperty, me = {}, we = m.ReactDebugCurrentFrame;
    function Ie(R) {
      if (R) {
        var ee = R._owner, le = fe(R.type, R._source, ee ? ee.type : null);
        we.setExtraStackFrame(le);
      } else
        we.setExtraStackFrame(null);
    }
    function nt(R, ee, le, pe, De) {
      {
        var Fe = Function.call.bind(oe);
        for (var Se in R)
          if (Fe(R, Se)) {
            var xe = void 0;
            try {
              if (typeof R[Se] != "function") {
                var Pt = Error((pe || "React class") + ": " + le + " type `" + Se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof R[Se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Pt.name = "Invariant Violation", Pt;
              }
              xe = R[Se](ee, Se, pe, le, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (tt) {
              xe = tt;
            }
            xe && !(xe instanceof Error) && (Ie(De), b("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", pe || "React class", le, Se, typeof xe), Ie(null)), xe instanceof Error && !(xe.message in me) && (me[xe.message] = !0, Ie(De), b("Failed %s type: %s", le, xe.message), Ie(null));
          }
      }
    }
    var St = Array.isArray;
    function Et(R) {
      return St(R);
    }
    function kt(R) {
      {
        var ee = typeof Symbol == "function" && Symbol.toStringTag, le = ee && R[Symbol.toStringTag] || R.constructor.name || "Object";
        return le;
      }
    }
    function ie(R) {
      try {
        return ue(R), !1;
      } catch {
        return !0;
      }
    }
    function ue(R) {
      return "" + R;
    }
    function z(R) {
      if (ie(R))
        return b("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", kt(R)), ue(R);
    }
    var F = m.ReactCurrentOwner, te = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ae, ce, he;
    he = {};
    function qe(R) {
      if (oe.call(R, "ref")) {
        var ee = Object.getOwnPropertyDescriptor(R, "ref").get;
        if (ee && ee.isReactWarning)
          return !1;
      }
      return R.ref !== void 0;
    }
    function Ge(R) {
      if (oe.call(R, "key")) {
        var ee = Object.getOwnPropertyDescriptor(R, "key").get;
        if (ee && ee.isReactWarning)
          return !1;
      }
      return R.key !== void 0;
    }
    function gt(R, ee) {
      if (typeof R.ref == "string" && F.current && ee && F.current.stateNode !== ee) {
        var le = L(F.current.type);
        he[le] || (b('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', L(F.current.type), R.ref), he[le] = !0);
      }
    }
    function rt(R, ee) {
      {
        var le = function() {
          ae || (ae = !0, b("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ee));
        };
        le.isReactWarning = !0, Object.defineProperty(R, "key", {
          get: le,
          configurable: !0
        });
      }
    }
    function Re(R, ee) {
      {
        var le = function() {
          ce || (ce = !0, b("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ee));
        };
        le.isReactWarning = !0, Object.defineProperty(R, "ref", {
          get: le,
          configurable: !0
        });
      }
    }
    var it = function(R, ee, le, pe, De, Fe, Se) {
      var xe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: R,
        key: ee,
        ref: le,
        props: Se,
        // Record the component responsible for creating this element.
        _owner: Fe
      };
      return xe._store = {}, Object.defineProperty(xe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(xe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: pe
      }), Object.defineProperty(xe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: De
      }), Object.freeze && (Object.freeze(xe.props), Object.freeze(xe)), xe;
    };
    function Qe(R, ee, le, pe, De) {
      {
        var Fe, Se = {}, xe = null, Pt = null;
        le !== void 0 && (z(le), xe = "" + le), Ge(ee) && (z(ee.key), xe = "" + ee.key), qe(ee) && (Pt = ee.ref, gt(ee, De));
        for (Fe in ee)
          oe.call(ee, Fe) && !te.hasOwnProperty(Fe) && (Se[Fe] = ee[Fe]);
        if (R && R.defaultProps) {
          var tt = R.defaultProps;
          for (Fe in tt)
            Se[Fe] === void 0 && (Se[Fe] = tt[Fe]);
        }
        if (xe || Pt) {
          var ot = typeof R == "function" ? R.displayName || R.name || "Unknown" : R;
          xe && rt(Se, ot), Pt && Re(Se, ot);
        }
        return it(R, xe, Pt, De, pe, F.current, Se);
      }
    }
    var qt = m.ReactCurrentOwner, Si = m.ReactDebugCurrentFrame;
    function Rn(R) {
      if (R) {
        var ee = R._owner, le = fe(R.type, R._source, ee ? ee.type : null);
        Si.setExtraStackFrame(le);
      } else
        Si.setExtraStackFrame(null);
    }
    var or;
    or = !1;
    function ar(R) {
      return typeof R == "object" && R !== null && R.$$typeof === t;
    }
    function sr() {
      {
        if (qt.current) {
          var R = L(qt.current.type);
          if (R)
            return `

Check the render method of \`` + R + "`.";
        }
        return "";
      }
    }
    function il(R) {
      return "";
    }
    var hn = {};
    function Fo(R) {
      {
        var ee = sr();
        if (!ee) {
          var le = typeof R == "string" ? R : R.displayName || R.name;
          le && (ee = `

Check the top-level render call using <` + le + ">.");
        }
        return ee;
      }
    }
    function Ei(R, ee) {
      {
        if (!R._store || R._store.validated || R.key != null)
          return;
        R._store.validated = !0;
        var le = Fo(ee);
        if (hn[le])
          return;
        hn[le] = !0;
        var pe = "";
        R && R._owner && R._owner !== qt.current && (pe = " It was passed a child from " + L(R._owner.type) + "."), Rn(R), b('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', le, pe), Rn(null);
      }
    }
    function ki(R, ee) {
      {
        if (typeof R != "object")
          return;
        if (Et(R))
          for (var le = 0; le < R.length; le++) {
            var pe = R[le];
            ar(pe) && Ei(pe, ee);
          }
        else if (ar(R))
          R._store && (R._store.validated = !0);
        else if (R) {
          var De = g(R);
          if (typeof De == "function" && De !== R.entries)
            for (var Fe = De.call(R), Se; !(Se = Fe.next()).done; )
              ar(Se.value) && Ei(Se.value, ee);
        }
      }
    }
    function K0(R) {
      {
        var ee = R.type;
        if (ee == null || typeof ee == "string")
          return;
        var le;
        if (typeof ee == "function")
          le = ee.propTypes;
        else if (typeof ee == "object" && (ee.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ee.$$typeof === f))
          le = ee.propTypes;
        else
          return;
        if (le) {
          var pe = L(ee);
          nt(le, R.props, "prop", pe, R);
        } else if (ee.PropTypes !== void 0 && !or) {
          or = !0;
          var De = L(ee);
          b("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", De || "Unknown");
        }
        typeof ee.getDefaultProps == "function" && !ee.getDefaultProps.isReactClassApproved && b("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function q0(R) {
      {
        for (var ee = Object.keys(R.props), le = 0; le < ee.length; le++) {
          var pe = ee[le];
          if (pe !== "children" && pe !== "key") {
            Rn(R), b("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", pe), Rn(null);
            break;
          }
        }
        R.ref !== null && (Rn(R), b("Invalid attribute `ref` supplied to `React.Fragment`."), Rn(null));
      }
    }
    var vp = {};
    function mp(R, ee, le, pe, De, Fe) {
      {
        var Se = O(R);
        if (!Se) {
          var xe = "";
          (R === void 0 || typeof R == "object" && R !== null && Object.keys(R).length === 0) && (xe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Pt = il();
          Pt ? xe += Pt : xe += sr();
          var tt;
          R === null ? tt = "null" : Et(R) ? tt = "array" : R !== void 0 && R.$$typeof === t ? (tt = "<" + (L(R.type) || "Unknown") + " />", xe = " Did you accidentally export a JSX literal instead of a component?") : tt = typeof R, b("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", tt, xe);
        }
        var ot = Qe(R, ee, le, De, Fe);
        if (ot == null)
          return ot;
        if (Se) {
          var Gt = ee.children;
          if (Gt !== void 0)
            if (pe)
              if (Et(Gt)) {
                for (var Cr = 0; Cr < Gt.length; Cr++)
                  ki(Gt[Cr], R);
                Object.freeze && Object.freeze(Gt);
              } else
                b("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ki(Gt, R);
        }
        if (oe.call(ee, "key")) {
          var lr = L(R), _t = Object.keys(ee).filter(function(Q0) {
            return Q0 !== "key";
          }), ol = _t.length > 0 ? "{key: someKey, " + _t.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!vp[lr + ol]) {
            var Z0 = _t.length > 0 ? "{" + _t.join(": ..., ") + ": ...}" : "{}";
            b(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ol, lr, Z0, lr), vp[lr + ol] = !0;
          }
        }
        return R === r ? q0(ot) : K0(ot), ot;
      }
    }
    function G0(R, ee, le) {
      return mp(R, ee, le, !0);
    }
    function Y0(R, ee, le) {
      return mp(R, ee, le, !1);
    }
    var X0 = Y0, J0 = G0;
    $i.Fragment = r, $i.jsx = X0, $i.jsxs = J0;
  }()), $i;
}
process.env.NODE_ENV === "production" ? Xu.exports = sE() : Xu.exports = lE();
var $ = Xu.exports;
function uE(e, t = []) {
  let n = [];
  function r(o, a) {
    const s = k.createContext(a), l = n.length;
    n = [...n, a];
    function u(f) {
      const { scope: p, children: d, ...v } = f, h = (p == null ? void 0 : p[e][l]) || s, g = k.useMemo(() => v, Object.values(v));
      return /* @__PURE__ */ $.jsx(h.Provider, { value: g, children: d });
    }
    function c(f, p) {
      const d = (p == null ? void 0 : p[e][l]) || s, v = k.useContext(d);
      if (v) return v;
      if (a !== void 0) return a;
      throw new Error(`\`${f}\` must be used within \`${o}\``);
    }
    return u.displayName = o + "Provider", [u, c];
  }
  const i = () => {
    const o = n.map((a) => k.createContext(a));
    return function(s) {
      const l = (s == null ? void 0 : s[e]) || o;
      return k.useMemo(
        () => ({ [`__scope${e}`]: { ...s, [e]: l } }),
        [s, l]
      );
    };
  };
  return i.scopeName = e, [r, cE(i, ...t)];
}
function cE(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(o) {
      const a = r.reduce((s, { useScope: l, scopeName: u }) => {
        const f = l(o)[`__scope${u}`];
        return { ...s, ...f };
      }, {});
      return k.useMemo(() => ({ [`__scope${t.scopeName}`]: a }), [a]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function Zn(e) {
  const t = k.useRef(e);
  return k.useEffect(() => {
    t.current = e;
  }), k.useMemo(() => (...n) => {
    var r;
    return (r = t.current) == null ? void 0 : r.call(t, ...n);
  }, []);
}
var Jr = globalThis != null && globalThis.document ? k.useLayoutEffect : () => {
};
function fE(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function dE(...e) {
  return (t) => e.forEach((n) => fE(n, t));
}
var Py = k.forwardRef((e, t) => {
  const { children: n, ...r } = e, i = k.Children.toArray(n), o = i.find(hE);
  if (o) {
    const a = o.props.children, s = i.map((l) => l === o ? k.Children.count(a) > 1 ? k.Children.only(null) : k.isValidElement(a) ? a.props.children : null : l);
    return /* @__PURE__ */ $.jsx(Ju, { ...r, ref: t, children: k.isValidElement(a) ? k.cloneElement(a, void 0, s) : null });
  }
  return /* @__PURE__ */ $.jsx(Ju, { ...r, ref: t, children: n });
});
Py.displayName = "Slot";
var Ju = k.forwardRef((e, t) => {
  const { children: n, ...r } = e;
  if (k.isValidElement(n)) {
    const i = mE(n);
    return k.cloneElement(n, {
      ...vE(r, n.props),
      // @ts-ignore
      ref: t ? dE(t, i) : i
    });
  }
  return k.Children.count(n) > 1 ? k.Children.only(null) : null;
});
Ju.displayName = "SlotClone";
var pE = ({ children: e }) => /* @__PURE__ */ $.jsx($.Fragment, { children: e });
function hE(e) {
  return k.isValidElement(e) && e.type === pE;
}
function vE(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], o = t[r];
    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...s) => {
      o(...s), i(...s);
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...o } : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function mE(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var gE = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], cf = gE.reduce((e, t) => {
  const n = k.forwardRef((r, i) => {
    const { asChild: o, ...a } = r, s = o ? Py : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ $.jsx(s, { ...a, ref: i });
  });
  return n.displayName = `Primitive.${t}`, { ...e, [t]: n };
}, {}), ff = "Avatar", [yE, cX] = uE(ff), [bE, Ay] = yE(ff), df = k.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, ...r } = e, [i, o] = k.useState("idle");
    return /* @__PURE__ */ $.jsx(
      bE,
      {
        scope: n,
        imageLoadingStatus: i,
        onImageLoadingStatusChange: o,
        children: /* @__PURE__ */ $.jsx(cf.span, { ...r, ref: t })
      }
    );
  }
);
df.displayName = ff;
var Dy = "AvatarImage", pf = k.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, src: r, onLoadingStatusChange: i = () => {
    }, ...o } = e, a = Ay(Dy, n), s = xE(r), l = Zn((u) => {
      i(u), a.onImageLoadingStatusChange(u);
    });
    return Jr(() => {
      s !== "idle" && l(s);
    }, [s, l]), s === "loaded" ? /* @__PURE__ */ $.jsx(cf.img, { ...o, ref: t, src: r }) : null;
  }
);
pf.displayName = Dy;
var _y = "AvatarFallback", hf = k.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, delayMs: r, ...i } = e, o = Ay(_y, n), [a, s] = k.useState(r === void 0);
    return k.useEffect(() => {
      if (r !== void 0) {
        const l = window.setTimeout(() => s(!0), r);
        return () => window.clearTimeout(l);
      }
    }, [r]), a && o.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ $.jsx(cf.span, { ...i, ref: t }) : null;
  }
);
hf.displayName = _y;
function xE(e) {
  const [t, n] = k.useState("idle");
  return Jr(() => {
    if (!e) {
      n("error");
      return;
    }
    let r = !0;
    const i = new window.Image(), o = (a) => () => {
      r && n(a);
    };
    return n("loading"), i.onload = o("loaded"), i.onerror = o("error"), i.src = e, () => {
      r = !1;
    };
  }, [e]), t;
}
function Zu(e) {
  if (!/^#?([a-fA-F\d]{6}|[a-fA-F\d]{3})$/.test(e))
    return { r: 0, g: 0, b: 0 };
  const n = e.replace(/^#/, "");
  let r = n;
  n.length === 3 && (r = n.split("").map((l) => l + l).join(""));
  const i = parseInt(r, 16), o = i >> 16 & 255, a = i >> 8 & 255, s = i & 255;
  return { r: o, g: a, b: s };
}
function wE(e) {
  return `#${((1 << 24) + (e.r << 16) + (e.g << 8) + e.b).toString(16).slice(1)}`;
}
const SE = (e, t = 30) => {
  const n = Math.min(e.r, e.g, e.b), r = Math.max(e.r, e.g, e.b, n + 1);
  return {
    r: Math.floor((e.r - n) / (r - n) * t * (1 - 0.299) + 120 - t / 2),
    g: Math.floor((e.g - n) / (r - n) * t * (1 - 0.587) + 120 - t / 2),
    b: Math.floor((e.b - n) / (r - n) * t * (1 - 0.114) + 120 - t / 2)
  };
};
function bp(e) {
  return Object.entries(e).reduce((t, [n, r]) => {
    const i = n.replace(/(\d+)/, (o) => (1e3 - parseInt(o)).toString());
    return { ...t, [i]: r };
  }, {});
}
const EE = 2.4, kE = 0.2126729, CE = 0.7151522, $E = 0.072175, TE = 0.56, OE = 0.57, IE = 0.62, RE = 0.65, Bo = 0.022, xp = 1.414, PE = 1.14, AE = 1.14, DE = 0.035991, _E = 0.035991, ME = 27.7847239587675, jE = 27.7847239587675, wp = 0.027, Sp = 0.027, Ep = 1e-3, NE = 5e-4;
function kp(e) {
  const { r: t, g: n, b: r } = e, i = (o) => (o / 255) ** EE;
  return kE * i(t) + CE * i(n) + $E * i(r);
}
function Cp(e, t) {
  if (!e || !t)
    return 0;
  let n = kp(Zu(e)), r = kp(Zu(t)), i = 0, o = 0;
  return n = n > Bo ? n : n + (Bo - n) ** xp, r = r > Bo ? r : r + (Bo - r) ** xp, Math.abs(r - n) < NE ? 0 : (r > n ? (i = (r ** TE - n ** OE) * PE, o = i < Ep ? 0 : i < DE ? i - i * ME * wp : i - wp) : (i = (r ** RE - n ** IE) * AE, o = i > -Ep ? 0 : i > -_E ? i - i * jE * Sp : i + Sp), Math.abs(o * 100));
}
class My {
  constructor() {
    al(this, "eventMap");
    this.eventMap = {};
  }
  on(t, n) {
    var r;
    return this.eventMap[t] || (this.eventMap[t] = /* @__PURE__ */ new Set()), (r = this.eventMap[t]) == null || r.add(n), () => {
      var i;
      (i = this.eventMap[t]) == null || i.delete(n);
    };
  }
  emit(t, n) {
    var r, i;
    (r = this.eventMap[t]) == null || r.forEach((o) => {
      o(n);
    }), (i = this.eventMap["*"]) == null || i.forEach((o) => {
      o({ type: t, payload: n });
    });
  }
}
const LE = new My();
function $p(e, t) {
  let n = `${e} {`;
  for (const [r, i] of Object.entries(t))
    n += `${r}: ${i}; `;
  return n += "}", n;
}
function jy(e, t) {
  let n = 0;
  if (e.length == 0)
    return n;
  for (let r = 0; r < e.length; r++) {
    const i = e.charCodeAt(r);
    n = (n << 5) - n + i, n = n & n;
  }
  return Math.abs(n) % t;
}
var Ny = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(an, function() {
    var n = 1e3, r = 6e4, i = 36e5, o = "millisecond", a = "second", s = "minute", l = "hour", u = "day", c = "week", f = "month", p = "quarter", d = "year", v = "date", h = "Invalid Date", g = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, m = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, b = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(I) {
      var A = ["th", "st", "nd", "rd"], M = I % 100;
      return "[" + I + (A[(M - 20) % 10] || A[M] || A[0]) + "]";
    } }, x = function(I, A, M) {
      var q = String(I);
      return !q || q.length >= A ? I : "" + Array(A + 1 - q.length).join(M) + I;
    }, C = { s: x, z: function(I) {
      var A = -I.utcOffset(), M = Math.abs(A), q = Math.floor(M / 60), W = M % 60;
      return (A <= 0 ? "+" : "-") + x(q, 2, "0") + ":" + x(W, 2, "0");
    }, m: function I(A, M) {
      if (A.date() < M.date()) return -I(M, A);
      var q = 12 * (M.year() - A.year()) + (M.month() - A.month()), W = A.clone().add(q, f), P = M - W < 0, y = A.clone().add(q + (P ? -1 : 1), f);
      return +(-(q + (M - W) / (P ? W - y : y - W)) || 0);
    }, a: function(I) {
      return I < 0 ? Math.ceil(I) || 0 : Math.floor(I);
    }, p: function(I) {
      return { M: f, y: d, w: c, d: u, D: v, h: l, m: s, s: a, ms: o, Q: p }[I] || String(I || "").toLowerCase().replace(/s$/, "");
    }, u: function(I) {
      return I === void 0;
    } }, S = "en", E = {};
    E[S] = b;
    var T = "$isDayjsObject", N = function(I) {
      return I instanceof V || !(!I || !I[T]);
    }, j = function I(A, M, q) {
      var W;
      if (!A) return S;
      if (typeof A == "string") {
        var P = A.toLowerCase();
        E[P] && (W = P), M && (E[P] = M, W = P);
        var y = A.split("-");
        if (!W && y.length > 1) return I(y[0]);
      } else {
        var D = A.name;
        E[D] = A, W = D;
      }
      return !q && W && (S = W), W || !q && S;
    }, O = function(I, A) {
      if (N(I)) return I.clone();
      var M = typeof A == "object" ? A : {};
      return M.date = I, M.args = arguments, new V(M);
    }, _ = C;
    _.l = j, _.i = N, _.w = function(I, A) {
      return O(I, { locale: A.$L, utc: A.$u, x: A.$x, $offset: A.$offset });
    };
    var V = function() {
      function I(M) {
        this.$L = j(M.locale, null, !0), this.parse(M), this.$x = this.$x || M.x || {}, this[T] = !0;
      }
      var A = I.prototype;
      return A.parse = function(M) {
        this.$d = function(q) {
          var W = q.date, P = q.utc;
          if (W === null) return /* @__PURE__ */ new Date(NaN);
          if (_.u(W)) return /* @__PURE__ */ new Date();
          if (W instanceof Date) return new Date(W);
          if (typeof W == "string" && !/Z$/i.test(W)) {
            var y = W.match(g);
            if (y) {
              var D = y[2] - 1 || 0, B = (y[7] || "0").substring(0, 3);
              return P ? new Date(Date.UTC(y[1], D, y[3] || 1, y[4] || 0, y[5] || 0, y[6] || 0, B)) : new Date(y[1], D, y[3] || 1, y[4] || 0, y[5] || 0, y[6] || 0, B);
            }
          }
          return new Date(W);
        }(M), this.init();
      }, A.init = function() {
        var M = this.$d;
        this.$y = M.getFullYear(), this.$M = M.getMonth(), this.$D = M.getDate(), this.$W = M.getDay(), this.$H = M.getHours(), this.$m = M.getMinutes(), this.$s = M.getSeconds(), this.$ms = M.getMilliseconds();
      }, A.$utils = function() {
        return _;
      }, A.isValid = function() {
        return this.$d.toString() !== h;
      }, A.isSame = function(M, q) {
        var W = O(M);
        return this.startOf(q) <= W && W <= this.endOf(q);
      }, A.isAfter = function(M, q) {
        return O(M) < this.startOf(q);
      }, A.isBefore = function(M, q) {
        return this.endOf(q) < O(M);
      }, A.$g = function(M, q, W) {
        return _.u(M) ? this[q] : this.set(W, M);
      }, A.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, A.valueOf = function() {
        return this.$d.getTime();
      }, A.startOf = function(M, q) {
        var W = this, P = !!_.u(q) || q, y = _.p(M), D = function(Q, X) {
          var J = _.w(W.$u ? Date.UTC(W.$y, X, Q) : new Date(W.$y, X, Q), W);
          return P ? J : J.endOf(u);
        }, B = function(Q, X) {
          return _.w(W.toDate()[Q].apply(W.toDate("s"), (P ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(X)), W);
        }, w = this.$W, U = this.$M, Y = this.$D, K = "set" + (this.$u ? "UTC" : "");
        switch (y) {
          case d:
            return P ? D(1, 0) : D(31, 11);
          case f:
            return P ? D(1, U) : D(0, U + 1);
          case c:
            var G = this.$locale().weekStart || 0, Z = (w < G ? w + 7 : w) - G;
            return D(P ? Y - Z : Y + (6 - Z), U);
          case u:
          case v:
            return B(K + "Hours", 0);
          case l:
            return B(K + "Minutes", 1);
          case s:
            return B(K + "Seconds", 2);
          case a:
            return B(K + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, A.endOf = function(M) {
        return this.startOf(M, !1);
      }, A.$set = function(M, q) {
        var W, P = _.p(M), y = "set" + (this.$u ? "UTC" : ""), D = (W = {}, W[u] = y + "Date", W[v] = y + "Date", W[f] = y + "Month", W[d] = y + "FullYear", W[l] = y + "Hours", W[s] = y + "Minutes", W[a] = y + "Seconds", W[o] = y + "Milliseconds", W)[P], B = P === u ? this.$D + (q - this.$W) : q;
        if (P === f || P === d) {
          var w = this.clone().set(v, 1);
          w.$d[D](B), w.init(), this.$d = w.set(v, Math.min(this.$D, w.daysInMonth())).$d;
        } else D && this.$d[D](B);
        return this.init(), this;
      }, A.set = function(M, q) {
        return this.clone().$set(M, q);
      }, A.get = function(M) {
        return this[_.p(M)]();
      }, A.add = function(M, q) {
        var W, P = this;
        M = Number(M);
        var y = _.p(q), D = function(U) {
          var Y = O(P);
          return _.w(Y.date(Y.date() + Math.round(U * M)), P);
        };
        if (y === f) return this.set(f, this.$M + M);
        if (y === d) return this.set(d, this.$y + M);
        if (y === u) return D(1);
        if (y === c) return D(7);
        var B = (W = {}, W[s] = r, W[l] = i, W[a] = n, W)[y] || 1, w = this.$d.getTime() + M * B;
        return _.w(w, this);
      }, A.subtract = function(M, q) {
        return this.add(-1 * M, q);
      }, A.format = function(M) {
        var q = this, W = this.$locale();
        if (!this.isValid()) return W.invalidDate || h;
        var P = M || "YYYY-MM-DDTHH:mm:ssZ", y = _.z(this), D = this.$H, B = this.$m, w = this.$M, U = W.weekdays, Y = W.months, K = W.meridiem, G = function(X, J, H, re) {
          return X && (X[J] || X(q, P)) || H[J].slice(0, re);
        }, Z = function(X) {
          return _.s(D % 12 || 12, X, "0");
        }, Q = K || function(X, J, H) {
          var re = X < 12 ? "AM" : "PM";
          return H ? re.toLowerCase() : re;
        };
        return P.replace(m, function(X, J) {
          return J || function(H) {
            switch (H) {
              case "YY":
                return String(q.$y).slice(-2);
              case "YYYY":
                return _.s(q.$y, 4, "0");
              case "M":
                return w + 1;
              case "MM":
                return _.s(w + 1, 2, "0");
              case "MMM":
                return G(W.monthsShort, w, Y, 3);
              case "MMMM":
                return G(Y, w);
              case "D":
                return q.$D;
              case "DD":
                return _.s(q.$D, 2, "0");
              case "d":
                return String(q.$W);
              case "dd":
                return G(W.weekdaysMin, q.$W, U, 2);
              case "ddd":
                return G(W.weekdaysShort, q.$W, U, 3);
              case "dddd":
                return U[q.$W];
              case "H":
                return String(D);
              case "HH":
                return _.s(D, 2, "0");
              case "h":
                return Z(1);
              case "hh":
                return Z(2);
              case "a":
                return Q(D, B, !0);
              case "A":
                return Q(D, B, !1);
              case "m":
                return String(B);
              case "mm":
                return _.s(B, 2, "0");
              case "s":
                return String(q.$s);
              case "ss":
                return _.s(q.$s, 2, "0");
              case "SSS":
                return _.s(q.$ms, 3, "0");
              case "Z":
                return y;
            }
            return null;
          }(X) || y.replace(":", "");
        });
      }, A.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, A.diff = function(M, q, W) {
        var P, y = this, D = _.p(q), B = O(M), w = (B.utcOffset() - this.utcOffset()) * r, U = this - B, Y = function() {
          return _.m(y, B);
        };
        switch (D) {
          case d:
            P = Y() / 12;
            break;
          case f:
            P = Y();
            break;
          case p:
            P = Y() / 3;
            break;
          case c:
            P = (U - w) / 6048e5;
            break;
          case u:
            P = (U - w) / 864e5;
            break;
          case l:
            P = U / i;
            break;
          case s:
            P = U / r;
            break;
          case a:
            P = U / n;
            break;
          default:
            P = U;
        }
        return W ? P : _.a(P);
      }, A.daysInMonth = function() {
        return this.endOf(f).$D;
      }, A.$locale = function() {
        return E[this.$L];
      }, A.locale = function(M, q) {
        if (!M) return this.$L;
        var W = this.clone(), P = j(M, q, !0);
        return P && (W.$L = P), W;
      }, A.clone = function() {
        return _.w(this.$d, this);
      }, A.toDate = function() {
        return new Date(this.valueOf());
      }, A.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, A.toISOString = function() {
        return this.$d.toISOString();
      }, A.toString = function() {
        return this.$d.toUTCString();
      }, I;
    }(), L = V.prototype;
    return O.prototype = L, [["$ms", o], ["$s", a], ["$m", s], ["$H", l], ["$W", u], ["$M", f], ["$y", d], ["$D", v]].forEach(function(I) {
      L[I[1]] = function(A) {
        return this.$g(A, I[0], I[1]);
      };
    }), O.extend = function(I, A) {
      return I.$i || (I(A, V, O), I.$i = !0), O;
    }, O.locale = j, O.isDayjs = N, O.unix = function(I) {
      return O(1e3 * I);
    }, O.en = E[S], O.Ls = E, O.p = {}, O;
  });
})(Ny);
var FE = Ny.exports;
const ds = /* @__PURE__ */ Ce(FE);
var Ly = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(an, function() {
    return function(n, r, i) {
      r.prototype.isToday = function() {
        var o = "YYYY-MM-DD", a = i();
        return this.format(o) === a.format(o);
      };
    };
  });
})(Ly);
var BE = Ly.exports;
const zE = /* @__PURE__ */ Ce(BE);
var Fy = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(an, function() {
    return function(n, r, i) {
      r.prototype.isYesterday = function() {
        var o = "YYYY-MM-DD", a = i().subtract(1, "day");
        return this.format(o) === a.format(o);
      };
    };
  });
})(Fy);
var WE = Fy.exports;
const UE = /* @__PURE__ */ Ce(WE);
let zo;
const HE = new Uint8Array(16);
function VE() {
  if (!zo && (zo = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !zo))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return zo(HE);
}
const yt = [];
for (let e = 0; e < 256; ++e)
  yt.push((e + 256).toString(16).slice(1));
function KE(e, t = 0) {
  return yt[e[t + 0]] + yt[e[t + 1]] + yt[e[t + 2]] + yt[e[t + 3]] + "-" + yt[e[t + 4]] + yt[e[t + 5]] + "-" + yt[e[t + 6]] + yt[e[t + 7]] + "-" + yt[e[t + 8]] + yt[e[t + 9]] + "-" + yt[e[t + 10]] + yt[e[t + 11]] + yt[e[t + 12]] + yt[e[t + 13]] + yt[e[t + 14]] + yt[e[t + 15]];
}
const qE = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Tp = {
  randomUUID: qE
};
function By(e, t, n) {
  if (Tp.randomUUID && !t && !e)
    return Tp.randomUUID();
  e = e || {};
  const r = e.random || (e.rng || VE)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, KE(r);
}
ds.extend(zE);
ds.extend(UE);
function GE(e, t = "day") {
  var r, i, o;
  if (!e || e.length === 0) return [];
  const n = [];
  (r = e[0]) != null && r.timestamp && n.push(Op(e[0].timestamp));
  for (let a = 0; a < e.length; a++)
    if (e[a] && n.push(e[a]), a + 1 < e.length) {
      const s = (i = e[a]) == null ? void 0 : i.timestamp, l = (o = e[a + 1]) == null ? void 0 : o.timestamp;
      !ds(s).isSame(l, t) && l && n.push(Op(l));
    }
  return n;
}
function Op(e) {
  return {
    id: By(),
    direction: "system",
    sender: { name: "system" },
    timestamp: e,
    block: {
      type: "text",
      text: YE(e)
    }
  };
}
function YE(e, t = !1) {
  const n = ds(e), r = "h:mma";
  return n.isToday() ? t ? `Today • ${n.format(r)}` : "Today" : n.isYesterday() ? t ? `Yesterday • ${n.format(r)}` : "Yesterday" : t ? n.format(`YYYY-MM-DD • ${r}`) : n.format("YYYY-MM-DD");
}
function XE(e = "") {
  if (typeof e != "string")
    throw new TypeError("Color should be string!");
  const t = /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(e);
  if (t)
    return t.splice(1).map((r) => Number.parseInt(r, 16));
  const n = /^#?([\da-f])([\da-f])([\da-f])$/i.exec(e);
  if (n)
    return n.splice(1).map((r) => Number.parseInt(r + r, 16));
  if (e.includes(","))
    return e.split(",").map((r) => Number.parseInt(r));
  throw new Error("Invalid color format! Use #ABC or #AABBCC or r,g,b");
}
function JE(e) {
  return "#" + e.map((t) => `0${t.toString(16).toUpperCase()}`.slice(-2)).join("");
}
function ZE(e, t) {
  return e.map((n) => Math.round(n + (255 - n) * t));
}
function QE(e, t) {
  return e.map((n) => Math.round(n * t));
}
const Ti = (e) => (t) => ZE(t, e), Oi = (e) => (t) => QE(t, e), ek = {
  50: Ti(0.95),
  100: Ti(0.9),
  200: Ti(0.75),
  300: Ti(0.6),
  400: Ti(0.3),
  500: (e) => e,
  600: Oi(0.9),
  700: Oi(0.6),
  800: Oi(0.45),
  900: Oi(0.3),
  950: Oi(0.2)
};
function Ip(e, t = ek) {
  const n = {}, r = XE(e);
  for (const [i, o] of Object.entries(t))
    n[i] = JE(o(r));
  return n;
}
function tk(e) {
  const { fontFamily: t, radius: n, themeMode: r, color: i, variant: o, headerVariant: a } = e;
  let s = {}, l = {};
  if (i) {
    const d = Ip(i), v = r === "dark" ? bp(d) : d, h = Ip(wE(SE(Zu(i)))), g = r === "dark" ? bp(h) : h, m = r === "dark" ? "#101010" : "#fdfdfd";
    l = Object.entries({ ...v, 1: m }).reduce(
      (x, [C, S]) => ({ ...x, [`--bpPrimary-${C}`]: S }),
      {}
    );
    const b = Object.entries({ ...g, 1: m }).reduce(
      (x, [C, S]) => ({ ...x, [`--bpGray-${C}`]: S }),
      {}
    );
    s = {
      ...l,
      ...b
    };
  }
  n && (s = {
    ...s,
    "--bpRadius-scale": n.toString()
  });
  const u = r === "dark" ? { bg: "var(--transparent-dark)", bgHover: "var(--transparent-dark-hover)" } : { bg: "var(--transparent-light)", bgHover: "var(--transparent-light-hover)" }, c = l ? Cp(l["--bpPrimary-600"], l["--bpPrimary-50"]) > 40 ? "var(--bpPrimary-50)" : "var(--bpPrimary-900)" : "var(--bpPrimary-50)", f = o === "solid" ? {
    "--message-bg": "var(--bpPrimary-600)",
    "--message-bg-hover": "var(--bpPrimary-700)",
    "--message-text": c,
    "--send-button-bg": "var(--bpPrimary-600)",
    "--send-button-bg-hover": "var(--bpPrimary-700)",
    "--send-button-text": "var(--bpPrimary-50)",
    "--button-bg": "var(--bpPrimary-100)",
    "--button-bg-hover": "var(--bpPrimary-200)",
    "--button-text": "var(--bpPrimary-800)",
    "--fab-bg": "var(--bpPrimary-600)",
    "--fab-bg-hover": "var(--bpPrimary-700)",
    "--fab-icon": c,
    "--modal-submit-bg": "var(--bpPrimary-600)",
    "--modal-submit-bg-hover": "var(--bpPrimary-700)"
  } : {
    "--message-bg": "var(--bpPrimary-100)",
    "--message-bg-hover": "var(--bpPrimary-200)",
    "--message-text": "var(--bpPrimary-900)",
    "--send-button-bg": "var(--bpPrimary-600)",
    "--send-button-bg-hover": "var(--bpPrimary-700)",
    "--send-button-text": "var(--bpPrimary-50)",
    "--button-bg": "var(--bpPrimary-500)",
    "--button-bg-hover": "var(--bpPrimary-600)",
    "--button-text": l ? Cp(l["--bpPrimary-500"], l["--bpPrimary-50"]) > 40 ? "var(--bpPrimary-50)" : "var(--bpPrimary-900)" : "var(--bpPrimary-50)",
    "--fab-bg": "var(--bpPrimary-100)",
    "--fab-bg-hover": "var(--bpPrimary-200)",
    "--fab-icon": "var(--bpPrimary-700)",
    "--scrollbar": "var(--bpGray-500)",
    "--scrollbar-hover": "var(--bpGray-400)",
    "--modal-submit-bg": "var(--bpPrimary-200)",
    "--modal-submit-bg-hover": "var(--bpPrimary-300)"
  }, p = a === "solid" ? {
    "--header-bg": "var(--bpPrimary-600)",
    "--header-bg-hover": "var(--bpPrimary-700)",
    "--header-hover-dark": "var(--bpPrimary-800)",
    "--header-title": c,
    "--header-description": c,
    "--header-description-icon": c,
    "--header-description-link": c,
    "--header-avatar-bg": "var(--bpPrimary-300)",
    "--header-avatar-text": "var(--bpPrimary-700)"
  } : {
    "--header-bg": u.bg,
    "--header-bg-hover": u.bgHover,
    "--header-hover-dark": "var(--bpGray-200)",
    "--header-title": "var(--bpGray-900)",
    "--header-description": "var(--bpGray-600)",
    "--header-description-icon": "var(--bpPrimary-700)",
    "--header-description-link": "var(--bpPrimary-800)",
    "--header-avatar-bg": "var(--bpPrimary-600)",
    "--header-avatar-text": "var(--bpPrimary-50)"
  };
  return s = {
    ...s,
    ...f,
    ...p
  }, $p(":root", s) + (t ? $p(".bpFont", { "font-family": `var(--${t}-font)` }) : "");
}
const nk = (e, t = {}) => new Promise((n, r) => {
  if (typeof window > "u")
    return r("Window is not defined");
  if (!e)
    return r("Url is not defined");
  let i = null;
  const o = new Image();
  o.addEventListener("load", () => {
    i && clearTimeout(i), n({ width: o.naturalWidth, height: o.naturalHeight });
  }), o.addEventListener("error", (a) => {
    i && clearTimeout(i), r(`${a.type}: ${a.message}`);
  }), o.src = e, t.timeout && (i = setTimeout(() => r("Timeout"), t.timeout));
}), vf = Ot(
  ({ userId: e, src: t, container: n, image: r, fallback: i, ...o }, a) => {
    const s = jy(e ?? "", 15);
    return /* @__PURE__ */ $.jsxs(df, { ref: a, "data-color": s, ...n, ...o, children: [
      /* @__PURE__ */ $.jsx(pf, { src: t, ...r }),
      /* @__PURE__ */ $.jsx(hf, { ...i, children: typeof o.children == "string" ? o.children[0] : o.children })
    ] });
  }
);
vf.displayName = "Avatar";
function rk(e, t) {
  const n = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const ik = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, ok = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, ak = {};
function Rp(e, t) {
  return (ak.jsx ? ok : ik).test(e);
}
const sk = /[ \t\n\f\r]/g;
function lk(e) {
  return typeof e == "object" ? e.type === "text" ? Pp(e.value) : !1 : Pp(e);
}
function Pp(e) {
  return e.replace(sk, "") === "";
}
class fo {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, n, r) {
    this.property = t, this.normal = n, r && (this.space = r);
  }
}
fo.prototype.property = {};
fo.prototype.normal = {};
fo.prototype.space = null;
function zy(e, t) {
  const n = {}, r = {};
  let i = -1;
  for (; ++i < e.length; )
    Object.assign(n, e[i].property), Object.assign(r, e[i].normal);
  return new fo(n, r, t);
}
function Qu(e) {
  return e.toLowerCase();
}
class Qt {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, n) {
    this.property = t, this.attribute = n;
  }
}
Qt.prototype.space = null;
Qt.prototype.boolean = !1;
Qt.prototype.booleanish = !1;
Qt.prototype.overloadedBoolean = !1;
Qt.prototype.number = !1;
Qt.prototype.commaSeparated = !1;
Qt.prototype.spaceSeparated = !1;
Qt.prototype.commaOrSpaceSeparated = !1;
Qt.prototype.mustUseProperty = !1;
Qt.prototype.defined = !1;
let uk = 0;
const ve = br(), at = br(), Wy = br(), ne = br(), We = br(), Vr = br(), zt = br();
function br() {
  return 2 ** ++uk;
}
const ec = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: ve,
  booleanish: at,
  commaOrSpaceSeparated: zt,
  commaSeparated: Vr,
  number: ne,
  overloadedBoolean: Wy,
  spaceSeparated: We
}, Symbol.toStringTag, { value: "Module" })), sl = Object.keys(ec);
class mf extends Qt {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, n, r, i) {
    let o = -1;
    if (super(t, n), Ap(this, "space", i), typeof r == "number")
      for (; ++o < sl.length; ) {
        const a = sl[o];
        Ap(this, sl[o], (r & ec[a]) === ec[a]);
      }
  }
}
mf.prototype.defined = !0;
function Ap(e, t, n) {
  n && (e[t] = n);
}
const ck = {}.hasOwnProperty;
function ci(e) {
  const t = {}, n = {};
  let r;
  for (r in e.properties)
    if (ck.call(e.properties, r)) {
      const i = e.properties[r], o = new mf(
        r,
        e.transform(e.attributes || {}, r),
        i,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (o.mustUseProperty = !0), t[r] = o, n[Qu(r)] = r, n[Qu(o.attribute)] = r;
    }
  return new fo(t, n, e.space);
}
const Uy = ci({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), Hy = ci({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function Vy(e, t) {
  return t in e ? e[t] : t;
}
function Ky(e, t) {
  return Vy(e, t.toLowerCase());
}
const qy = ci({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: Ky,
  properties: { xmlns: null, xmlnsXLink: null }
}), Gy = ci({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: at,
    ariaAutoComplete: null,
    ariaBusy: at,
    ariaChecked: at,
    ariaColCount: ne,
    ariaColIndex: ne,
    ariaColSpan: ne,
    ariaControls: We,
    ariaCurrent: null,
    ariaDescribedBy: We,
    ariaDetails: null,
    ariaDisabled: at,
    ariaDropEffect: We,
    ariaErrorMessage: null,
    ariaExpanded: at,
    ariaFlowTo: We,
    ariaGrabbed: at,
    ariaHasPopup: null,
    ariaHidden: at,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: We,
    ariaLevel: ne,
    ariaLive: null,
    ariaModal: at,
    ariaMultiLine: at,
    ariaMultiSelectable: at,
    ariaOrientation: null,
    ariaOwns: We,
    ariaPlaceholder: null,
    ariaPosInSet: ne,
    ariaPressed: at,
    ariaReadOnly: at,
    ariaRelevant: null,
    ariaRequired: at,
    ariaRoleDescription: We,
    ariaRowCount: ne,
    ariaRowIndex: ne,
    ariaRowSpan: ne,
    ariaSelected: at,
    ariaSetSize: ne,
    ariaSort: null,
    ariaValueMax: ne,
    ariaValueMin: ne,
    ariaValueNow: ne,
    ariaValueText: null,
    role: null
  }
}), fk = ci({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: Ky,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Vr,
    acceptCharset: We,
    accessKey: We,
    action: null,
    allow: null,
    allowFullScreen: ve,
    allowPaymentRequest: ve,
    allowUserMedia: ve,
    alt: null,
    as: null,
    async: ve,
    autoCapitalize: null,
    autoComplete: We,
    autoFocus: ve,
    autoPlay: ve,
    blocking: We,
    capture: null,
    charSet: null,
    checked: ve,
    cite: null,
    className: We,
    cols: ne,
    colSpan: null,
    content: null,
    contentEditable: at,
    controls: ve,
    controlsList: We,
    coords: ne | Vr,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: ve,
    defer: ve,
    dir: null,
    dirName: null,
    disabled: ve,
    download: Wy,
    draggable: at,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: ve,
    formTarget: null,
    headers: We,
    height: ne,
    hidden: ve,
    high: ne,
    href: null,
    hrefLang: null,
    htmlFor: We,
    httpEquiv: We,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: ve,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: ve,
    itemId: null,
    itemProp: We,
    itemRef: We,
    itemScope: ve,
    itemType: We,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: ve,
    low: ne,
    manifest: null,
    max: null,
    maxLength: ne,
    media: null,
    method: null,
    min: null,
    minLength: ne,
    multiple: ve,
    muted: ve,
    name: null,
    nonce: null,
    noModule: ve,
    noValidate: ve,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: ve,
    optimum: ne,
    pattern: null,
    ping: We,
    placeholder: null,
    playsInline: ve,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: ve,
    referrerPolicy: null,
    rel: We,
    required: ve,
    reversed: ve,
    rows: ne,
    rowSpan: ne,
    sandbox: We,
    scope: null,
    scoped: ve,
    seamless: ve,
    selected: ve,
    shadowRootClonable: ve,
    shadowRootDelegatesFocus: ve,
    shadowRootMode: null,
    shape: null,
    size: ne,
    sizes: null,
    slot: null,
    span: ne,
    spellCheck: at,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: ne,
    step: null,
    style: null,
    tabIndex: ne,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: ve,
    useMap: null,
    value: at,
    width: ne,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: We,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: ne,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: ne,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: ve,
    // Lists. Use CSS to reduce space between items instead
    declare: ve,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: ne,
    // `<img>` and `<object>`
    leftMargin: ne,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: ne,
    // `<body>`
    marginWidth: ne,
    // `<body>`
    noResize: ve,
    // `<frame>`
    noHref: ve,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: ve,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: ve,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: ne,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: at,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: ne,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: ne,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: ve,
    disableRemotePlayback: ve,
    prefix: null,
    property: null,
    results: ne,
    security: null,
    unselectable: null
  }
}), dk = ci({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: Vy,
  properties: {
    about: zt,
    accentHeight: ne,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: ne,
    amplitude: ne,
    arabicForm: null,
    ascent: ne,
    attributeName: null,
    attributeType: null,
    azimuth: ne,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: ne,
    by: null,
    calcMode: null,
    capHeight: ne,
    className: We,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: ne,
    diffuseConstant: ne,
    direction: null,
    display: null,
    dur: null,
    divisor: ne,
    dominantBaseline: null,
    download: ve,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: ne,
    enableBackground: null,
    end: null,
    event: null,
    exponent: ne,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: ne,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Vr,
    g2: Vr,
    glyphName: Vr,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: ne,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: ne,
    horizOriginX: ne,
    horizOriginY: ne,
    id: null,
    ideographic: ne,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: ne,
    k: ne,
    k1: ne,
    k2: ne,
    k3: ne,
    k4: ne,
    kernelMatrix: zt,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: ne,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: ne,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: ne,
    overlineThickness: ne,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: ne,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: We,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: ne,
    pointsAtY: ne,
    pointsAtZ: ne,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: zt,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: zt,
    rev: zt,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: zt,
    requiredFeatures: zt,
    requiredFonts: zt,
    requiredFormats: zt,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: ne,
    specularExponent: ne,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: ne,
    strikethroughThickness: ne,
    string: null,
    stroke: null,
    strokeDashArray: zt,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: ne,
    strokeOpacity: ne,
    strokeWidth: null,
    style: null,
    surfaceScale: ne,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: zt,
    tabIndex: ne,
    tableValues: null,
    target: null,
    targetX: ne,
    targetY: ne,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: zt,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: ne,
    underlineThickness: ne,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: ne,
    values: null,
    vAlphabetic: ne,
    vMathematical: ne,
    vectorEffect: null,
    vHanging: ne,
    vIdeographic: ne,
    version: null,
    vertAdvY: ne,
    vertOriginX: ne,
    vertOriginY: ne,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: ne,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), pk = /^data[-\w.:]+$/i, Dp = /-[a-z]/g, hk = /[A-Z]/g;
function vk(e, t) {
  const n = Qu(t);
  let r = t, i = Qt;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && pk.test(t)) {
    if (t.charAt(4) === "-") {
      const o = t.slice(5).replace(Dp, gk);
      r = "data" + o.charAt(0).toUpperCase() + o.slice(1);
    } else {
      const o = t.slice(4);
      if (!Dp.test(o)) {
        let a = o.replace(hk, mk);
        a.charAt(0) !== "-" && (a = "-" + a), t = "data" + a;
      }
    }
    i = mf;
  }
  return new i(r, t);
}
function mk(e) {
  return "-" + e.toLowerCase();
}
function gk(e) {
  return e.charAt(1).toUpperCase();
}
const yk = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, bk = zy([Hy, Uy, qy, Gy, fk], "html"), gf = zy([Hy, Uy, qy, Gy, dk], "svg");
function xk(e) {
  return e.join(" ").trim();
}
var Yy = {}, _p = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, wk = /\n/g, Sk = /^\s*/, Ek = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, kk = /^:\s*/, Ck = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, $k = /^[;\s]*/, Tk = /^\s+|\s+$/g, Ok = `
`, Mp = "/", jp = "*", fr = "", Ik = "comment", Rk = "declaration", Pk = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function i(v) {
    var h = v.match(wk);
    h && (n += h.length);
    var g = v.lastIndexOf(Ok);
    r = ~g ? v.length - g : r + v.length;
  }
  function o() {
    var v = { line: n, column: r };
    return function(h) {
      return h.position = new a(v), u(), h;
    };
  }
  function a(v) {
    this.start = v, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(v) {
    var h = new Error(
      t.source + ":" + n + ":" + r + ": " + v
    );
    if (h.reason = v, h.filename = t.source, h.line = n, h.column = r, h.source = e, !t.silent) throw h;
  }
  function l(v) {
    var h = v.exec(e);
    if (h) {
      var g = h[0];
      return i(g), e = e.slice(g.length), h;
    }
  }
  function u() {
    l(Sk);
  }
  function c(v) {
    var h;
    for (v = v || []; h = f(); )
      h !== !1 && v.push(h);
    return v;
  }
  function f() {
    var v = o();
    if (!(Mp != e.charAt(0) || jp != e.charAt(1))) {
      for (var h = 2; fr != e.charAt(h) && (jp != e.charAt(h) || Mp != e.charAt(h + 1)); )
        ++h;
      if (h += 2, fr === e.charAt(h - 1))
        return s("End of comment missing");
      var g = e.slice(2, h - 2);
      return r += 2, i(g), e = e.slice(h), r += 2, v({
        type: Ik,
        comment: g
      });
    }
  }
  function p() {
    var v = o(), h = l(Ek);
    if (h) {
      if (f(), !l(kk)) return s("property missing ':'");
      var g = l(Ck), m = v({
        type: Rk,
        property: Np(h[0].replace(_p, fr)),
        value: g ? Np(g[0].replace(_p, fr)) : fr
      });
      return l($k), m;
    }
  }
  function d() {
    var v = [];
    c(v);
    for (var h; h = p(); )
      h !== !1 && (v.push(h), c(v));
    return v;
  }
  return u(), d();
};
function Np(e) {
  return e ? e.replace(Tk, fr) : fr;
}
var Ak = an && an.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Yy, "__esModule", { value: !0 });
var Lp = Yy.default = _k, Dk = Ak(Pk);
function _k(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Dk.default)(e), i = typeof t == "function";
  return r.forEach(function(o) {
    if (o.type === "declaration") {
      var a = o.property, s = o.value;
      i ? t(a, s, o) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
const Mk = Lp.default || Lp, Xy = Jy("end"), yf = Jy("start");
function Jy(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function jk(e) {
  const t = yf(e), n = Xy(e);
  if (t && n)
    return { start: t, end: n };
}
function Ui(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? Fp(e.position) : "start" in e || "end" in e ? Fp(e) : "line" in e || "column" in e ? tc(e) : "";
}
function tc(e) {
  return Bp(e && e.line) + ":" + Bp(e && e.column);
}
function Fp(e) {
  return tc(e && e.start) + "-" + tc(e && e.end);
}
function Bp(e) {
  return e && typeof e == "number" ? e : 1;
}
class It extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let i = "", o = {}, a = !1;
    if (n && ("line" in n && "column" in n ? o = { place: n } : "start" in n && "end" in n ? o = { place: n } : "type" in n ? o = {
      ancestors: [n],
      place: n.position
    } : o = { ...n }), typeof t == "string" ? i = t : !o.cause && t && (a = !0, i = t.message, o.cause = t), !o.ruleId && !o.source && typeof r == "string") {
      const l = r.indexOf(":");
      l === -1 ? o.ruleId = r : (o.source = r.slice(0, l), o.ruleId = r.slice(l + 1));
    }
    if (!o.place && o.ancestors && o.ancestors) {
      const l = o.ancestors[o.ancestors.length - 1];
      l && (o.place = l.position);
    }
    const s = o.place && "start" in o.place ? o.place.start : o.place;
    this.ancestors = o.ancestors || void 0, this.cause = o.cause || void 0, this.column = s ? s.column : void 0, this.fatal = void 0, this.file, this.message = i, this.line = s ? s.line : void 0, this.name = Ui(o.place) || "1:1", this.place = o.place || void 0, this.reason = this.message, this.ruleId = o.ruleId || void 0, this.source = o.source || void 0, this.stack = a && o.cause && typeof o.cause.stack == "string" ? o.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
It.prototype.file = "";
It.prototype.name = "";
It.prototype.reason = "";
It.prototype.message = "";
It.prototype.stack = "";
It.prototype.column = void 0;
It.prototype.line = void 0;
It.prototype.ancestors = void 0;
It.prototype.cause = void 0;
It.prototype.fatal = void 0;
It.prototype.place = void 0;
It.prototype.ruleId = void 0;
It.prototype.source = void 0;
const bf = {}.hasOwnProperty, Nk = /* @__PURE__ */ new Map(), Lk = /[A-Z]/g, Fk = /-([a-z])/g, Bk = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), zk = /* @__PURE__ */ new Set(["td", "th"]), Zy = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function Wk(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = Xk(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = Yk(n, t.jsx, t.jsxs);
  }
  const i = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? gf : bk,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, o = Qy(i, e, void 0);
  return o && typeof o != "string" ? o : i.create(
    e,
    i.Fragment,
    { children: o || void 0 },
    void 0
  );
}
function Qy(e, t, n) {
  if (t.type === "element")
    return Uk(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return Hk(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return Kk(e, t, n);
  if (t.type === "mdxjsEsm")
    return Vk(e, t);
  if (t.type === "root")
    return qk(e, t, n);
  if (t.type === "text")
    return Gk(e, t);
}
function Uk(e, t, n) {
  const r = e.schema;
  let i = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (i = gf, e.schema = i), e.ancestors.push(t);
  const o = tb(e, t.tagName, !1), a = Jk(e, t);
  let s = wf(e, t);
  return Bk.has(t.tagName) && (s = s.filter(function(l) {
    return typeof l == "string" ? !lk(l) : !0;
  })), eb(e, a, o, t), xf(a, s), e.ancestors.pop(), e.schema = r, e.create(t, o, a, n);
}
function Hk(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(r.expression);
  }
  Xi(e, t.position);
}
function Vk(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  Xi(e, t.position);
}
function Kk(e, t, n) {
  const r = e.schema;
  let i = r;
  t.name === "svg" && r.space === "html" && (i = gf, e.schema = i), e.ancestors.push(t);
  const o = t.name === null ? e.Fragment : tb(e, t.name, !0), a = Zk(e, t), s = wf(e, t);
  return eb(e, a, o, t), xf(a, s), e.ancestors.pop(), e.schema = r, e.create(t, o, a, n);
}
function qk(e, t, n) {
  const r = {};
  return xf(r, wf(e, t)), e.create(t, e.Fragment, r, n);
}
function Gk(e, t) {
  return t.value;
}
function eb(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function xf(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function Yk(e, t, n) {
  return r;
  function r(i, o, a, s) {
    const u = Array.isArray(a.children) ? n : t;
    return s ? u(o, a, s) : u(o, a);
  }
}
function Xk(e, t) {
  return n;
  function n(r, i, o, a) {
    const s = Array.isArray(o.children), l = yf(r);
    return t(
      i,
      o,
      a,
      s,
      {
        columnNumber: l ? l.column - 1 : void 0,
        fileName: e,
        lineNumber: l ? l.line : void 0
      },
      void 0
    );
  }
}
function Jk(e, t) {
  const n = {};
  let r, i;
  for (i in t.properties)
    if (i !== "children" && bf.call(t.properties, i)) {
      const o = Qk(e, i, t.properties[i]);
      if (o) {
        const [a, s] = o;
        e.tableCellAlignToStyle && a === "align" && typeof s == "string" && zk.has(t.tagName) ? r = s : n[a] = s;
      }
    }
  if (r) {
    const o = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    o[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function Zk(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const o = r.data.estree.body[0];
        o.type;
        const a = o.expression;
        a.type;
        const s = a.properties[0];
        s.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(s.argument)
        );
      } else
        Xi(e, t.position);
    else {
      const i = r.name;
      let o;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const s = r.value.data.estree.body[0];
          s.type, o = e.evaluater.evaluateExpression(s.expression);
        } else
          Xi(e, t.position);
      else
        o = r.value === null ? !0 : r.value;
      n[i] = /** @type {Props[keyof Props]} */
      o;
    }
  return n;
}
function wf(e, t) {
  const n = [];
  let r = -1;
  const i = e.passKeys ? /* @__PURE__ */ new Map() : Nk;
  for (; ++r < t.children.length; ) {
    const o = t.children[r];
    let a;
    if (e.passKeys) {
      const l = o.type === "element" ? o.tagName : o.type === "mdxJsxFlowElement" || o.type === "mdxJsxTextElement" ? o.name : void 0;
      if (l) {
        const u = i.get(l) || 0;
        a = l + "-" + u, i.set(l, u + 1);
      }
    }
    const s = Qy(e, o, a);
    s !== void 0 && n.push(s);
  }
  return n;
}
function Qk(e, t, n) {
  const r = vk(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? rk(n) : xk(n)), r.property === "style") {
      let i = typeof n == "object" ? n : eC(e, String(n));
      return e.stylePropertyNameCase === "css" && (i = tC(i)), ["style", i];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? yk[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function eC(e, t) {
  const n = {};
  try {
    Mk(t, r);
  } catch (i) {
    if (!e.ignoreInvalidStyle) {
      const o = (
        /** @type {Error} */
        i
      ), a = new It("Cannot parse `style` attribute", {
        ancestors: e.ancestors,
        cause: o,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw a.file = e.filePath || void 0, a.url = Zy + "#cannot-parse-style-attribute", a;
    }
  }
  return n;
  function r(i, o) {
    let a = i;
    a.slice(0, 2) !== "--" && (a.slice(0, 4) === "-ms-" && (a = "ms-" + a.slice(4)), a = a.replace(Fk, rC)), n[a] = o;
  }
}
function tb(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const i = t.split(".");
    let o = -1, a;
    for (; ++o < i.length; ) {
      const s = Rp(i[o]) ? { type: "Identifier", name: i[o] } : { type: "Literal", value: i[o] };
      a = a ? {
        type: "MemberExpression",
        object: a,
        property: s,
        computed: !!(o && s.type === "Literal"),
        optional: !1
      } : s;
    }
    r = a;
  } else
    r = Rp(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const i = (
      /** @type {keyof JSX.IntrinsicElements} */
      r.value
    );
    return bf.call(e.components, i) ? e.components[i] : i;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  Xi(e);
}
function Xi(e, t) {
  const n = new It(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = Zy + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function tC(e) {
  const t = {};
  let n;
  for (n in e)
    bf.call(e, n) && (t[nC(n)] = e[n]);
  return t;
}
function nC(e) {
  let t = e.replace(Lk, iC);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function rC(e, t) {
  return t.toUpperCase();
}
function iC(e) {
  return "-" + e.toLowerCase();
}
const ll = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, oC = {};
function Sf(e, t) {
  const n = oC, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return nb(e, r, i);
}
function nb(e, t, n) {
  if (aC(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return zp(e.children, t, n);
  }
  return Array.isArray(e) ? zp(e, t, n) : "";
}
function zp(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; )
    r[i] = nb(e[i], t, n);
  return r.join("");
}
function aC(e) {
  return !!(e && typeof e == "object");
}
const Wp = document.createElement("i");
function Ef(e) {
  const t = "&" + e + ";";
  Wp.innerHTML = t;
  const n = Wp.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function Zt(e, t, n, r) {
  const i = e.length;
  let o = 0, a;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, n = n > 0 ? n : 0, r.length < 1e4)
    a = Array.from(r), a.unshift(t, n), e.splice(...a);
  else
    for (n && e.splice(t, n); o < r.length; )
      a = r.slice(o, o + 1e4), a.unshift(t, 0), e.splice(...a), o += 1e4, t += 1e4;
}
function Yt(e, t) {
  return e.length > 0 ? (Zt(e, e.length, 0, t), e) : t;
}
const Up = {}.hasOwnProperty;
function rb(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    sC(t, e[n]);
  return t;
}
function sC(e, t) {
  let n;
  for (n in t) {
    const i = (Up.call(e, n) ? e[n] : void 0) || (e[n] = {}), o = t[n];
    let a;
    if (o)
      for (a in o) {
        Up.call(i, a) || (i[a] = []);
        const s = o[a];
        lC(
          // @ts-expect-error Looks like a list.
          i[a],
          Array.isArray(s) ? s : s ? [s] : []
        );
      }
  }
}
function lC(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  Zt(e, 0, 0, r);
}
function ib(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "�" : String.fromCodePoint(n)
  );
}
function ln(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const Dt = tr(/[A-Za-z]/), Tt = tr(/[\dA-Za-z]/), uC = tr(/[#-'*+\--9=?A-Z^-~]/);
function ja(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const nc = tr(/\d/), cC = tr(/[\dA-Fa-f]/), fC = tr(/[!-/:-@[-`{-~]/);
function de(e) {
  return e !== null && e < -2;
}
function ze(e) {
  return e !== null && (e < 0 || e === 32);
}
function be(e) {
  return e === -2 || e === -1 || e === 32;
}
const ps = tr(new RegExp("\\p{P}|\\p{S}", "u")), mr = tr(/\s/);
function tr(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function fi(e) {
  const t = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < e.length; ) {
    const o = e.charCodeAt(n);
    let a = "";
    if (o === 37 && Tt(e.charCodeAt(n + 1)) && Tt(e.charCodeAt(n + 2)))
      i = 2;
    else if (o < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(o)) || (a = String.fromCharCode(o));
    else if (o > 55295 && o < 57344) {
      const s = e.charCodeAt(n + 1);
      o < 56320 && s > 56319 && s < 57344 ? (a = String.fromCharCode(o, s), i = 1) : a = "�";
    } else
      a = String.fromCharCode(o);
    a && (t.push(e.slice(r, n), encodeURIComponent(a)), r = n + i + 1, a = ""), i && (n += i, i = 0);
  }
  return t.join("") + e.slice(r);
}
function ke(e, t, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let o = 0;
  return a;
  function a(l) {
    return be(l) ? (e.enter(n), s(l)) : t(l);
  }
  function s(l) {
    return be(l) && o++ < i ? (e.consume(l), s) : (e.exit(n), t(l));
  }
}
const dC = {
  tokenize: pC
};
function pC(e) {
  const t = e.attempt(
    this.parser.constructs.contentInitial,
    r,
    i
  );
  let n;
  return t;
  function r(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), ke(e, t, "linePrefix");
  }
  function i(s) {
    return e.enter("paragraph"), o(s);
  }
  function o(s) {
    const l = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = l), n = l, a(s);
  }
  function a(s) {
    if (s === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(s);
      return;
    }
    return de(s) ? (e.consume(s), e.exit("chunkText"), o) : (e.consume(s), a);
  }
}
const hC = {
  tokenize: vC
}, Hp = {
  tokenize: mC
};
function vC(e) {
  const t = this, n = [];
  let r = 0, i, o, a;
  return s;
  function s(x) {
    if (r < n.length) {
      const C = n[r];
      return t.containerState = C[1], e.attempt(
        C[0].continuation,
        l,
        u
      )(x);
    }
    return u(x);
  }
  function l(x) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && b();
      const C = t.events.length;
      let S = C, E;
      for (; S--; )
        if (t.events[S][0] === "exit" && t.events[S][1].type === "chunkFlow") {
          E = t.events[S][1].end;
          break;
        }
      m(r);
      let T = C;
      for (; T < t.events.length; )
        t.events[T][1].end = Object.assign({}, E), T++;
      return Zt(
        t.events,
        S + 1,
        0,
        t.events.slice(C)
      ), t.events.length = T, u(x);
    }
    return s(x);
  }
  function u(x) {
    if (r === n.length) {
      if (!i)
        return p(x);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return v(x);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(
      Hp,
      c,
      f
    )(x);
  }
  function c(x) {
    return i && b(), m(r), p(x);
  }
  function f(x) {
    return t.parser.lazy[t.now().line] = r !== n.length, a = t.now().offset, v(x);
  }
  function p(x) {
    return t.containerState = {}, e.attempt(
      Hp,
      d,
      v
    )(x);
  }
  function d(x) {
    return r++, n.push([t.currentConstruct, t.containerState]), p(x);
  }
  function v(x) {
    if (x === null) {
      i && b(), m(0), e.consume(x);
      return;
    }
    return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: o,
      _tokenizer: i
    }), h(x);
  }
  function h(x) {
    if (x === null) {
      g(e.exit("chunkFlow"), !0), m(0), e.consume(x);
      return;
    }
    return de(x) ? (e.consume(x), g(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, s) : (e.consume(x), h);
  }
  function g(x, C) {
    const S = t.sliceStream(x);
    if (C && S.push(null), x.previous = o, o && (o.next = x), o = x, i.defineSkip(x.start), i.write(S), t.parser.lazy[x.start.line]) {
      let E = i.events.length;
      for (; E--; )
        if (
          // The token starts before the line ending…
          i.events[E][1].start.offset < a && // …and either is not ended yet…
          (!i.events[E][1].end || // …or ends after it.
          i.events[E][1].end.offset > a)
        )
          return;
      const T = t.events.length;
      let N = T, j, O;
      for (; N--; )
        if (t.events[N][0] === "exit" && t.events[N][1].type === "chunkFlow") {
          if (j) {
            O = t.events[N][1].end;
            break;
          }
          j = !0;
        }
      for (m(r), E = T; E < t.events.length; )
        t.events[E][1].end = Object.assign({}, O), E++;
      Zt(
        t.events,
        N + 1,
        0,
        t.events.slice(T)
      ), t.events.length = E;
    }
  }
  function m(x) {
    let C = n.length;
    for (; C-- > x; ) {
      const S = n[C];
      t.containerState = S[1], S[0].exit.call(t, e);
    }
    n.length = x;
  }
  function b() {
    i.write([null]), o = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function mC(e, t, n) {
  return ke(
    e,
    e.attempt(this.parser.constructs.document, t, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function Na(e) {
  if (e === null || ze(e) || mr(e))
    return 1;
  if (ps(e))
    return 2;
}
function hs(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const o = e[i].resolveAll;
    o && !r.includes(o) && (t = o(t, n), r.push(o));
  }
  return t;
}
const rc = {
  name: "attention",
  tokenize: yC,
  resolveAll: gC
};
function gC(e, t) {
  let n = -1, r, i, o, a, s, l, u, c;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          l = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const f = Object.assign({}, e[r][1].end), p = Object.assign({}, e[n][1].start);
          Vp(f, -l), Vp(p, l), a = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: f,
            end: Object.assign({}, e[r][1].end)
          }, s = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e[n][1].start),
            end: p
          }, o = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e[r][1].end),
            end: Object.assign({}, e[n][1].start)
          }, i = {
            type: l > 1 ? "strong" : "emphasis",
            start: Object.assign({}, a.start),
            end: Object.assign({}, s.end)
          }, e[r][1].end = Object.assign({}, a.start), e[n][1].start = Object.assign({}, s.end), u = [], e[r][1].end.offset - e[r][1].start.offset && (u = Yt(u, [["enter", e[r][1], t], ["exit", e[r][1], t]])), u = Yt(u, [["enter", i, t], ["enter", a, t], ["exit", a, t], ["enter", o, t]]), u = Yt(u, hs(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), u = Yt(u, [["exit", o, t], ["enter", s, t], ["exit", s, t], ["exit", i, t]]), e[n][1].end.offset - e[n][1].start.offset ? (c = 2, u = Yt(u, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : c = 0, Zt(e, r - 1, n - r + 3, u), n = r + u.length - c - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function yC(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = Na(r);
  let o;
  return a;
  function a(l) {
    return o = l, e.enter("attentionSequence"), s(l);
  }
  function s(l) {
    if (l === o)
      return e.consume(l), s;
    const u = e.exit("attentionSequence"), c = Na(l), f = !c || c === 2 && i || n.includes(l), p = !i || i === 2 && c || n.includes(r);
    return u._open = !!(o === 42 ? f : f && (i || !p)), u._close = !!(o === 42 ? p : p && (c || !f)), t(l);
  }
}
function Vp(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const bC = {
  name: "autolink",
  tokenize: xC
};
function xC(e, t, n) {
  let r = 0;
  return i;
  function i(d) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(d), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), o;
  }
  function o(d) {
    return Dt(d) ? (e.consume(d), a) : d === 64 ? n(d) : u(d);
  }
  function a(d) {
    return d === 43 || d === 45 || d === 46 || Tt(d) ? (r = 1, s(d)) : u(d);
  }
  function s(d) {
    return d === 58 ? (e.consume(d), r = 0, l) : (d === 43 || d === 45 || d === 46 || Tt(d)) && r++ < 32 ? (e.consume(d), s) : (r = 0, u(d));
  }
  function l(d) {
    return d === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(d), e.exit("autolinkMarker"), e.exit("autolink"), t) : d === null || d === 32 || d === 60 || ja(d) ? n(d) : (e.consume(d), l);
  }
  function u(d) {
    return d === 64 ? (e.consume(d), c) : uC(d) ? (e.consume(d), u) : n(d);
  }
  function c(d) {
    return Tt(d) ? f(d) : n(d);
  }
  function f(d) {
    return d === 46 ? (e.consume(d), r = 0, c) : d === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(d), e.exit("autolinkMarker"), e.exit("autolink"), t) : p(d);
  }
  function p(d) {
    if ((d === 45 || Tt(d)) && r++ < 63) {
      const v = d === 45 ? p : f;
      return e.consume(d), v;
    }
    return n(d);
  }
}
const po = {
  tokenize: wC,
  partial: !0
};
function wC(e, t, n) {
  return r;
  function r(o) {
    return be(o) ? ke(e, i, "linePrefix")(o) : i(o);
  }
  function i(o) {
    return o === null || de(o) ? t(o) : n(o);
  }
}
const ob = {
  name: "blockQuote",
  tokenize: SC,
  continuation: {
    tokenize: EC
  },
  exit: kC
};
function SC(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    if (a === 62) {
      const s = r.containerState;
      return s.open || (e.enter("blockQuote", {
        _container: !0
      }), s.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(a), e.exit("blockQuoteMarker"), o;
    }
    return n(a);
  }
  function o(a) {
    return be(a) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(a), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(a));
  }
}
function EC(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return be(a) ? ke(e, o, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a) : o(a);
  }
  function o(a) {
    return e.attempt(ob, t, n)(a);
  }
}
function kC(e) {
  e.exit("blockQuote");
}
const ab = {
  name: "characterEscape",
  tokenize: CC
};
function CC(e, t, n) {
  return r;
  function r(o) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(o), e.exit("escapeMarker"), i;
  }
  function i(o) {
    return fC(o) ? (e.enter("characterEscapeValue"), e.consume(o), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(o);
  }
}
const sb = {
  name: "characterReference",
  tokenize: $C
};
function $C(e, t, n) {
  const r = this;
  let i = 0, o, a;
  return s;
  function s(f) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), l;
  }
  function l(f) {
    return f === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(f), e.exit("characterReferenceMarkerNumeric"), u) : (e.enter("characterReferenceValue"), o = 31, a = Tt, c(f));
  }
  function u(f) {
    return f === 88 || f === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(f), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), o = 6, a = cC, c) : (e.enter("characterReferenceValue"), o = 7, a = nc, c(f));
  }
  function c(f) {
    if (f === 59 && i) {
      const p = e.exit("characterReferenceValue");
      return a === Tt && !Ef(r.sliceSerialize(p)) ? n(f) : (e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return a(f) && i++ < o ? (e.consume(f), c) : n(f);
  }
}
const Kp = {
  tokenize: OC,
  partial: !0
}, qp = {
  name: "codeFenced",
  tokenize: TC,
  concrete: !0
};
function TC(e, t, n) {
  const r = this, i = {
    tokenize: S,
    partial: !0
  };
  let o = 0, a = 0, s;
  return l;
  function l(E) {
    return u(E);
  }
  function u(E) {
    const T = r.events[r.events.length - 1];
    return o = T && T[1].type === "linePrefix" ? T[2].sliceSerialize(T[1], !0).length : 0, s = E, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), c(E);
  }
  function c(E) {
    return E === s ? (a++, e.consume(E), c) : a < 3 ? n(E) : (e.exit("codeFencedFenceSequence"), be(E) ? ke(e, f, "whitespace")(E) : f(E));
  }
  function f(E) {
    return E === null || de(E) ? (e.exit("codeFencedFence"), r.interrupt ? t(E) : e.check(Kp, h, C)(E)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), p(E));
  }
  function p(E) {
    return E === null || de(E) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), f(E)) : be(E) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), ke(e, d, "whitespace")(E)) : E === 96 && E === s ? n(E) : (e.consume(E), p);
  }
  function d(E) {
    return E === null || de(E) ? f(E) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), v(E));
  }
  function v(E) {
    return E === null || de(E) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), f(E)) : E === 96 && E === s ? n(E) : (e.consume(E), v);
  }
  function h(E) {
    return e.attempt(i, C, g)(E);
  }
  function g(E) {
    return e.enter("lineEnding"), e.consume(E), e.exit("lineEnding"), m;
  }
  function m(E) {
    return o > 0 && be(E) ? ke(e, b, "linePrefix", o + 1)(E) : b(E);
  }
  function b(E) {
    return E === null || de(E) ? e.check(Kp, h, C)(E) : (e.enter("codeFlowValue"), x(E));
  }
  function x(E) {
    return E === null || de(E) ? (e.exit("codeFlowValue"), b(E)) : (e.consume(E), x);
  }
  function C(E) {
    return e.exit("codeFenced"), t(E);
  }
  function S(E, T, N) {
    let j = 0;
    return O;
    function O(A) {
      return E.enter("lineEnding"), E.consume(A), E.exit("lineEnding"), _;
    }
    function _(A) {
      return E.enter("codeFencedFence"), be(A) ? ke(E, V, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(A) : V(A);
    }
    function V(A) {
      return A === s ? (E.enter("codeFencedFenceSequence"), L(A)) : N(A);
    }
    function L(A) {
      return A === s ? (j++, E.consume(A), L) : j >= a ? (E.exit("codeFencedFenceSequence"), be(A) ? ke(E, I, "whitespace")(A) : I(A)) : N(A);
    }
    function I(A) {
      return A === null || de(A) ? (E.exit("codeFencedFence"), T(A)) : N(A);
    }
  }
}
function OC(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return a === null ? n(a) : (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), o);
  }
  function o(a) {
    return r.parser.lazy[r.now().line] ? n(a) : t(a);
  }
}
const ul = {
  name: "codeIndented",
  tokenize: RC
}, IC = {
  tokenize: PC,
  partial: !0
};
function RC(e, t, n) {
  const r = this;
  return i;
  function i(u) {
    return e.enter("codeIndented"), ke(e, o, "linePrefix", 5)(u);
  }
  function o(u) {
    const c = r.events[r.events.length - 1];
    return c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? a(u) : n(u);
  }
  function a(u) {
    return u === null ? l(u) : de(u) ? e.attempt(IC, a, l)(u) : (e.enter("codeFlowValue"), s(u));
  }
  function s(u) {
    return u === null || de(u) ? (e.exit("codeFlowValue"), a(u)) : (e.consume(u), s);
  }
  function l(u) {
    return e.exit("codeIndented"), t(u);
  }
}
function PC(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return r.parser.lazy[r.now().line] ? n(a) : de(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), i) : ke(e, o, "linePrefix", 5)(a);
  }
  function o(a) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(a) : de(a) ? i(a) : n(a);
  }
}
const AC = {
  name: "codeText",
  tokenize: MC,
  resolve: DC,
  previous: _C
};
function DC(e) {
  let t = e.length - 4, n = 3, r, i;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    i === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (i = r) : (r === t || e[r][1].type === "lineEnding") && (e[i][1].type = "codeTextData", r !== i + 2 && (e[i][1].end = e[r - 1][1].end, e.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0);
  return e;
}
function _C(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function MC(e, t, n) {
  let r = 0, i, o;
  return a;
  function a(f) {
    return e.enter("codeText"), e.enter("codeTextSequence"), s(f);
  }
  function s(f) {
    return f === 96 ? (e.consume(f), r++, s) : (e.exit("codeTextSequence"), l(f));
  }
  function l(f) {
    return f === null ? n(f) : f === 32 ? (e.enter("space"), e.consume(f), e.exit("space"), l) : f === 96 ? (o = e.enter("codeTextSequence"), i = 0, c(f)) : de(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), l) : (e.enter("codeTextData"), u(f));
  }
  function u(f) {
    return f === null || f === 32 || f === 96 || de(f) ? (e.exit("codeTextData"), l(f)) : (e.consume(f), u);
  }
  function c(f) {
    return f === 96 ? (e.consume(f), i++, c) : i === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(f)) : (o.type = "codeTextData", u(f));
  }
}
class jC {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const i = n || 0;
    this.setCursor(Math.trunc(t));
    const o = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && Ii(this.left, r), o.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), Ii(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), Ii(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        Ii(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        Ii(this.left, n.reverse());
      }
  }
}
function Ii(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function lb(e) {
  const t = {};
  let n = -1, r, i, o, a, s, l, u;
  const c = new jC(e);
  for (; ++n < c.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = c.get(n), n && r[1].type === "chunkFlow" && c.get(n - 1)[1].type === "listItemPrefix" && (l = r[1]._tokenizer.events, o = 0, o < l.length && l[o][1].type === "lineEndingBlank" && (o += 2), o < l.length && l[o][1].type === "content"))
      for (; ++o < l.length && l[o][1].type !== "content"; )
        l[o][1].type === "chunkText" && (l[o][1]._isInFirstContentOfListItem = !0, o++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, NC(c, n)), n = t[n], u = !0);
    else if (r[1]._container) {
      for (o = n, i = void 0; o-- && (a = c.get(o), a[1].type === "lineEnding" || a[1].type === "lineEndingBlank"); )
        a[0] === "enter" && (i && (c.get(i)[1].type = "lineEndingBlank"), a[1].type = "lineEnding", i = o);
      i && (r[1].end = Object.assign({}, c.get(i)[1].start), s = c.slice(i, n), s.unshift(r), c.splice(i, n - i + 1, s));
    }
  }
  return Zt(e, 0, Number.POSITIVE_INFINITY, c.slice(0)), !u;
}
function NC(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let i = t - 1;
  const o = [], a = n._tokenizer || r.parser[n.contentType](n.start), s = a.events, l = [], u = {};
  let c, f, p = -1, d = n, v = 0, h = 0;
  const g = [h];
  for (; d; ) {
    for (; e.get(++i)[1] !== d; )
      ;
    o.push(i), d._tokenizer || (c = r.sliceStream(d), d.next || c.push(null), f && a.defineSkip(d.start), d._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = !0), a.write(c), d._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = void 0)), f = d, d = d.next;
  }
  for (d = n; ++p < s.length; )
    // Find a void token that includes a break.
    s[p][0] === "exit" && s[p - 1][0] === "enter" && s[p][1].type === s[p - 1][1].type && s[p][1].start.line !== s[p][1].end.line && (h = p + 1, g.push(h), d._tokenizer = void 0, d.previous = void 0, d = d.next);
  for (a.events = [], d ? (d._tokenizer = void 0, d.previous = void 0) : g.pop(), p = g.length; p--; ) {
    const m = s.slice(g[p], g[p + 1]), b = o.pop();
    l.push([b, b + m.length - 1]), e.splice(b, 2, m);
  }
  for (l.reverse(), p = -1; ++p < l.length; )
    u[v + l[p][0]] = v + l[p][1], v += l[p][1] - l[p][0] - 1;
  return u;
}
const LC = {
  tokenize: zC,
  resolve: BC
}, FC = {
  tokenize: WC,
  partial: !0
};
function BC(e) {
  return lb(e), e;
}
function zC(e, t) {
  let n;
  return r;
  function r(s) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), i(s);
  }
  function i(s) {
    return s === null ? o(s) : de(s) ? e.check(FC, a, o)(s) : (e.consume(s), i);
  }
  function o(s) {
    return e.exit("chunkContent"), e.exit("content"), t(s);
  }
  function a(s) {
    return e.consume(s), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function WC(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), ke(e, o, "linePrefix");
  }
  function o(a) {
    if (a === null || de(a))
      return n(a);
    const s = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(a) : e.interrupt(r.parser.constructs.flow, n, t)(a);
  }
}
function ub(e, t, n, r, i, o, a, s, l) {
  const u = l || Number.POSITIVE_INFINITY;
  let c = 0;
  return f;
  function f(m) {
    return m === 60 ? (e.enter(r), e.enter(i), e.enter(o), e.consume(m), e.exit(o), p) : m === null || m === 32 || m === 41 || ja(m) ? n(m) : (e.enter(r), e.enter(a), e.enter(s), e.enter("chunkString", {
      contentType: "string"
    }), h(m));
  }
  function p(m) {
    return m === 62 ? (e.enter(o), e.consume(m), e.exit(o), e.exit(i), e.exit(r), t) : (e.enter(s), e.enter("chunkString", {
      contentType: "string"
    }), d(m));
  }
  function d(m) {
    return m === 62 ? (e.exit("chunkString"), e.exit(s), p(m)) : m === null || m === 60 || de(m) ? n(m) : (e.consume(m), m === 92 ? v : d);
  }
  function v(m) {
    return m === 60 || m === 62 || m === 92 ? (e.consume(m), d) : d(m);
  }
  function h(m) {
    return !c && (m === null || m === 41 || ze(m)) ? (e.exit("chunkString"), e.exit(s), e.exit(a), e.exit(r), t(m)) : c < u && m === 40 ? (e.consume(m), c++, h) : m === 41 ? (e.consume(m), c--, h) : m === null || m === 32 || m === 40 || ja(m) ? n(m) : (e.consume(m), m === 92 ? g : h);
  }
  function g(m) {
    return m === 40 || m === 41 || m === 92 ? (e.consume(m), h) : h(m);
  }
}
function cb(e, t, n, r, i, o) {
  const a = this;
  let s = 0, l;
  return u;
  function u(d) {
    return e.enter(r), e.enter(i), e.consume(d), e.exit(i), e.enter(o), c;
  }
  function c(d) {
    return s > 999 || d === null || d === 91 || d === 93 && !l || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    d === 94 && !s && "_hiddenFootnoteSupport" in a.parser.constructs ? n(d) : d === 93 ? (e.exit(o), e.enter(i), e.consume(d), e.exit(i), e.exit(r), t) : de(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), c) : (e.enter("chunkString", {
      contentType: "string"
    }), f(d));
  }
  function f(d) {
    return d === null || d === 91 || d === 93 || de(d) || s++ > 999 ? (e.exit("chunkString"), c(d)) : (e.consume(d), l || (l = !be(d)), d === 92 ? p : f);
  }
  function p(d) {
    return d === 91 || d === 92 || d === 93 ? (e.consume(d), s++, f) : f(d);
  }
}
function fb(e, t, n, r, i, o) {
  let a;
  return s;
  function s(p) {
    return p === 34 || p === 39 || p === 40 ? (e.enter(r), e.enter(i), e.consume(p), e.exit(i), a = p === 40 ? 41 : p, l) : n(p);
  }
  function l(p) {
    return p === a ? (e.enter(i), e.consume(p), e.exit(i), e.exit(r), t) : (e.enter(o), u(p));
  }
  function u(p) {
    return p === a ? (e.exit(o), l(a)) : p === null ? n(p) : de(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), ke(e, u, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), c(p));
  }
  function c(p) {
    return p === a || p === null || de(p) ? (e.exit("chunkString"), u(p)) : (e.consume(p), p === 92 ? f : c);
  }
  function f(p) {
    return p === a || p === 92 ? (e.consume(p), c) : c(p);
  }
}
function Hi(e, t) {
  let n;
  return r;
  function r(i) {
    return de(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), n = !0, r) : be(i) ? ke(
      e,
      r,
      n ? "linePrefix" : "lineSuffix"
    )(i) : t(i);
  }
}
const UC = {
  name: "definition",
  tokenize: VC
}, HC = {
  tokenize: KC,
  partial: !0
};
function VC(e, t, n) {
  const r = this;
  let i;
  return o;
  function o(d) {
    return e.enter("definition"), a(d);
  }
  function a(d) {
    return cb.call(
      r,
      e,
      s,
      // Note: we don’t need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(d);
  }
  function s(d) {
    return i = ln(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), d === 58 ? (e.enter("definitionMarker"), e.consume(d), e.exit("definitionMarker"), l) : n(d);
  }
  function l(d) {
    return ze(d) ? Hi(e, u)(d) : u(d);
  }
  function u(d) {
    return ub(
      e,
      c,
      // Note: we don’t need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(d);
  }
  function c(d) {
    return e.attempt(HC, f, f)(d);
  }
  function f(d) {
    return be(d) ? ke(e, p, "whitespace")(d) : p(d);
  }
  function p(d) {
    return d === null || de(d) ? (e.exit("definition"), r.parser.defined.push(i), t(d)) : n(d);
  }
}
function KC(e, t, n) {
  return r;
  function r(s) {
    return ze(s) ? Hi(e, i)(s) : n(s);
  }
  function i(s) {
    return fb(e, o, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(s);
  }
  function o(s) {
    return be(s) ? ke(e, a, "whitespace")(s) : a(s);
  }
  function a(s) {
    return s === null || de(s) ? t(s) : n(s);
  }
}
const qC = {
  name: "hardBreakEscape",
  tokenize: GC
};
function GC(e, t, n) {
  return r;
  function r(o) {
    return e.enter("hardBreakEscape"), e.consume(o), i;
  }
  function i(o) {
    return de(o) ? (e.exit("hardBreakEscape"), t(o)) : n(o);
  }
}
const YC = {
  name: "headingAtx",
  tokenize: JC,
  resolve: XC
};
function XC(e, t) {
  let n = e.length - 2, r = 3, i, o;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, o = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, Zt(e, r, n - r + 1, [["enter", i, t], ["enter", o, t], ["exit", o, t], ["exit", i, t]])), e;
}
function JC(e, t, n) {
  let r = 0;
  return i;
  function i(c) {
    return e.enter("atxHeading"), o(c);
  }
  function o(c) {
    return e.enter("atxHeadingSequence"), a(c);
  }
  function a(c) {
    return c === 35 && r++ < 6 ? (e.consume(c), a) : c === null || ze(c) ? (e.exit("atxHeadingSequence"), s(c)) : n(c);
  }
  function s(c) {
    return c === 35 ? (e.enter("atxHeadingSequence"), l(c)) : c === null || de(c) ? (e.exit("atxHeading"), t(c)) : be(c) ? ke(e, s, "whitespace")(c) : (e.enter("atxHeadingText"), u(c));
  }
  function l(c) {
    return c === 35 ? (e.consume(c), l) : (e.exit("atxHeadingSequence"), s(c));
  }
  function u(c) {
    return c === null || c === 35 || ze(c) ? (e.exit("atxHeadingText"), s(c)) : (e.consume(c), u);
  }
}
const ZC = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Gp = ["pre", "script", "style", "textarea"], QC = {
  name: "htmlFlow",
  tokenize: r$,
  resolveTo: n$,
  concrete: !0
}, e$ = {
  tokenize: o$,
  partial: !0
}, t$ = {
  tokenize: i$,
  partial: !0
};
function n$(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function r$(e, t, n) {
  const r = this;
  let i, o, a, s, l;
  return u;
  function u(w) {
    return c(w);
  }
  function c(w) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(w), f;
  }
  function f(w) {
    return w === 33 ? (e.consume(w), p) : w === 47 ? (e.consume(w), o = !0, h) : w === 63 ? (e.consume(w), i = 3, r.interrupt ? t : y) : Dt(w) ? (e.consume(w), a = String.fromCharCode(w), g) : n(w);
  }
  function p(w) {
    return w === 45 ? (e.consume(w), i = 2, d) : w === 91 ? (e.consume(w), i = 5, s = 0, v) : Dt(w) ? (e.consume(w), i = 4, r.interrupt ? t : y) : n(w);
  }
  function d(w) {
    return w === 45 ? (e.consume(w), r.interrupt ? t : y) : n(w);
  }
  function v(w) {
    const U = "CDATA[";
    return w === U.charCodeAt(s++) ? (e.consume(w), s === U.length ? r.interrupt ? t : V : v) : n(w);
  }
  function h(w) {
    return Dt(w) ? (e.consume(w), a = String.fromCharCode(w), g) : n(w);
  }
  function g(w) {
    if (w === null || w === 47 || w === 62 || ze(w)) {
      const U = w === 47, Y = a.toLowerCase();
      return !U && !o && Gp.includes(Y) ? (i = 1, r.interrupt ? t(w) : V(w)) : ZC.includes(a.toLowerCase()) ? (i = 6, U ? (e.consume(w), m) : r.interrupt ? t(w) : V(w)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(w) : o ? b(w) : x(w));
    }
    return w === 45 || Tt(w) ? (e.consume(w), a += String.fromCharCode(w), g) : n(w);
  }
  function m(w) {
    return w === 62 ? (e.consume(w), r.interrupt ? t : V) : n(w);
  }
  function b(w) {
    return be(w) ? (e.consume(w), b) : O(w);
  }
  function x(w) {
    return w === 47 ? (e.consume(w), O) : w === 58 || w === 95 || Dt(w) ? (e.consume(w), C) : be(w) ? (e.consume(w), x) : O(w);
  }
  function C(w) {
    return w === 45 || w === 46 || w === 58 || w === 95 || Tt(w) ? (e.consume(w), C) : S(w);
  }
  function S(w) {
    return w === 61 ? (e.consume(w), E) : be(w) ? (e.consume(w), S) : x(w);
  }
  function E(w) {
    return w === null || w === 60 || w === 61 || w === 62 || w === 96 ? n(w) : w === 34 || w === 39 ? (e.consume(w), l = w, T) : be(w) ? (e.consume(w), E) : N(w);
  }
  function T(w) {
    return w === l ? (e.consume(w), l = null, j) : w === null || de(w) ? n(w) : (e.consume(w), T);
  }
  function N(w) {
    return w === null || w === 34 || w === 39 || w === 47 || w === 60 || w === 61 || w === 62 || w === 96 || ze(w) ? S(w) : (e.consume(w), N);
  }
  function j(w) {
    return w === 47 || w === 62 || be(w) ? x(w) : n(w);
  }
  function O(w) {
    return w === 62 ? (e.consume(w), _) : n(w);
  }
  function _(w) {
    return w === null || de(w) ? V(w) : be(w) ? (e.consume(w), _) : n(w);
  }
  function V(w) {
    return w === 45 && i === 2 ? (e.consume(w), M) : w === 60 && i === 1 ? (e.consume(w), q) : w === 62 && i === 4 ? (e.consume(w), D) : w === 63 && i === 3 ? (e.consume(w), y) : w === 93 && i === 5 ? (e.consume(w), P) : de(w) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.check(e$, B, L)(w)) : w === null || de(w) ? (e.exit("htmlFlowData"), L(w)) : (e.consume(w), V);
  }
  function L(w) {
    return e.check(t$, I, B)(w);
  }
  function I(w) {
    return e.enter("lineEnding"), e.consume(w), e.exit("lineEnding"), A;
  }
  function A(w) {
    return w === null || de(w) ? L(w) : (e.enter("htmlFlowData"), V(w));
  }
  function M(w) {
    return w === 45 ? (e.consume(w), y) : V(w);
  }
  function q(w) {
    return w === 47 ? (e.consume(w), a = "", W) : V(w);
  }
  function W(w) {
    if (w === 62) {
      const U = a.toLowerCase();
      return Gp.includes(U) ? (e.consume(w), D) : V(w);
    }
    return Dt(w) && a.length < 8 ? (e.consume(w), a += String.fromCharCode(w), W) : V(w);
  }
  function P(w) {
    return w === 93 ? (e.consume(w), y) : V(w);
  }
  function y(w) {
    return w === 62 ? (e.consume(w), D) : w === 45 && i === 2 ? (e.consume(w), y) : V(w);
  }
  function D(w) {
    return w === null || de(w) ? (e.exit("htmlFlowData"), B(w)) : (e.consume(w), D);
  }
  function B(w) {
    return e.exit("htmlFlow"), t(w);
  }
}
function i$(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return de(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), o) : n(a);
  }
  function o(a) {
    return r.parser.lazy[r.now().line] ? n(a) : t(a);
  }
}
function o$(e, t, n) {
  return r;
  function r(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(po, t, n);
  }
}
const a$ = {
  name: "htmlText",
  tokenize: s$
};
function s$(e, t, n) {
  const r = this;
  let i, o, a;
  return s;
  function s(y) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(y), l;
  }
  function l(y) {
    return y === 33 ? (e.consume(y), u) : y === 47 ? (e.consume(y), S) : y === 63 ? (e.consume(y), x) : Dt(y) ? (e.consume(y), N) : n(y);
  }
  function u(y) {
    return y === 45 ? (e.consume(y), c) : y === 91 ? (e.consume(y), o = 0, v) : Dt(y) ? (e.consume(y), b) : n(y);
  }
  function c(y) {
    return y === 45 ? (e.consume(y), d) : n(y);
  }
  function f(y) {
    return y === null ? n(y) : y === 45 ? (e.consume(y), p) : de(y) ? (a = f, q(y)) : (e.consume(y), f);
  }
  function p(y) {
    return y === 45 ? (e.consume(y), d) : f(y);
  }
  function d(y) {
    return y === 62 ? M(y) : y === 45 ? p(y) : f(y);
  }
  function v(y) {
    const D = "CDATA[";
    return y === D.charCodeAt(o++) ? (e.consume(y), o === D.length ? h : v) : n(y);
  }
  function h(y) {
    return y === null ? n(y) : y === 93 ? (e.consume(y), g) : de(y) ? (a = h, q(y)) : (e.consume(y), h);
  }
  function g(y) {
    return y === 93 ? (e.consume(y), m) : h(y);
  }
  function m(y) {
    return y === 62 ? M(y) : y === 93 ? (e.consume(y), m) : h(y);
  }
  function b(y) {
    return y === null || y === 62 ? M(y) : de(y) ? (a = b, q(y)) : (e.consume(y), b);
  }
  function x(y) {
    return y === null ? n(y) : y === 63 ? (e.consume(y), C) : de(y) ? (a = x, q(y)) : (e.consume(y), x);
  }
  function C(y) {
    return y === 62 ? M(y) : x(y);
  }
  function S(y) {
    return Dt(y) ? (e.consume(y), E) : n(y);
  }
  function E(y) {
    return y === 45 || Tt(y) ? (e.consume(y), E) : T(y);
  }
  function T(y) {
    return de(y) ? (a = T, q(y)) : be(y) ? (e.consume(y), T) : M(y);
  }
  function N(y) {
    return y === 45 || Tt(y) ? (e.consume(y), N) : y === 47 || y === 62 || ze(y) ? j(y) : n(y);
  }
  function j(y) {
    return y === 47 ? (e.consume(y), M) : y === 58 || y === 95 || Dt(y) ? (e.consume(y), O) : de(y) ? (a = j, q(y)) : be(y) ? (e.consume(y), j) : M(y);
  }
  function O(y) {
    return y === 45 || y === 46 || y === 58 || y === 95 || Tt(y) ? (e.consume(y), O) : _(y);
  }
  function _(y) {
    return y === 61 ? (e.consume(y), V) : de(y) ? (a = _, q(y)) : be(y) ? (e.consume(y), _) : j(y);
  }
  function V(y) {
    return y === null || y === 60 || y === 61 || y === 62 || y === 96 ? n(y) : y === 34 || y === 39 ? (e.consume(y), i = y, L) : de(y) ? (a = V, q(y)) : be(y) ? (e.consume(y), V) : (e.consume(y), I);
  }
  function L(y) {
    return y === i ? (e.consume(y), i = void 0, A) : y === null ? n(y) : de(y) ? (a = L, q(y)) : (e.consume(y), L);
  }
  function I(y) {
    return y === null || y === 34 || y === 39 || y === 60 || y === 61 || y === 96 ? n(y) : y === 47 || y === 62 || ze(y) ? j(y) : (e.consume(y), I);
  }
  function A(y) {
    return y === 47 || y === 62 || ze(y) ? j(y) : n(y);
  }
  function M(y) {
    return y === 62 ? (e.consume(y), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(y);
  }
  function q(y) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(y), e.exit("lineEnding"), W;
  }
  function W(y) {
    return be(y) ? ke(e, P, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(y) : P(y);
  }
  function P(y) {
    return e.enter("htmlTextData"), a(y);
  }
}
const kf = {
  name: "labelEnd",
  tokenize: p$,
  resolveTo: d$,
  resolveAll: f$
}, l$ = {
  tokenize: h$
}, u$ = {
  tokenize: v$
}, c$ = {
  tokenize: m$
};
function f$(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const n = e[t][1];
    (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") && (e.splice(t + 1, n.type === "labelImage" ? 4 : 2), n.type = "data", t++);
  }
  return e;
}
function d$(e, t) {
  let n = e.length, r = 0, i, o, a, s;
  for (; n--; )
    if (i = e[n][1], o) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (a) {
      if (e[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (o = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (a = n);
  const l = {
    type: e[o][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e[o][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, u = {
    type: "label",
    start: Object.assign({}, e[o][1].start),
    end: Object.assign({}, e[a][1].end)
  }, c = {
    type: "labelText",
    start: Object.assign({}, e[o + r + 2][1].end),
    end: Object.assign({}, e[a - 2][1].start)
  };
  return s = [["enter", l, t], ["enter", u, t]], s = Yt(s, e.slice(o + 1, o + r + 3)), s = Yt(s, [["enter", c, t]]), s = Yt(s, hs(t.parser.constructs.insideSpan.null, e.slice(o + r + 4, a - 3), t)), s = Yt(s, [["exit", c, t], e[a - 2], e[a - 1], ["exit", u, t]]), s = Yt(s, e.slice(a + 1)), s = Yt(s, [["exit", l, t]]), Zt(e, o, e.length, s), e;
}
function p$(e, t, n) {
  const r = this;
  let i = r.events.length, o, a;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      o = r.events[i][1];
      break;
    }
  return s;
  function s(p) {
    return o ? o._inactive ? f(p) : (a = r.parser.defined.includes(ln(r.sliceSerialize({
      start: o.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(p), e.exit("labelMarker"), e.exit("labelEnd"), l) : n(p);
  }
  function l(p) {
    return p === 40 ? e.attempt(l$, c, a ? c : f)(p) : p === 91 ? e.attempt(u$, c, a ? u : f)(p) : a ? c(p) : f(p);
  }
  function u(p) {
    return e.attempt(c$, c, f)(p);
  }
  function c(p) {
    return t(p);
  }
  function f(p) {
    return o._balanced = !0, n(p);
  }
}
function h$(e, t, n) {
  return r;
  function r(f) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(f), e.exit("resourceMarker"), i;
  }
  function i(f) {
    return ze(f) ? Hi(e, o)(f) : o(f);
  }
  function o(f) {
    return f === 41 ? c(f) : ub(e, a, s, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(f);
  }
  function a(f) {
    return ze(f) ? Hi(e, l)(f) : c(f);
  }
  function s(f) {
    return n(f);
  }
  function l(f) {
    return f === 34 || f === 39 || f === 40 ? fb(e, u, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(f) : c(f);
  }
  function u(f) {
    return ze(f) ? Hi(e, c)(f) : c(f);
  }
  function c(f) {
    return f === 41 ? (e.enter("resourceMarker"), e.consume(f), e.exit("resourceMarker"), e.exit("resource"), t) : n(f);
  }
}
function v$(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return cb.call(r, e, o, a, "reference", "referenceMarker", "referenceString")(s);
  }
  function o(s) {
    return r.parser.defined.includes(ln(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(s) : n(s);
  }
  function a(s) {
    return n(s);
  }
}
function m$(e, t, n) {
  return r;
  function r(o) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), i;
  }
  function i(o) {
    return o === 93 ? (e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), e.exit("reference"), t) : n(o);
  }
}
const g$ = {
  name: "labelStartImage",
  tokenize: y$,
  resolveAll: kf.resolveAll
};
function y$(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(s), e.exit("labelImageMarker"), o;
  }
  function o(s) {
    return s === 91 ? (e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelImage"), a) : n(s);
  }
  function a(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const b$ = {
  name: "labelStartLink",
  tokenize: x$,
  resolveAll: kf.resolveAll
};
function x$(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(a), e.exit("labelMarker"), e.exit("labelLink"), o;
  }
  function o(a) {
    return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : t(a);
  }
}
const cl = {
  name: "lineEnding",
  tokenize: w$
};
function w$(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), ke(e, t, "linePrefix");
  }
}
const ya = {
  name: "thematicBreak",
  tokenize: S$
};
function S$(e, t, n) {
  let r = 0, i;
  return o;
  function o(u) {
    return e.enter("thematicBreak"), a(u);
  }
  function a(u) {
    return i = u, s(u);
  }
  function s(u) {
    return u === i ? (e.enter("thematicBreakSequence"), l(u)) : r >= 3 && (u === null || de(u)) ? (e.exit("thematicBreak"), t(u)) : n(u);
  }
  function l(u) {
    return u === i ? (e.consume(u), r++, l) : (e.exit("thematicBreakSequence"), be(u) ? ke(e, s, "whitespace")(u) : s(u));
  }
}
const Mt = {
  name: "list",
  tokenize: C$,
  continuation: {
    tokenize: $$
  },
  exit: O$
}, E$ = {
  tokenize: I$,
  partial: !0
}, k$ = {
  tokenize: T$,
  partial: !0
};
function C$(e, t, n) {
  const r = this, i = r.events[r.events.length - 1];
  let o = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, a = 0;
  return s;
  function s(d) {
    const v = r.containerState.type || (d === 42 || d === 43 || d === 45 ? "listUnordered" : "listOrdered");
    if (v === "listUnordered" ? !r.containerState.marker || d === r.containerState.marker : nc(d)) {
      if (r.containerState.type || (r.containerState.type = v, e.enter(v, {
        _container: !0
      })), v === "listUnordered")
        return e.enter("listItemPrefix"), d === 42 || d === 45 ? e.check(ya, n, u)(d) : u(d);
      if (!r.interrupt || d === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), l(d);
    }
    return n(d);
  }
  function l(d) {
    return nc(d) && ++a < 10 ? (e.consume(d), l) : (!r.interrupt || a < 2) && (r.containerState.marker ? d === r.containerState.marker : d === 41 || d === 46) ? (e.exit("listItemValue"), u(d)) : n(d);
  }
  function u(d) {
    return e.enter("listItemMarker"), e.consume(d), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || d, e.check(
      po,
      // Can’t be empty when interrupting.
      r.interrupt ? n : c,
      e.attempt(E$, p, f)
    );
  }
  function c(d) {
    return r.containerState.initialBlankLine = !0, o++, p(d);
  }
  function f(d) {
    return be(d) ? (e.enter("listItemPrefixWhitespace"), e.consume(d), e.exit("listItemPrefixWhitespace"), p) : n(d);
  }
  function p(d) {
    return r.containerState.size = o + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(d);
  }
}
function $$(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(po, i, o);
  function i(s) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, ke(e, t, "listItemIndent", r.containerState.size + 1)(s);
  }
  function o(s) {
    return r.containerState.furtherBlankLines || !be(s) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, a(s)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(k$, t, a)(s));
  }
  function a(s) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, ke(e, e.attempt(Mt, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s);
  }
}
function T$(e, t, n) {
  const r = this;
  return ke(e, i, "listItemIndent", r.containerState.size + 1);
  function i(o) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "listItemIndent" && a[2].sliceSerialize(a[1], !0).length === r.containerState.size ? t(o) : n(o);
  }
}
function O$(e) {
  e.exit(this.containerState.type);
}
function I$(e, t, n) {
  const r = this;
  return ke(e, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(o) {
    const a = r.events[r.events.length - 1];
    return !be(o) && a && a[1].type === "listItemPrefixWhitespace" ? t(o) : n(o);
  }
}
const Yp = {
  name: "setextUnderline",
  tokenize: P$,
  resolveTo: R$
};
function R$(e, t) {
  let n = e.length, r, i, o;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (i = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !o && e[n][1].type === "definition" && (o = n);
  const a = {
    type: "setextHeading",
    start: Object.assign({}, e[i][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  };
  return e[i][1].type = "setextHeadingText", o ? (e.splice(i, 0, ["enter", a, t]), e.splice(o + 1, 0, ["exit", e[r][1], t]), e[r][1].end = Object.assign({}, e[o][1].end)) : e[r][1] = a, e.push(["exit", a, t]), e;
}
function P$(e, t, n) {
  const r = this;
  let i;
  return o;
  function o(u) {
    let c = r.events.length, f;
    for (; c--; )
      if (r.events[c][1].type !== "lineEnding" && r.events[c][1].type !== "linePrefix" && r.events[c][1].type !== "content") {
        f = r.events[c][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || f) ? (e.enter("setextHeadingLine"), i = u, a(u)) : n(u);
  }
  function a(u) {
    return e.enter("setextHeadingLineSequence"), s(u);
  }
  function s(u) {
    return u === i ? (e.consume(u), s) : (e.exit("setextHeadingLineSequence"), be(u) ? ke(e, l, "lineSuffix")(u) : l(u));
  }
  function l(u) {
    return u === null || de(u) ? (e.exit("setextHeadingLine"), t(u)) : n(u);
  }
}
const A$ = {
  tokenize: D$
};
function D$(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    po,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(
      this.parser.constructs.flowInitial,
      i,
      ke(
        e,
        e.attempt(
          this.parser.constructs.flow,
          i,
          e.attempt(LC, i)
        ),
        "linePrefix"
      )
    )
  );
  return n;
  function r(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(o), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function i(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const _$ = {
  resolveAll: pb()
}, M$ = db("string"), j$ = db("text");
function db(e) {
  return {
    tokenize: t,
    resolveAll: pb(
      e === "text" ? N$ : void 0
    )
  };
  function t(n) {
    const r = this, i = this.parser.constructs[e], o = n.attempt(i, a, s);
    return a;
    function a(c) {
      return u(c) ? o(c) : s(c);
    }
    function s(c) {
      if (c === null) {
        n.consume(c);
        return;
      }
      return n.enter("data"), n.consume(c), l;
    }
    function l(c) {
      return u(c) ? (n.exit("data"), o(c)) : (n.consume(c), l);
    }
    function u(c) {
      if (c === null)
        return !0;
      const f = i[c];
      let p = -1;
      if (f)
        for (; ++p < f.length; ) {
          const d = f[p];
          if (!d.previous || d.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function pb(e) {
  return t;
  function t(n, r) {
    let i = -1, o;
    for (; ++i <= n.length; )
      o === void 0 ? n[i] && n[i][1].type === "data" && (o = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== o + 2 && (n[o][1].end = n[i - 1][1].end, n.splice(o + 2, i - o - 2), i = o + 2), o = void 0);
    return e ? e(n, r) : n;
  }
}
function N$(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], i = t.sliceStream(r);
      let o = i.length, a = -1, s = 0, l;
      for (; o--; ) {
        const u = i[o];
        if (typeof u == "string") {
          for (a = u.length; u.charCodeAt(a - 1) === 32; )
            s++, a--;
          if (a) break;
          a = -1;
        } else if (u === -2)
          l = !0, s++;
        else if (u !== -1) {
          o++;
          break;
        }
      }
      if (s) {
        const u = {
          type: n === e.length || l || s < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - s,
            offset: r.end.offset - s,
            _index: r.start._index + o,
            _bufferIndex: o ? a : r.start._bufferIndex + a
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, u.start), r.start.offset === r.end.offset ? Object.assign(r, u) : (e.splice(
          n,
          0,
          ["enter", u, t],
          ["exit", u, t]
        ), n += 2);
      }
      n++;
    }
  return e;
}
function L$(e, t, n) {
  let r = Object.assign(
    n ? Object.assign({}, n) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const i = {}, o = [];
  let a = [], s = [];
  const l = {
    consume: b,
    enter: x,
    exit: C,
    attempt: T(S),
    check: T(E),
    interrupt: T(E, {
      interrupt: !0
    })
  }, u = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: d,
    sliceSerialize: p,
    now: v,
    defineSkip: h,
    write: f
  };
  let c = t.tokenize.call(u, l);
  return t.resolveAll && o.push(t), u;
  function f(_) {
    return a = Yt(a, _), g(), a[a.length - 1] !== null ? [] : (N(t, 0), u.events = hs(o, u.events, u), u.events);
  }
  function p(_, V) {
    return B$(d(_), V);
  }
  function d(_) {
    return F$(a, _);
  }
  function v() {
    const { line: _, column: V, offset: L, _index: I, _bufferIndex: A } = r;
    return {
      line: _,
      column: V,
      offset: L,
      _index: I,
      _bufferIndex: A
    };
  }
  function h(_) {
    i[_.line] = _.column, O();
  }
  function g() {
    let _;
    for (; r._index < a.length; ) {
      const V = a[r._index];
      if (typeof V == "string")
        for (_ = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === _ && r._bufferIndex < V.length; )
          m(V.charCodeAt(r._bufferIndex));
      else
        m(V);
    }
  }
  function m(_) {
    c = c(_);
  }
  function b(_) {
    de(_) ? (r.line++, r.column = 1, r.offset += _ === -3 ? 2 : 1, O()) : _ !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === a[r._index].length && (r._bufferIndex = -1, r._index++)), u.previous = _;
  }
  function x(_, V) {
    const L = V || {};
    return L.type = _, L.start = v(), u.events.push(["enter", L, u]), s.push(L), L;
  }
  function C(_) {
    const V = s.pop();
    return V.end = v(), u.events.push(["exit", V, u]), V;
  }
  function S(_, V) {
    N(_, V.from);
  }
  function E(_, V) {
    V.restore();
  }
  function T(_, V) {
    return L;
    function L(I, A, M) {
      let q, W, P, y;
      return Array.isArray(I) ? B(I) : "tokenize" in I ? (
        // @ts-expect-error Looks like a construct.
        B([I])
      ) : D(I);
      function D(K) {
        return G;
        function G(Z) {
          const Q = Z !== null && K[Z], X = Z !== null && K.null, J = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Q) ? Q : Q ? [Q] : [],
            ...Array.isArray(X) ? X : X ? [X] : []
          ];
          return B(J)(Z);
        }
      }
      function B(K) {
        return q = K, W = 0, K.length === 0 ? M : w(K[W]);
      }
      function w(K) {
        return G;
        function G(Z) {
          return y = j(), P = K, K.partial || (u.currentConstruct = K), K.name && u.parser.constructs.disable.null.includes(K.name) ? Y() : K.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            V ? Object.assign(Object.create(u), V) : u,
            l,
            U,
            Y
          )(Z);
        }
      }
      function U(K) {
        return _(P, y), A;
      }
      function Y(K) {
        return y.restore(), ++W < q.length ? w(q[W]) : M;
      }
    }
  }
  function N(_, V) {
    _.resolveAll && !o.includes(_) && o.push(_), _.resolve && Zt(
      u.events,
      V,
      u.events.length - V,
      _.resolve(u.events.slice(V), u)
    ), _.resolveTo && (u.events = _.resolveTo(u.events, u));
  }
  function j() {
    const _ = v(), V = u.previous, L = u.currentConstruct, I = u.events.length, A = Array.from(s);
    return {
      restore: M,
      from: I
    };
    function M() {
      r = _, u.previous = V, u.currentConstruct = L, u.events.length = I, s = A, O();
    }
  }
  function O() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function F$(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, i = t.end._index, o = t.end._bufferIndex;
  let a;
  if (n === i)
    a = [e[n].slice(r, o)];
  else {
    if (a = e.slice(n, i), r > -1) {
      const s = a[0];
      typeof s == "string" ? a[0] = s.slice(r) : a.shift();
    }
    o > 0 && a.push(e[i].slice(0, o));
  }
  return a;
}
function B$(e, t) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < e.length; ) {
    const o = e[n];
    let a;
    if (typeof o == "string")
      a = o;
    else
      switch (o) {
        case -5: {
          a = "\r";
          break;
        }
        case -4: {
          a = `
`;
          break;
        }
        case -3: {
          a = `\r
`;
          break;
        }
        case -2: {
          a = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && i) continue;
          a = " ";
          break;
        }
        default:
          a = String.fromCharCode(o);
      }
    i = o === -2, r.push(a);
  }
  return r.join("");
}
const z$ = {
  42: Mt,
  43: Mt,
  45: Mt,
  48: Mt,
  49: Mt,
  50: Mt,
  51: Mt,
  52: Mt,
  53: Mt,
  54: Mt,
  55: Mt,
  56: Mt,
  57: Mt,
  62: ob
}, W$ = {
  91: UC
}, U$ = {
  [-2]: ul,
  [-1]: ul,
  32: ul
}, H$ = {
  35: YC,
  42: ya,
  45: [Yp, ya],
  60: QC,
  61: Yp,
  95: ya,
  96: qp,
  126: qp
}, V$ = {
  38: sb,
  92: ab
}, K$ = {
  [-5]: cl,
  [-4]: cl,
  [-3]: cl,
  33: g$,
  38: sb,
  42: rc,
  60: [bC, a$],
  91: b$,
  92: [qC, ab],
  93: kf,
  95: rc,
  96: AC
}, q$ = {
  null: [rc, _$]
}, G$ = {
  null: [42, 95]
}, Y$ = {
  null: []
}, X$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: G$,
  contentInitial: W$,
  disable: Y$,
  document: z$,
  flow: H$,
  flowInitial: U$,
  insideSpan: q$,
  string: V$,
  text: K$
}, Symbol.toStringTag, { value: "Module" }));
function J$(e) {
  const n = (
    /** @type {FullNormalizedExtension} */
    rb([X$, ...(e || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: n,
    content: i(dC),
    document: i(hC),
    flow: i(A$),
    string: i(M$),
    text: i(j$)
  };
  return r;
  function i(o) {
    return a;
    function a(s) {
      return L$(r, o, s);
    }
  }
}
function Z$(e) {
  for (; !lb(e); )
    ;
  return e;
}
const Xp = /[\0\t\n\r]/g;
function Q$() {
  let e = 1, t = "", n = !0, r;
  return i;
  function i(o, a, s) {
    const l = [];
    let u, c, f, p, d;
    for (o = t + (typeof o == "string" ? o.toString() : new TextDecoder(a || void 0).decode(o)), f = 0, t = "", n && (o.charCodeAt(0) === 65279 && f++, n = void 0); f < o.length; ) {
      if (Xp.lastIndex = f, u = Xp.exec(o), p = u && u.index !== void 0 ? u.index : o.length, d = o.charCodeAt(p), !u) {
        t = o.slice(f);
        break;
      }
      if (d === 10 && f === p && r)
        l.push(-3), r = void 0;
      else
        switch (r && (l.push(-5), r = void 0), f < p && (l.push(o.slice(f, p)), e += p - f), d) {
          case 0: {
            l.push(65533), e++;
            break;
          }
          case 9: {
            for (c = Math.ceil(e / 4) * 4, l.push(-2); e++ < c; ) l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      f = p + 1;
    }
    return s && (r && l.push(-5), t && l.push(t), l.push(null)), l;
  }
}
const eT = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function tT(e) {
  return e.replace(eT, nT);
}
function nT(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1), o = i === 120 || i === 88;
    return ib(n.slice(o ? 2 : 1), o ? 16 : 10);
  }
  return Ef(n) || e;
}
const hb = {}.hasOwnProperty;
function rT(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), iT(n)(Z$(J$(n).document().write(Q$()(e, t, !0))));
}
function iT(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: o(Ie),
      autolinkProtocol: j,
      autolinkEmail: j,
      atxHeading: o(fe),
      blockQuote: o(X),
      characterEscape: j,
      characterReference: j,
      codeFenced: o(J),
      codeFencedFenceInfo: a,
      codeFencedFenceMeta: a,
      codeIndented: o(J, a),
      codeText: o(H, a),
      codeTextData: j,
      data: j,
      codeFlowValue: j,
      definition: o(re),
      definitionDestinationString: a,
      definitionLabelString: a,
      definitionTitleString: a,
      emphasis: o(se),
      hardBreakEscape: o(oe),
      hardBreakTrailing: o(oe),
      htmlFlow: o(me, a),
      htmlFlowData: j,
      htmlText: o(me, a),
      htmlTextData: j,
      image: o(we),
      label: a,
      link: o(Ie),
      listItem: o(St),
      listItemValue: p,
      listOrdered: o(nt, f),
      listUnordered: o(nt),
      paragraph: o(Et),
      reference: w,
      referenceString: a,
      resourceDestinationString: a,
      resourceTitleString: a,
      setextHeading: o(fe),
      strong: o(kt),
      thematicBreak: o(ue)
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: S,
      autolink: l(),
      autolinkEmail: Q,
      autolinkProtocol: Z,
      blockQuote: l(),
      characterEscapeValue: O,
      characterReferenceMarkerHexadecimal: Y,
      characterReferenceMarkerNumeric: Y,
      characterReferenceValue: K,
      characterReference: G,
      codeFenced: l(g),
      codeFencedFence: h,
      codeFencedFenceInfo: d,
      codeFencedFenceMeta: v,
      codeFlowValue: O,
      codeIndented: l(m),
      codeText: l(A),
      codeTextData: O,
      data: O,
      definition: l(),
      definitionDestinationString: C,
      definitionLabelString: b,
      definitionTitleString: x,
      emphasis: l(),
      hardBreakEscape: l(V),
      hardBreakTrailing: l(V),
      htmlFlow: l(L),
      htmlFlowData: O,
      htmlText: l(I),
      htmlTextData: O,
      image: l(q),
      label: P,
      labelText: W,
      lineEnding: _,
      link: l(M),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: U,
      resourceDestinationString: y,
      resourceTitleString: D,
      resource: B,
      setextHeading: l(N),
      setextHeadingLineSequence: T,
      setextHeadingText: E,
      strong: l(),
      thematicBreak: l()
    }
  };
  vb(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(z) {
    let F = {
      type: "root",
      children: []
    };
    const te = {
      stack: [F],
      tokenStack: [],
      config: t,
      enter: s,
      exit: u,
      buffer: a,
      resume: c,
      data: n
    }, ae = [];
    let ce = -1;
    for (; ++ce < z.length; )
      if (z[ce][1].type === "listOrdered" || z[ce][1].type === "listUnordered")
        if (z[ce][0] === "enter")
          ae.push(ce);
        else {
          const he = ae.pop();
          ce = i(z, he, ce);
        }
    for (ce = -1; ++ce < z.length; ) {
      const he = t[z[ce][0]];
      hb.call(he, z[ce][1].type) && he[z[ce][1].type].call(Object.assign({
        sliceSerialize: z[ce][2].sliceSerialize
      }, te), z[ce][1]);
    }
    if (te.tokenStack.length > 0) {
      const he = te.tokenStack[te.tokenStack.length - 1];
      (he[1] || Jp).call(te, void 0, he[0]);
    }
    for (F.position = {
      start: zn(z.length > 0 ? z[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: zn(z.length > 0 ? z[z.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, ce = -1; ++ce < t.transforms.length; )
      F = t.transforms[ce](F) || F;
    return F;
  }
  function i(z, F, te) {
    let ae = F - 1, ce = -1, he = !1, qe, Ge, gt, rt;
    for (; ++ae <= te; ) {
      const Re = z[ae];
      switch (Re[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Re[0] === "enter" ? ce++ : ce--, rt = void 0;
          break;
        }
        case "lineEndingBlank": {
          Re[0] === "enter" && (qe && !rt && !ce && !gt && (gt = ae), rt = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          rt = void 0;
      }
      if (!ce && Re[0] === "enter" && Re[1].type === "listItemPrefix" || ce === -1 && Re[0] === "exit" && (Re[1].type === "listUnordered" || Re[1].type === "listOrdered")) {
        if (qe) {
          let it = ae;
          for (Ge = void 0; it--; ) {
            const Qe = z[it];
            if (Qe[1].type === "lineEnding" || Qe[1].type === "lineEndingBlank") {
              if (Qe[0] === "exit") continue;
              Ge && (z[Ge][1].type = "lineEndingBlank", he = !0), Qe[1].type = "lineEnding", Ge = it;
            } else if (!(Qe[1].type === "linePrefix" || Qe[1].type === "blockQuotePrefix" || Qe[1].type === "blockQuotePrefixWhitespace" || Qe[1].type === "blockQuoteMarker" || Qe[1].type === "listItemIndent")) break;
          }
          gt && (!Ge || gt < Ge) && (qe._spread = !0), qe.end = Object.assign({}, Ge ? z[Ge][1].start : Re[1].end), z.splice(Ge || ae, 0, ["exit", qe, Re[2]]), ae++, te++;
        }
        if (Re[1].type === "listItemPrefix") {
          const it = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Re[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          qe = it, z.splice(ae, 0, ["enter", it, Re[2]]), ae++, te++, gt = void 0, rt = !0;
        }
      }
    }
    return z[F][1]._spread = he, te;
  }
  function o(z, F) {
    return te;
    function te(ae) {
      s.call(this, z(ae), ae), F && F.call(this, ae);
    }
  }
  function a() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function s(z, F, te) {
    this.stack[this.stack.length - 1].children.push(z), this.stack.push(z), this.tokenStack.push([F, te]), z.position = {
      start: zn(F.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l(z) {
    return F;
    function F(te) {
      z && z.call(this, te), u.call(this, te);
    }
  }
  function u(z, F) {
    const te = this.stack.pop(), ae = this.tokenStack.pop();
    if (ae)
      ae[0].type !== z.type && (F ? F.call(this, z, ae[0]) : (ae[1] || Jp).call(this, z, ae[0]));
    else throw new Error("Cannot close `" + z.type + "` (" + Ui({
      start: z.start,
      end: z.end
    }) + "): it’s not open");
    te.position.end = zn(z.end);
  }
  function c() {
    return Sf(this.stack.pop());
  }
  function f() {
    this.data.expectingFirstListItemValue = !0;
  }
  function p(z) {
    if (this.data.expectingFirstListItemValue) {
      const F = this.stack[this.stack.length - 2];
      F.start = Number.parseInt(this.sliceSerialize(z), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function d() {
    const z = this.resume(), F = this.stack[this.stack.length - 1];
    F.lang = z;
  }
  function v() {
    const z = this.resume(), F = this.stack[this.stack.length - 1];
    F.meta = z;
  }
  function h() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function g() {
    const z = this.resume(), F = this.stack[this.stack.length - 1];
    F.value = z.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function m() {
    const z = this.resume(), F = this.stack[this.stack.length - 1];
    F.value = z.replace(/(\r?\n|\r)$/g, "");
  }
  function b(z) {
    const F = this.resume(), te = this.stack[this.stack.length - 1];
    te.label = F, te.identifier = ln(this.sliceSerialize(z)).toLowerCase();
  }
  function x() {
    const z = this.resume(), F = this.stack[this.stack.length - 1];
    F.title = z;
  }
  function C() {
    const z = this.resume(), F = this.stack[this.stack.length - 1];
    F.url = z;
  }
  function S(z) {
    const F = this.stack[this.stack.length - 1];
    if (!F.depth) {
      const te = this.sliceSerialize(z).length;
      F.depth = te;
    }
  }
  function E() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function T(z) {
    const F = this.stack[this.stack.length - 1];
    F.depth = this.sliceSerialize(z).codePointAt(0) === 61 ? 1 : 2;
  }
  function N() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function j(z) {
    const te = this.stack[this.stack.length - 1].children;
    let ae = te[te.length - 1];
    (!ae || ae.type !== "text") && (ae = ie(), ae.position = {
      start: zn(z.start),
      // @ts-expect-error: we’ll add `end` later.
      end: void 0
    }, te.push(ae)), this.stack.push(ae);
  }
  function O(z) {
    const F = this.stack.pop();
    F.value += this.sliceSerialize(z), F.position.end = zn(z.end);
  }
  function _(z) {
    const F = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const te = F.children[F.children.length - 1];
      te.position.end = zn(z.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(F.type) && (j.call(this, z), O.call(this, z));
  }
  function V() {
    this.data.atHardBreak = !0;
  }
  function L() {
    const z = this.resume(), F = this.stack[this.stack.length - 1];
    F.value = z;
  }
  function I() {
    const z = this.resume(), F = this.stack[this.stack.length - 1];
    F.value = z;
  }
  function A() {
    const z = this.resume(), F = this.stack[this.stack.length - 1];
    F.value = z;
  }
  function M() {
    const z = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const F = this.data.referenceType || "shortcut";
      z.type += "Reference", z.referenceType = F, delete z.url, delete z.title;
    } else
      delete z.identifier, delete z.label;
    this.data.referenceType = void 0;
  }
  function q() {
    const z = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const F = this.data.referenceType || "shortcut";
      z.type += "Reference", z.referenceType = F, delete z.url, delete z.title;
    } else
      delete z.identifier, delete z.label;
    this.data.referenceType = void 0;
  }
  function W(z) {
    const F = this.sliceSerialize(z), te = this.stack[this.stack.length - 2];
    te.label = tT(F), te.identifier = ln(F).toLowerCase();
  }
  function P() {
    const z = this.stack[this.stack.length - 1], F = this.resume(), te = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, te.type === "link") {
      const ae = z.children;
      te.children = ae;
    } else
      te.alt = F;
  }
  function y() {
    const z = this.resume(), F = this.stack[this.stack.length - 1];
    F.url = z;
  }
  function D() {
    const z = this.resume(), F = this.stack[this.stack.length - 1];
    F.title = z;
  }
  function B() {
    this.data.inReference = void 0;
  }
  function w() {
    this.data.referenceType = "collapsed";
  }
  function U(z) {
    const F = this.resume(), te = this.stack[this.stack.length - 1];
    te.label = F, te.identifier = ln(this.sliceSerialize(z)).toLowerCase(), this.data.referenceType = "full";
  }
  function Y(z) {
    this.data.characterReferenceType = z.type;
  }
  function K(z) {
    const F = this.sliceSerialize(z), te = this.data.characterReferenceType;
    let ae;
    te ? (ae = ib(F, te === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : ae = Ef(F);
    const ce = this.stack[this.stack.length - 1];
    ce.value += ae;
  }
  function G(z) {
    const F = this.stack.pop();
    F.position.end = zn(z.end);
  }
  function Z(z) {
    O.call(this, z);
    const F = this.stack[this.stack.length - 1];
    F.url = this.sliceSerialize(z);
  }
  function Q(z) {
    O.call(this, z);
    const F = this.stack[this.stack.length - 1];
    F.url = "mailto:" + this.sliceSerialize(z);
  }
  function X() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function J() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function H() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function re() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function se() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function fe() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function oe() {
    return {
      type: "break"
    };
  }
  function me() {
    return {
      type: "html",
      value: ""
    };
  }
  function we() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Ie() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function nt(z) {
    return {
      type: "list",
      ordered: z.type === "listOrdered",
      start: null,
      spread: z._spread,
      children: []
    };
  }
  function St(z) {
    return {
      type: "listItem",
      spread: z._spread,
      checked: null,
      children: []
    };
  }
  function Et() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function kt() {
    return {
      type: "strong",
      children: []
    };
  }
  function ie() {
    return {
      type: "text",
      value: ""
    };
  }
  function ue() {
    return {
      type: "thematicBreak"
    };
  }
}
function zn(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function vb(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? vb(e, r) : oT(e, r);
  }
}
function oT(e, t) {
  let n;
  for (n in t)
    if (hb.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function Jp(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + Ui({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + Ui({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + Ui({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function aT(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return rT(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function sT(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function lT(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function uT(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let i = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (i.data = { meta: t.meta }), e.patch(t, i), i = e.applyData(t, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, e.patch(t, i), i;
}
function cT(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function fT(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function dT(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), i = fi(r.toLowerCase()), o = e.footnoteOrder.indexOf(r);
  let a, s = e.footnoteCounts.get(r);
  s === void 0 ? (s = 0, e.footnoteOrder.push(r), a = e.footnoteOrder.length) : a = o + 1, s += 1, e.footnoteCounts.set(r, s);
  const l = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + i,
      id: n + "fnref-" + i + (s > 1 ? "-" + s : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(a) }]
  };
  e.patch(t, l);
  const u = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [l]
  };
  return e.patch(t, u), e.applyData(t, u);
}
function pT(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function hT(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function mb(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const i = e.all(t), o = i[0];
  o && o.type === "text" ? o.value = "[" + o.value : i.unshift({ type: "text", value: "[" });
  const a = i[i.length - 1];
  return a && a.type === "text" ? a.value += r : i.push({ type: "text", value: r }), i;
}
function vT(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return mb(e, t);
  const i = { src: fi(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const o = { type: "element", tagName: "img", properties: i, children: [] };
  return e.patch(t, o), e.applyData(t, o);
}
function mT(e, t) {
  const n = { src: fi(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function gT(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function yT(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return mb(e, t);
  const i = { href: fi(r.url || "") };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const o = {
    type: "element",
    tagName: "a",
    properties: i,
    children: e.all(t)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function bT(e, t) {
  const n = { href: fi(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function xT(e, t, n) {
  const r = e.all(t), i = n ? wT(n) : gb(t), o = {}, a = [];
  if (typeof t.checked == "boolean") {
    const c = r[0];
    let f;
    c && c.type === "element" && c.tagName === "p" ? f = c : (f = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(f)), f.children.length > 0 && f.children.unshift({ type: "text", value: " " }), f.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), o.className = ["task-list-item"];
  }
  let s = -1;
  for (; ++s < r.length; ) {
    const c = r[s];
    (i || s !== 0 || c.type !== "element" || c.tagName !== "p") && a.push({ type: "text", value: `
` }), c.type === "element" && c.tagName === "p" && !i ? a.push(...c.children) : a.push(c);
  }
  const l = r[r.length - 1];
  l && (i || l.type !== "element" || l.tagName !== "p") && a.push({ type: "text", value: `
` });
  const u = { type: "element", tagName: "li", properties: o, children: a };
  return e.patch(t, u), e.applyData(t, u);
}
function wT(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = gb(n[r]);
  }
  return t;
}
function gb(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function ST(e, t) {
  const n = {}, r = e.all(t);
  let i = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length; ) {
    const a = r[i];
    if (a.type === "element" && a.tagName === "li" && a.properties && Array.isArray(a.properties.className) && a.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const o = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function ET(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function kT(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function CT(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function $T(e, t) {
  const n = e.all(t), r = n.shift(), i = [];
  if (r) {
    const a = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], a), i.push(a);
  }
  if (n.length > 0) {
    const a = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, s = yf(t.children[1]), l = Xy(t.children[t.children.length - 1]);
    s && l && (a.position = { start: s, end: l }), i.push(a);
  }
  const o = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function TT(e, t, n) {
  const r = n ? n.children : void 0, o = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", a = n && n.type === "table" ? n.align : void 0, s = a ? a.length : t.children.length;
  let l = -1;
  const u = [];
  for (; ++l < s; ) {
    const f = t.children[l], p = {}, d = a ? a[l] : void 0;
    d && (p.align = d);
    let v = { type: "element", tagName: o, properties: p, children: [] };
    f && (v.children = e.all(f), e.patch(f, v), v = e.applyData(f, v)), u.push(v);
  }
  const c = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(u, !0)
  };
  return e.patch(t, c), e.applyData(t, c);
}
function OT(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const Zp = 9, Qp = 32;
function IT(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), i = 0;
  const o = [];
  for (; r; )
    o.push(
      eh(t.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(t);
  return o.push(eh(t.slice(i), i > 0, !1)), o.join("");
}
function eh(e, t, n) {
  let r = 0, i = e.length;
  if (t) {
    let o = e.codePointAt(r);
    for (; o === Zp || o === Qp; )
      r++, o = e.codePointAt(r);
  }
  if (n) {
    let o = e.codePointAt(i - 1);
    for (; o === Zp || o === Qp; )
      i--, o = e.codePointAt(i - 1);
  }
  return i > r ? e.slice(r, i) : "";
}
function RT(e, t) {
  const n = { type: "text", value: IT(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function PT(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const AT = {
  blockquote: sT,
  break: lT,
  code: uT,
  delete: cT,
  emphasis: fT,
  footnoteReference: dT,
  heading: pT,
  html: hT,
  imageReference: vT,
  image: mT,
  inlineCode: gT,
  linkReference: yT,
  link: bT,
  listItem: xT,
  list: ST,
  paragraph: ET,
  // @ts-expect-error: root is different, but hard to type.
  root: kT,
  strong: CT,
  table: $T,
  tableCell: OT,
  tableRow: TT,
  text: RT,
  thematicBreak: PT,
  toml: Wo,
  yaml: Wo,
  definition: Wo,
  footnoteDefinition: Wo
};
function Wo() {
}
const yb = -1, vs = 0, La = 1, Fa = 2, Cf = 3, $f = 4, Tf = 5, Of = 6, bb = 7, xb = 8, th = typeof self == "object" ? self : globalThis, DT = (e, t) => {
  const n = (i, o) => (e.set(o, i), i), r = (i) => {
    if (e.has(i))
      return e.get(i);
    const [o, a] = t[i];
    switch (o) {
      case vs:
      case yb:
        return n(a, i);
      case La: {
        const s = n([], i);
        for (const l of a)
          s.push(r(l));
        return s;
      }
      case Fa: {
        const s = n({}, i);
        for (const [l, u] of a)
          s[r(l)] = r(u);
        return s;
      }
      case Cf:
        return n(new Date(a), i);
      case $f: {
        const { source: s, flags: l } = a;
        return n(new RegExp(s, l), i);
      }
      case Tf: {
        const s = n(/* @__PURE__ */ new Map(), i);
        for (const [l, u] of a)
          s.set(r(l), r(u));
        return s;
      }
      case Of: {
        const s = n(/* @__PURE__ */ new Set(), i);
        for (const l of a)
          s.add(r(l));
        return s;
      }
      case bb: {
        const { name: s, message: l } = a;
        return n(new th[s](l), i);
      }
      case xb:
        return n(BigInt(a), i);
      case "BigInt":
        return n(Object(BigInt(a)), i);
    }
    return n(new th[o](a), i);
  };
  return r;
}, nh = (e) => DT(/* @__PURE__ */ new Map(), e)(0), $r = "", { toString: _T } = {}, { keys: MT } = Object, Ri = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [vs, t];
  const n = _T.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [La, $r];
    case "Object":
      return [Fa, $r];
    case "Date":
      return [Cf, $r];
    case "RegExp":
      return [$f, $r];
    case "Map":
      return [Tf, $r];
    case "Set":
      return [Of, $r];
  }
  return n.includes("Array") ? [La, n] : n.includes("Error") ? [bb, n] : [Fa, n];
}, Uo = ([e, t]) => e === vs && (t === "function" || t === "symbol"), jT = (e, t, n, r) => {
  const i = (a, s) => {
    const l = r.push(a) - 1;
    return n.set(s, l), l;
  }, o = (a) => {
    if (n.has(a))
      return n.get(a);
    let [s, l] = Ri(a);
    switch (s) {
      case vs: {
        let c = a;
        switch (l) {
          case "bigint":
            s = xb, c = a.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + l);
            c = null;
            break;
          case "undefined":
            return i([yb], a);
        }
        return i([s, c], a);
      }
      case La: {
        if (l)
          return i([l, [...a]], a);
        const c = [], f = i([s, c], a);
        for (const p of a)
          c.push(o(p));
        return f;
      }
      case Fa: {
        if (l)
          switch (l) {
            case "BigInt":
              return i([l, a.toString()], a);
            case "Boolean":
            case "Number":
            case "String":
              return i([l, a.valueOf()], a);
          }
        if (t && "toJSON" in a)
          return o(a.toJSON());
        const c = [], f = i([s, c], a);
        for (const p of MT(a))
          (e || !Uo(Ri(a[p]))) && c.push([o(p), o(a[p])]);
        return f;
      }
      case Cf:
        return i([s, a.toISOString()], a);
      case $f: {
        const { source: c, flags: f } = a;
        return i([s, { source: c, flags: f }], a);
      }
      case Tf: {
        const c = [], f = i([s, c], a);
        for (const [p, d] of a)
          (e || !(Uo(Ri(p)) || Uo(Ri(d)))) && c.push([o(p), o(d)]);
        return f;
      }
      case Of: {
        const c = [], f = i([s, c], a);
        for (const p of a)
          (e || !Uo(Ri(p))) && c.push(o(p));
        return f;
      }
    }
    const { message: u } = a;
    return i([s, { name: l, message: u }], a);
  };
  return o;
}, rh = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return jT(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, Ba = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? nh(rh(e, t)) : structuredClone(e)
) : (e, t) => nh(rh(e, t));
function NT(e, t) {
  const n = [{ type: "text", value: "↩" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function LT(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function FT(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || NT, r = e.options.footnoteBackLabel || LT, i = e.options.footnoteLabel || "Footnotes", o = e.options.footnoteLabelTagName || "h2", a = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, s = [];
  let l = -1;
  for (; ++l < e.footnoteOrder.length; ) {
    const u = e.footnoteById.get(
      e.footnoteOrder[l]
    );
    if (!u)
      continue;
    const c = e.all(u), f = String(u.identifier).toUpperCase(), p = fi(f.toLowerCase());
    let d = 0;
    const v = [], h = e.footnoteCounts.get(f);
    for (; h !== void 0 && ++d <= h; ) {
      v.length > 0 && v.push({ type: "text", value: " " });
      let b = typeof n == "string" ? n : n(l, d);
      typeof b == "string" && (b = { type: "text", value: b }), v.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + p + (d > 1 ? "-" + d : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(l, d),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(b) ? b : [b]
      });
    }
    const g = c[c.length - 1];
    if (g && g.type === "element" && g.tagName === "p") {
      const b = g.children[g.children.length - 1];
      b && b.type === "text" ? b.value += " " : g.children.push({ type: "text", value: " " }), g.children.push(...v);
    } else
      c.push(...v);
    const m = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + p },
      children: e.wrap(c, !0)
    };
    e.patch(u, m), s.push(m);
  }
  if (s.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: o,
          properties: {
            ...Ba(a),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(s, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const ms = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return UT;
    if (typeof e == "function")
      return gs(e);
    if (typeof e == "object")
      return Array.isArray(e) ? BT(e) : zT(e);
    if (typeof e == "string")
      return WT(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function BT(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = ms(e[n]);
  return gs(r);
  function r(...i) {
    let o = -1;
    for (; ++o < t.length; )
      if (t[o].apply(this, i)) return !0;
    return !1;
  }
}
function zT(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return gs(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let o;
    for (o in e)
      if (i[o] !== t[o]) return !1;
    return !0;
  }
}
function WT(e) {
  return gs(t);
  function t(n) {
    return n && n.type === e;
  }
}
function gs(e) {
  return t;
  function t(n, r, i) {
    return !!(HT(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function UT() {
  return !0;
}
function HT(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const wb = [], VT = !0, ic = !1, KT = "skip";
function Sb(e, t, n, r) {
  let i;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : i = t;
  const o = ms(i), a = r ? -1 : 1;
  s(e, void 0, [])();
  function s(l, u, c) {
    const f = (
      /** @type {Record<string, unknown>} */
      l && typeof l == "object" ? l : {}
    );
    if (typeof f.type == "string") {
      const d = (
        // `hast`
        typeof f.tagName == "string" ? f.tagName : (
          // `xast`
          typeof f.name == "string" ? f.name : void 0
        )
      );
      Object.defineProperty(p, "name", {
        value: "node (" + (l.type + (d ? "<" + d + ">" : "")) + ")"
      });
    }
    return p;
    function p() {
      let d = wb, v, h, g;
      if ((!t || o(l, u, c[c.length - 1] || void 0)) && (d = qT(n(l, c)), d[0] === ic))
        return d;
      if ("children" in l && l.children) {
        const m = (
          /** @type {UnistParent} */
          l
        );
        if (m.children && d[0] !== KT)
          for (h = (r ? m.children.length : -1) + a, g = c.concat(m); h > -1 && h < m.children.length; ) {
            const b = m.children[h];
            if (v = s(b, h, g)(), v[0] === ic)
              return v;
            h = typeof v[1] == "number" ? v[1] : h + a;
          }
      }
      return d;
    }
  }
}
function qT(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [VT, e] : e == null ? wb : [e];
}
function If(e, t, n, r) {
  let i, o, a;
  typeof t == "function" && typeof n != "function" ? (o = void 0, a = t, i = n) : (o = t, a = n, i = r), Sb(e, o, s, i);
  function s(l, u) {
    const c = u[u.length - 1], f = c ? c.children.indexOf(l) : void 0;
    return a(l, f, c);
  }
}
const oc = {}.hasOwnProperty, GT = {};
function YT(e, t) {
  const n = t || GT, r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), a = { ...AT, ...n.handlers }, s = {
    all: u,
    applyData: JT,
    definitionById: r,
    footnoteById: i,
    footnoteCounts: o,
    footnoteOrder: [],
    handlers: a,
    one: l,
    options: n,
    patch: XT,
    wrap: QT
  };
  return If(e, function(c) {
    if (c.type === "definition" || c.type === "footnoteDefinition") {
      const f = c.type === "definition" ? r : i, p = String(c.identifier).toUpperCase();
      f.has(p) || f.set(p, c);
    }
  }), s;
  function l(c, f) {
    const p = c.type, d = s.handlers[p];
    if (oc.call(s.handlers, p) && d)
      return d(s, c, f);
    if (s.options.passThrough && s.options.passThrough.includes(p)) {
      if ("children" in c) {
        const { children: h, ...g } = c, m = Ba(g);
        return m.children = s.all(c), m;
      }
      return Ba(c);
    }
    return (s.options.unknownHandler || ZT)(s, c, f);
  }
  function u(c) {
    const f = [];
    if ("children" in c) {
      const p = c.children;
      let d = -1;
      for (; ++d < p.length; ) {
        const v = s.one(p[d], c);
        if (v) {
          if (d && p[d - 1].type === "break" && (!Array.isArray(v) && v.type === "text" && (v.value = ih(v.value)), !Array.isArray(v) && v.type === "element")) {
            const h = v.children[0];
            h && h.type === "text" && (h.value = ih(h.value));
          }
          Array.isArray(v) ? f.push(...v) : f.push(v);
        }
      }
    }
    return f;
  }
}
function XT(e, t) {
  e.position && (t.position = jk(e));
}
function JT(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, i = e.data.hChildren, o = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const a = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: a };
      }
    n.type === "element" && o && Object.assign(n.properties, Ba(o)), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function ZT(e, t) {
  const n = t.data || {}, r = "value" in t && !(oc.call(n, "hProperties") || oc.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function QT(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function ih(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function oh(e, t) {
  const n = YT(e, t), r = n.one(e, void 0), i = FT(n), o = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return i && o.children.push({ type: "text", value: `
` }, i), o;
}
function eO(e, t) {
  return e && "run" in e ? async function(n, r) {
    const i = (
      /** @type {HastRoot} */
      oh(n, { file: r, ...t })
    );
    await e.run(i, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      oh(n, { file: r, ...e || t })
    );
  };
}
function ah(e) {
  if (e)
    throw e;
}
var ba = Object.prototype.hasOwnProperty, Eb = Object.prototype.toString, sh = Object.defineProperty, lh = Object.getOwnPropertyDescriptor, uh = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : Eb.call(t) === "[object Array]";
}, ch = function(t) {
  if (!t || Eb.call(t) !== "[object Object]")
    return !1;
  var n = ba.call(t, "constructor"), r = t.constructor && t.constructor.prototype && ba.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !n && !r)
    return !1;
  var i;
  for (i in t)
    ;
  return typeof i > "u" || ba.call(t, i);
}, fh = function(t, n) {
  sh && n.name === "__proto__" ? sh(t, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : t[n.name] = n.newValue;
}, dh = function(t, n) {
  if (n === "__proto__")
    if (ba.call(t, n)) {
      if (lh)
        return lh(t, n).value;
    } else return;
  return t[n];
}, tO = function e() {
  var t, n, r, i, o, a, s = arguments[0], l = 1, u = arguments.length, c = !1;
  for (typeof s == "boolean" && (c = s, s = arguments[1] || {}, l = 2), (s == null || typeof s != "object" && typeof s != "function") && (s = {}); l < u; ++l)
    if (t = arguments[l], t != null)
      for (n in t)
        r = dh(s, n), i = dh(t, n), s !== i && (c && i && (ch(i) || (o = uh(i))) ? (o ? (o = !1, a = r && uh(r) ? r : []) : a = r && ch(r) ? r : {}, fh(s, { name: n, newValue: e(c, a, i) })) : typeof i < "u" && fh(s, { name: n, newValue: i }));
  return s;
};
const fl = /* @__PURE__ */ Ce(tO);
function ac(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function nO() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...i) {
    let o = -1;
    const a = i.pop();
    if (typeof a != "function")
      throw new TypeError("Expected function as last argument, not " + a);
    s(null, ...i);
    function s(l, ...u) {
      const c = e[++o];
      let f = -1;
      if (l) {
        a(l);
        return;
      }
      for (; ++f < i.length; )
        (u[f] === null || u[f] === void 0) && (u[f] = i[f]);
      i = u, c ? rO(c, s)(...u) : a(null, ...u);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), t;
  }
}
function rO(e, t) {
  let n;
  return r;
  function r(...a) {
    const s = e.length > a.length;
    let l;
    s && a.push(i);
    try {
      l = e.apply(this, a);
    } catch (u) {
      const c = (
        /** @type {Error} */
        u
      );
      if (s && n)
        throw c;
      return i(c);
    }
    s || (l && l.then && typeof l.then == "function" ? l.then(o, i) : l instanceof Error ? i(l) : o(l));
  }
  function i(a, ...s) {
    n || (n = !0, t(a, ...s));
  }
  function o(a) {
    i(null, a);
  }
}
const yn = { basename: iO, dirname: oO, extname: aO, join: sO, sep: "/" };
function iO(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  ho(e);
  let n = 0, r = -1, i = e.length, o;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; i--; )
      if (e.codePointAt(i) === 47) {
        if (o) {
          n = i + 1;
          break;
        }
      } else r < 0 && (o = !0, r = i + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let a = -1, s = t.length - 1;
  for (; i--; )
    if (e.codePointAt(i) === 47) {
      if (o) {
        n = i + 1;
        break;
      }
    } else
      a < 0 && (o = !0, a = i + 1), s > -1 && (e.codePointAt(i) === t.codePointAt(s--) ? s < 0 && (r = i) : (s = -1, r = a));
  return n === r ? r = a : r < 0 && (r = e.length), e.slice(n, r);
}
function oO(e) {
  if (ho(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function aO(e) {
  ho(e);
  let t = e.length, n = -1, r = 0, i = -1, o = 0, a;
  for (; t--; ) {
    const s = e.codePointAt(t);
    if (s === 47) {
      if (a) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (a = !0, n = t + 1), s === 46 ? i < 0 ? i = t : o !== 1 && (o = 1) : i > -1 && (o = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  o === 0 || // The (right-most) trimmed path component is exactly `..`.
  o === 1 && i === n - 1 && i === r + 1 ? "" : e.slice(i, n);
}
function sO(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    ho(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : lO(n);
}
function lO(e) {
  ho(e);
  const t = e.codePointAt(0) === 47;
  let n = uO(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function uO(e, t) {
  let n = "", r = 0, i = -1, o = 0, a = -1, s, l;
  for (; ++a <= e.length; ) {
    if (a < e.length)
      s = e.codePointAt(a);
    else {
      if (s === 47)
        break;
      s = 47;
    }
    if (s === 47) {
      if (!(i === a - 1 || o === 1)) if (i !== a - 1 && o === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (l = n.lastIndexOf("/"), l !== n.length - 1) {
              l < 0 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), i = a, o = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, i = a, o = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(i + 1, a) : n = e.slice(i + 1, a), r = a - i - 1;
      i = a, o = 0;
    } else s === 46 && o > -1 ? o++ : o = -1;
  }
  return n;
}
function ho(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const cO = { cwd: fO };
function fO() {
  return "/";
}
function sc(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function dO(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!sc(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return pO(e);
}
function pO(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
const dl = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class kb {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? sc(t) ? n = { path: t } : typeof t == "string" || hO(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : cO.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < dl.length; ) {
      const o = dl[r];
      o in n && n[o] !== void 0 && n[o] !== null && (this[o] = o === "history" ? [...n[o]] : n[o]);
    }
    let i;
    for (i in n)
      dl.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? yn.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    hl(t, "basename"), pl(t, "basename"), this.path = yn.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? yn.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    ph(this.basename, "dirname"), this.path = yn.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? yn.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (pl(t, "extname"), ph(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = yn.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    sc(t) && (t = dO(t)), hl(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? yn.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    hl(t, "stem"), pl(t, "stem"), this.path = yn.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const i = this.message(t, n, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const i = this.message(t, n, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const i = new It(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function pl(e, t) {
  if (e && e.includes(yn.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + yn.sep + "`"
    );
}
function hl(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function ph(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function hO(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const vO = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[e], o = function() {
      return i.apply(o, arguments);
    };
    return Object.setPrototypeOf(o, r), o;
  }
), mO = {}.hasOwnProperty;
class Rf extends vO {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = nO();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Rf()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(fl(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (gl("data", this.frozen), this.namespace[t] = n, this) : mO.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (gl("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = n.call(t, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = Ho(t), r = this.parser || this.Parser;
    return vl("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), vl("process", this.parser || this.Parser), ml("process", this.compiler || this.Compiler), n ? i(void 0, n) : new Promise(i);
    function i(o, a) {
      const s = Ho(t), l = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(s)
      );
      r.run(l, s, function(c, f, p) {
        if (c || !f || !p)
          return u(c);
        const d = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          f
        ), v = r.stringify(d, p);
        bO(v) ? p.value = v : p.result = v, u(
          c,
          /** @type {VFileWithOutput<CompileResult>} */
          p
        );
      });
      function u(c, f) {
        c || !f ? a(c) : o ? o(f) : n(void 0, f);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), vl("processSync", this.parser || this.Parser), ml("processSync", this.compiler || this.Compiler), this.process(t, i), vh("processSync", "process", n), r;
    function i(o, a) {
      n = !0, ah(o), r = a;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    hh(t), this.freeze();
    const i = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? o(void 0, r) : new Promise(o);
    function o(a, s) {
      const l = Ho(n);
      i.run(t, l, u);
      function u(c, f, p) {
        const d = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          f || t
        );
        c ? s(c) : a ? a(d) : r(void 0, d, p);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, i;
    return this.run(t, n, o), vh("runSync", "run", r), i;
    function o(a, s) {
      ah(a), i = s, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = Ho(n), i = this.compiler || this.Compiler;
    return ml("stringify", i), hh(t), i(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, i = this.namespace;
    if (gl("use", this.frozen), t != null) if (typeof t == "function")
      l(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? s(t) : a(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function o(u) {
      if (typeof u == "function")
        l(u, []);
      else if (typeof u == "object")
        if (Array.isArray(u)) {
          const [c, ...f] = (
            /** @type {PluginTuple<Array<unknown>>} */
            u
          );
          l(c, f);
        } else
          a(u);
      else
        throw new TypeError("Expected usable value, not `" + u + "`");
    }
    function a(u) {
      if (!("plugins" in u) && !("settings" in u))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      s(u.plugins), u.settings && (i.settings = fl(!0, i.settings, u.settings));
    }
    function s(u) {
      let c = -1;
      if (u != null) if (Array.isArray(u))
        for (; ++c < u.length; ) {
          const f = u[c];
          o(f);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + u + "`");
    }
    function l(u, c) {
      let f = -1, p = -1;
      for (; ++f < r.length; )
        if (r[f][0] === u) {
          p = f;
          break;
        }
      if (p === -1)
        r.push([u, ...c]);
      else if (c.length > 0) {
        let [d, ...v] = c;
        const h = r[p][1];
        ac(h) && ac(d) && (d = fl(!0, h, d)), r[p] = [u, d, ...v];
      }
    }
  }
}
const gO = new Rf().freeze();
function vl(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function ml(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function gl(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function hh(e) {
  if (!ac(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function vh(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function Ho(e) {
  return yO(e) ? e : new kb(e);
}
function yO(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function bO(e) {
  return typeof e == "string" || xO(e);
}
function xO(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const wO = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", mh = [], gh = { allowDangerousHtml: !0 }, SO = /^(https?|ircs?|mailto|xmpp)$/i, EO = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function Cb(e) {
  const t = e.allowedElements, n = e.allowElement, r = e.children || "", i = e.className, o = e.components, a = e.disallowedElements, s = e.rehypePlugins || mh, l = e.remarkPlugins || mh, u = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...gh } : gh, c = e.skipHtml, f = e.unwrapDisallowed, p = e.urlTransform || $b, d = gO().use(aT).use(l).use(eO, u).use(s), v = new kb();
  typeof r == "string" && (v.value = r);
  for (const b of EO)
    Object.hasOwn(e, b.from) && ("" + b.from + (b.to ? "use `" + b.to + "` instead" : "remove it") + wO + b.id, void 0);
  const h = d.parse(v);
  let g = d.runSync(h, v);
  return i && (g = {
    type: "element",
    tagName: "div",
    properties: { className: i },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      g.type === "root" ? g.children : [g]
    )
  }), If(g, m), Wk(g, {
    Fragment: $.Fragment,
    components: o,
    ignoreInvalidStyle: !0,
    jsx: $.jsx,
    jsxs: $.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function m(b, x, C) {
    if (b.type === "raw" && C && typeof x == "number")
      return c ? C.children.splice(x, 1) : C.children[x] = { type: "text", value: b.value }, x;
    if (b.type === "element") {
      let S;
      for (S in ll)
        if (Object.hasOwn(ll, S) && Object.hasOwn(b.properties, S)) {
          const E = b.properties[S], T = ll[S];
          (T === null || T.includes(b.tagName)) && (b.properties[S] = p(String(E || ""), S, b));
        }
    }
    if (b.type === "element") {
      let S = t ? !t.includes(b.tagName) : a ? a.includes(b.tagName) : !1;
      if (!S && n && typeof x == "number" && (S = !n(b, x, C)), S && C && typeof x == "number")
        return f && b.children ? C.children.splice(x, 1, ...b.children) : C.children.splice(x, 1), x;
    }
  }
}
function $b(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), i = e.indexOf("/");
  return (
    // If there is no protocol, it’s relative.
    t < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
    i > -1 && t > i || n > -1 && t > n || r > -1 && t > r || // It is a protocol, it should be allowed.
    SO.test(e.slice(0, t)) ? e : ""
  );
}
function kO(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function Tb(e, t, n) {
  const i = ms((n || {}).ignore || []), o = CO(t);
  let a = -1;
  for (; ++a < o.length; )
    Sb(e, "text", s);
  function s(u, c) {
    let f = -1, p;
    for (; ++f < c.length; ) {
      const d = c[f], v = p ? p.children : void 0;
      if (i(
        d,
        v ? v.indexOf(d) : void 0,
        p
      ))
        return;
      p = d;
    }
    if (p)
      return l(u, c);
  }
  function l(u, c) {
    const f = c[c.length - 1], p = o[a][0], d = o[a][1];
    let v = 0;
    const g = f.children.indexOf(u);
    let m = !1, b = [];
    p.lastIndex = 0;
    let x = p.exec(u.value);
    for (; x; ) {
      const C = x.index, S = {
        index: x.index,
        input: x.input,
        stack: [...c, u]
      };
      let E = d(...x, S);
      if (typeof E == "string" && (E = E.length > 0 ? { type: "text", value: E } : void 0), E === !1 ? p.lastIndex = C + 1 : (v !== C && b.push({
        type: "text",
        value: u.value.slice(v, C)
      }), Array.isArray(E) ? b.push(...E) : E && b.push(E), v = C + x[0].length, m = !0), !p.global)
        break;
      x = p.exec(u.value);
    }
    return m ? (v < u.value.length && b.push({ type: "text", value: u.value.slice(v) }), f.children.splice(g, 1, ...b)) : b = [u], g + b.length;
  }
}
function CO(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    t.push([$O(i[0]), TO(i[1])]);
  }
  return t;
}
function $O(e) {
  return typeof e == "string" ? new RegExp(kO(e), "g") : e;
}
function TO(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
function OO(e) {
  Tb(e, [/\r?\n|\r/g, IO]);
}
function IO() {
  return { type: "break" };
}
function RO() {
  return function(e) {
    OO(e);
  };
}
function yh(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(t);
  for (; i !== -1; )
    r++, i = n.indexOf(t, i + t.length);
  return r;
}
const yl = "phrasing", bl = ["autolink", "link", "image", "label"];
function PO() {
  return {
    transforms: [LO],
    enter: {
      literalAutolink: DO,
      literalAutolinkEmail: xl,
      literalAutolinkHttp: xl,
      literalAutolinkWww: xl
    },
    exit: {
      literalAutolink: NO,
      literalAutolinkEmail: jO,
      literalAutolinkHttp: _O,
      literalAutolinkWww: MO
    }
  };
}
function AO() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: yl,
        notInConstruct: bl
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: yl,
        notInConstruct: bl
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: yl,
        notInConstruct: bl
      }
    ]
  };
}
function DO(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function xl(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function _O(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function MO(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function jO(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function NO(e) {
  this.exit(e);
}
function LO(e) {
  Tb(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, FO],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), BO]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function FO(e, t, n, r, i) {
  let o = "";
  if (!Ob(i) || (/^w/i.test(t) && (n = t + n, t = "", o = "http://"), !zO(n)))
    return !1;
  const a = WO(n + r);
  if (!a[0]) return !1;
  const s = {
    type: "link",
    title: null,
    url: o + t + a[0],
    children: [{ type: "text", value: t + a[0] }]
  };
  return a[1] ? [s, { type: "text", value: a[1] }] : s;
}
function BO(e, t, n, r) {
  return (
    // Not an expected previous character.
    !Ob(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function zO(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function WO(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const i = yh(e, "(");
  let o = yh(e, ")");
  for (; r !== -1 && i > o; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), o++;
  return [e, n];
}
function Ob(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || mr(n) || ps(n)) && // If it’s an email, the previous character should not be a slash.
  (!t || n !== 47);
}
Ib.peek = QO;
function UO() {
  return {
    enter: {
      gfmFootnoteDefinition: VO,
      gfmFootnoteDefinitionLabelString: KO,
      gfmFootnoteCall: YO,
      gfmFootnoteCallString: XO
    },
    exit: {
      gfmFootnoteDefinition: GO,
      gfmFootnoteDefinitionLabelString: qO,
      gfmFootnoteCall: ZO,
      gfmFootnoteCallString: JO
    }
  };
}
function HO() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition: eI, footnoteReference: Ib }
  };
}
function VO(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function KO() {
  this.buffer();
}
function qO(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = ln(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function GO(e) {
  this.exit(e);
}
function YO(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function XO() {
  this.buffer();
}
function JO(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = ln(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function ZO(e) {
  this.exit(e);
}
function Ib(e, t, n, r) {
  const i = n.createTracker(r);
  let o = i.move("[^");
  const a = n.enter("footnoteReference"), s = n.enter("reference");
  return o += i.move(
    n.safe(n.associationId(e), {
      ...i.current(),
      before: o,
      after: "]"
    })
  ), s(), a(), o += i.move("]"), o;
}
function QO() {
  return "[";
}
function eI(e, t, n, r) {
  const i = n.createTracker(r);
  let o = i.move("[^");
  const a = n.enter("footnoteDefinition"), s = n.enter("label");
  return o += i.move(
    n.safe(n.associationId(e), {
      ...i.current(),
      before: o,
      after: "]"
    })
  ), s(), o += i.move(
    "]:" + (e.children && e.children.length > 0 ? " " : "")
  ), i.shift(4), o += i.move(
    n.indentLines(n.containerFlow(e, i.current()), tI)
  ), a(), o;
}
function tI(e, t, n) {
  return t === 0 ? e : (n ? "" : "    ") + e;
}
const nI = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
Rb.peek = sI;
function rI() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: oI },
    exit: { strikethrough: aI }
  };
}
function iI() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: nI
      }
    ],
    handlers: { delete: Rb }
  };
}
function oI(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function aI(e) {
  this.exit(e);
}
function Rb(e, t, n, r) {
  const i = n.createTracker(r), o = n.enter("strikethrough");
  let a = i.move("~~");
  return a += n.containerPhrasing(e, {
    ...i.current(),
    before: a,
    after: "~"
  }), a += i.move("~~"), o(), a;
}
function sI() {
  return "~";
}
function lI(e) {
  return e.length;
}
function uI(e, t) {
  const n = t || {}, r = (n.align || []).concat(), i = n.stringLength || lI, o = [], a = [], s = [], l = [];
  let u = 0, c = -1;
  for (; ++c < e.length; ) {
    const h = [], g = [];
    let m = -1;
    for (e[c].length > u && (u = e[c].length); ++m < e[c].length; ) {
      const b = cI(e[c][m]);
      if (n.alignDelimiters !== !1) {
        const x = i(b);
        g[m] = x, (l[m] === void 0 || x > l[m]) && (l[m] = x);
      }
      h.push(b);
    }
    a[c] = h, s[c] = g;
  }
  let f = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++f < u; )
      o[f] = bh(r[f]);
  else {
    const h = bh(r);
    for (; ++f < u; )
      o[f] = h;
  }
  f = -1;
  const p = [], d = [];
  for (; ++f < u; ) {
    const h = o[f];
    let g = "", m = "";
    h === 99 ? (g = ":", m = ":") : h === 108 ? g = ":" : h === 114 && (m = ":");
    let b = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      l[f] - g.length - m.length
    );
    const x = g + "-".repeat(b) + m;
    n.alignDelimiters !== !1 && (b = g.length + b + m.length, b > l[f] && (l[f] = b), d[f] = b), p[f] = x;
  }
  a.splice(1, 0, p), s.splice(1, 0, d), c = -1;
  const v = [];
  for (; ++c < a.length; ) {
    const h = a[c], g = s[c];
    f = -1;
    const m = [];
    for (; ++f < u; ) {
      const b = h[f] || "";
      let x = "", C = "";
      if (n.alignDelimiters !== !1) {
        const S = l[f] - (g[f] || 0), E = o[f];
        E === 114 ? x = " ".repeat(S) : E === 99 ? S % 2 ? (x = " ".repeat(S / 2 + 0.5), C = " ".repeat(S / 2 - 0.5)) : (x = " ".repeat(S / 2), C = x) : C = " ".repeat(S);
      }
      n.delimiterStart !== !1 && !f && m.push("|"), n.padding !== !1 && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && b === "") && (n.delimiterStart !== !1 || f) && m.push(" "), n.alignDelimiters !== !1 && m.push(x), m.push(b), n.alignDelimiters !== !1 && m.push(C), n.padding !== !1 && m.push(" "), (n.delimiterEnd !== !1 || f !== u - 1) && m.push("|");
    }
    v.push(
      n.delimiterEnd === !1 ? m.join("").replace(/ +$/, "") : m.join("")
    );
  }
  return v.join(`
`);
}
function cI(e) {
  return e == null ? "" : String(e);
}
function bh(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function fI(e, t, n, r) {
  const i = n.enter("blockquote"), o = n.createTracker(r);
  o.move("> "), o.shift(2);
  const a = n.indentLines(
    n.containerFlow(e, o.current()),
    dI
  );
  return i(), a;
}
function dI(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function pI(e, t) {
  return xh(e, t.inConstruct, !0) && !xh(e, t.notInConstruct, !1);
}
function xh(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function wh(e, t, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && pI(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function hI(e, t) {
  const n = String(e);
  let r = n.indexOf(t), i = r, o = 0, a = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++o > a && (a = o) : o = 1, i = r + t.length, r = n.indexOf(t, i);
  return a;
}
function vI(e, t) {
  return !!(t.options.fences === !1 && e.value && // If there’s no info…
  !e.lang && // And there’s a non-whitespace character…
  /[^ \r\n]/.test(e.value) && // And the value doesn’t start or end in a blank…
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function mI(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function gI(e, t, n, r) {
  const i = mI(n), o = e.value || "", a = i === "`" ? "GraveAccent" : "Tilde";
  if (vI(e, n)) {
    const f = n.enter("codeIndented"), p = n.indentLines(o, yI);
    return f(), p;
  }
  const s = n.createTracker(r), l = i.repeat(Math.max(hI(o, i) + 1, 3)), u = n.enter("codeFenced");
  let c = s.move(l);
  if (e.lang) {
    const f = n.enter(`codeFencedLang${a}`);
    c += s.move(
      n.safe(e.lang, {
        before: c,
        after: " ",
        encode: ["`"],
        ...s.current()
      })
    ), f();
  }
  if (e.lang && e.meta) {
    const f = n.enter(`codeFencedMeta${a}`);
    c += s.move(" "), c += s.move(
      n.safe(e.meta, {
        before: c,
        after: `
`,
        encode: ["`"],
        ...s.current()
      })
    ), f();
  }
  return c += s.move(`
`), o && (c += s.move(o + `
`)), c += s.move(l), u(), c;
}
function yI(e, t, n) {
  return (n ? "" : "    ") + e;
}
function Pf(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function bI(e, t, n, r) {
  const i = Pf(n), o = i === '"' ? "Quote" : "Apostrophe", a = n.enter("definition");
  let s = n.enter("label");
  const l = n.createTracker(r);
  let u = l.move("[");
  return u += l.move(
    n.safe(n.associationId(e), {
      before: u,
      after: "]",
      ...l.current()
    })
  ), u += l.move("]: "), s(), // If there’s no url, or…
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), u += l.move("<"), u += l.move(
    n.safe(e.url, { before: u, after: ">", ...l.current() })
  ), u += l.move(">")) : (s = n.enter("destinationRaw"), u += l.move(
    n.safe(e.url, {
      before: u,
      after: e.title ? " " : `
`,
      ...l.current()
    })
  )), s(), e.title && (s = n.enter(`title${o}`), u += l.move(" " + i), u += l.move(
    n.safe(e.title, {
      before: u,
      after: i,
      ...l.current()
    })
  ), u += l.move(i), s()), a(), u;
}
function xI(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
Pb.peek = wI;
function Pb(e, t, n, r) {
  const i = xI(n), o = n.enter("emphasis"), a = n.createTracker(r);
  let s = a.move(i);
  return s += a.move(
    n.containerPhrasing(e, {
      before: s,
      after: i,
      ...a.current()
    })
  ), s += a.move(i), o(), s;
}
function wI(e, t, n) {
  return n.options.emphasis || "*";
}
function SI(e, t) {
  let n = !1;
  return If(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, ic;
  }), !!((!e.depth || e.depth < 3) && Sf(e) && (t.options.setext || n));
}
function EI(e, t, n, r) {
  const i = Math.max(Math.min(6, e.depth || 1), 1), o = n.createTracker(r);
  if (SI(e, n)) {
    const c = n.enter("headingSetext"), f = n.enter("phrasing"), p = n.containerPhrasing(e, {
      ...o.current(),
      before: `
`,
      after: `
`
    });
    return f(), c(), p + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size…
      p.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(p.lastIndexOf("\r"), p.lastIndexOf(`
`)) + 1)
    );
  }
  const a = "#".repeat(i), s = n.enter("headingAtx"), l = n.enter("phrasing");
  o.move(a + " ");
  let u = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...o.current()
  });
  return /^[\t ]/.test(u) && (u = "&#x" + u.charCodeAt(0).toString(16).toUpperCase() + ";" + u.slice(1)), u = u ? a + " " + u : a, n.options.closeAtx && (u += " " + a), l(), s(), u;
}
Ab.peek = kI;
function Ab(e) {
  return e.value || "";
}
function kI() {
  return "<";
}
Db.peek = CI;
function Db(e, t, n, r) {
  const i = Pf(n), o = i === '"' ? "Quote" : "Apostrophe", a = n.enter("image");
  let s = n.enter("label");
  const l = n.createTracker(r);
  let u = l.move("![");
  return u += l.move(
    n.safe(e.alt, { before: u, after: "]", ...l.current() })
  ), u += l.move("]("), s(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), u += l.move("<"), u += l.move(
    n.safe(e.url, { before: u, after: ">", ...l.current() })
  ), u += l.move(">")) : (s = n.enter("destinationRaw"), u += l.move(
    n.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...l.current()
    })
  )), s(), e.title && (s = n.enter(`title${o}`), u += l.move(" " + i), u += l.move(
    n.safe(e.title, {
      before: u,
      after: i,
      ...l.current()
    })
  ), u += l.move(i), s()), u += l.move(")"), a(), u;
}
function CI() {
  return "!";
}
_b.peek = $I;
function _b(e, t, n, r) {
  const i = e.referenceType, o = n.enter("imageReference");
  let a = n.enter("label");
  const s = n.createTracker(r);
  let l = s.move("![");
  const u = n.safe(e.alt, {
    before: l,
    after: "]",
    ...s.current()
  });
  l += s.move(u + "]["), a();
  const c = n.stack;
  n.stack = [], a = n.enter("reference");
  const f = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...s.current()
  });
  return a(), n.stack = c, o(), i === "full" || !u || u !== f ? l += s.move(f + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += s.move("]"), l;
}
function $I() {
  return "!";
}
Mb.peek = TI;
function Mb(e, t, n) {
  let r = e.value || "", i = "`", o = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++o < n.unsafe.length; ) {
    const a = n.unsafe[o], s = n.compilePattern(a);
    let l;
    if (a.atBreak)
      for (; l = s.exec(r); ) {
        let u = l.index;
        r.charCodeAt(u) === 10 && r.charCodeAt(u - 1) === 13 && u--, r = r.slice(0, u) + " " + r.slice(l.index + 1);
      }
  }
  return i + r + i;
}
function TI() {
  return "`";
}
function jb(e, t) {
  const n = Sf(e);
  return !!(!t.options.resourceLink && // If there’s a url…
  e.url && // And there’s a no title…
  !e.title && // And the content of `node` is a single text node…
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content…
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol…
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesn’t contain ASCII control codes (character escapes and
  // references don’t work), space, or angle brackets…
  !/[\0- <>\u007F]/.test(e.url));
}
Nb.peek = OI;
function Nb(e, t, n, r) {
  const i = Pf(n), o = i === '"' ? "Quote" : "Apostrophe", a = n.createTracker(r);
  let s, l;
  if (jb(e, n)) {
    const c = n.stack;
    n.stack = [], s = n.enter("autolink");
    let f = a.move("<");
    return f += a.move(
      n.containerPhrasing(e, {
        before: f,
        after: ">",
        ...a.current()
      })
    ), f += a.move(">"), s(), n.stack = c, f;
  }
  s = n.enter("link"), l = n.enter("label");
  let u = a.move("[");
  return u += a.move(
    n.containerPhrasing(e, {
      before: u,
      after: "](",
      ...a.current()
    })
  ), u += a.move("]("), l(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"), u += a.move("<"), u += a.move(
    n.safe(e.url, { before: u, after: ">", ...a.current() })
  ), u += a.move(">")) : (l = n.enter("destinationRaw"), u += a.move(
    n.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...a.current()
    })
  )), l(), e.title && (l = n.enter(`title${o}`), u += a.move(" " + i), u += a.move(
    n.safe(e.title, {
      before: u,
      after: i,
      ...a.current()
    })
  ), u += a.move(i), l()), u += a.move(")"), s(), u;
}
function OI(e, t, n) {
  return jb(e, n) ? "<" : "[";
}
Lb.peek = II;
function Lb(e, t, n, r) {
  const i = e.referenceType, o = n.enter("linkReference");
  let a = n.enter("label");
  const s = n.createTracker(r);
  let l = s.move("[");
  const u = n.containerPhrasing(e, {
    before: l,
    after: "]",
    ...s.current()
  });
  l += s.move(u + "]["), a();
  const c = n.stack;
  n.stack = [], a = n.enter("reference");
  const f = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...s.current()
  });
  return a(), n.stack = c, o(), i === "full" || !u || u !== f ? l += s.move(f + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += s.move("]"), l;
}
function II() {
  return "[";
}
function Af(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function RI(e) {
  const t = Af(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function PI(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function Fb(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function AI(e, t, n, r) {
  const i = n.enter("list"), o = n.bulletCurrent;
  let a = e.ordered ? PI(n) : Af(n);
  const s = e.ordered ? a === "." ? ")" : "." : RI(n);
  let l = t && n.bulletLastUsed ? a === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const c = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (a === "*" || a === "-") && // Empty first list item:
      c && (!c.children || !c.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (l = !0), Fb(n) === a && c
    ) {
      let f = -1;
      for (; ++f < e.children.length; ) {
        const p = e.children[f];
        if (p && p.type === "listItem" && p.children && p.children[0] && p.children[0].type === "thematicBreak") {
          l = !0;
          break;
        }
      }
    }
  }
  l && (a = s), n.bulletCurrent = a;
  const u = n.containerFlow(e, r);
  return n.bulletLastUsed = a, n.bulletCurrent = o, i(), u;
}
function DI(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function _I(e, t, n, r) {
  const i = DI(n);
  let o = n.bulletCurrent || Af(n);
  t && t.type === "list" && t.ordered && (o = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + o);
  let a = o.length + 1;
  (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (a = Math.ceil(a / 4) * 4);
  const s = n.createTracker(r);
  s.move(o + " ".repeat(a - o.length)), s.shift(a);
  const l = n.enter("listItem"), u = n.indentLines(
    n.containerFlow(e, s.current()),
    c
  );
  return l(), u;
  function c(f, p, d) {
    return p ? (d ? "" : " ".repeat(a)) + f : (d ? o : o + " ".repeat(a - o.length)) + f;
  }
}
function MI(e, t, n, r) {
  const i = n.enter("paragraph"), o = n.enter("phrasing"), a = n.containerPhrasing(e, r);
  return o(), i(), a;
}
const jI = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  ms([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function NI(e, t, n, r) {
  return (e.children.some(function(a) {
    return jI(a);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function LI(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
Bb.peek = FI;
function Bb(e, t, n, r) {
  const i = LI(n), o = n.enter("strong"), a = n.createTracker(r);
  let s = a.move(i + i);
  return s += a.move(
    n.containerPhrasing(e, {
      before: s,
      after: i,
      ...a.current()
    })
  ), s += a.move(i + i), o(), s;
}
function FI(e, t, n) {
  return n.options.strong || "*";
}
function BI(e, t, n, r) {
  return n.safe(e.value, r);
}
function zI(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function WI(e, t, n) {
  const r = (Fb(n) + (n.options.ruleSpaces ? " " : "")).repeat(zI(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const zb = {
  blockquote: fI,
  break: wh,
  code: gI,
  definition: bI,
  emphasis: Pb,
  hardBreak: wh,
  heading: EI,
  html: Ab,
  image: Db,
  imageReference: _b,
  inlineCode: Mb,
  link: Nb,
  linkReference: Lb,
  list: AI,
  listItem: _I,
  paragraph: MI,
  root: NI,
  strong: Bb,
  text: BI,
  thematicBreak: WI
};
function UI() {
  return {
    enter: {
      table: HI,
      tableData: Sh,
      tableHeader: Sh,
      tableRow: KI
    },
    exit: {
      codeText: qI,
      table: VI,
      tableData: wl,
      tableHeader: wl,
      tableRow: wl
    }
  };
}
function HI(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function VI(e) {
  this.exit(e), this.data.inTable = void 0;
}
function KI(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function wl(e) {
  this.exit(e);
}
function Sh(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function qI(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, GI));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function GI(e, t) {
  return t === "|" ? t : e;
}
function YI(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, i = t.stringLength, o = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: p,
      table: a,
      tableCell: l,
      tableRow: s
    }
  };
  function a(d, v, h, g) {
    return u(c(d, h, g), d.align);
  }
  function s(d, v, h, g) {
    const m = f(d, h, g), b = u([m]);
    return b.slice(0, b.indexOf(`
`));
  }
  function l(d, v, h, g) {
    const m = h.enter("tableCell"), b = h.enter("phrasing"), x = h.containerPhrasing(d, {
      ...g,
      before: o,
      after: o
    });
    return b(), m(), x;
  }
  function u(d, v) {
    return uI(d, {
      align: v,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function c(d, v, h) {
    const g = d.children;
    let m = -1;
    const b = [], x = v.enter("table");
    for (; ++m < g.length; )
      b[m] = f(g[m], v, h);
    return x(), b;
  }
  function f(d, v, h) {
    const g = d.children;
    let m = -1;
    const b = [], x = v.enter("tableRow");
    for (; ++m < g.length; )
      b[m] = l(g[m], d, v, h);
    return x(), b;
  }
  function p(d, v, h) {
    let g = zb.inlineCode(d, v, h);
    return h.stack.includes("tableCell") && (g = g.replace(/\|/g, "\\$&")), g;
  }
}
function XI() {
  return {
    exit: {
      taskListCheckValueChecked: Eh,
      taskListCheckValueUnchecked: Eh,
      paragraph: ZI
    }
  };
}
function JI() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: QI }
  };
}
function Eh(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function ZI(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = t.children;
      let o = -1, a;
      for (; ++o < i.length; ) {
        const s = i[o];
        if (s.type === "paragraph") {
          a = s;
          break;
        }
      }
      a === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function QI(e, t, n, r) {
  const i = e.children[0], o = typeof e.checked == "boolean" && i && i.type === "paragraph", a = "[" + (e.checked ? "x" : " ") + "] ", s = n.createTracker(r);
  o && s.move(a);
  let l = zb.listItem(e, t, n, {
    ...r,
    ...s.current()
  });
  return o && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), l;
  function u(c) {
    return c + a;
  }
}
function eR() {
  return [
    PO(),
    UO(),
    rI(),
    UI(),
    XI()
  ];
}
function tR(e) {
  return {
    extensions: [
      AO(),
      HO(),
      iI(),
      YI(e),
      JI()
    ]
  };
}
const nR = {
  tokenize: lR,
  partial: !0
}, Wb = {
  tokenize: uR,
  partial: !0
}, Ub = {
  tokenize: cR,
  partial: !0
}, Hb = {
  tokenize: fR,
  partial: !0
}, rR = {
  tokenize: dR,
  partial: !0
}, Vb = {
  name: "wwwAutolink",
  tokenize: aR,
  previous: qb
}, Kb = {
  name: "protocolAutolink",
  tokenize: sR,
  previous: Gb
}, Nn = {
  name: "emailAutolink",
  tokenize: oR,
  previous: Yb
}, kn = {};
function iR() {
  return {
    text: kn
  };
}
let ur = 48;
for (; ur < 123; )
  kn[ur] = Nn, ur++, ur === 58 ? ur = 65 : ur === 91 && (ur = 97);
kn[43] = Nn;
kn[45] = Nn;
kn[46] = Nn;
kn[95] = Nn;
kn[72] = [Nn, Kb];
kn[104] = [Nn, Kb];
kn[87] = [Nn, Vb];
kn[119] = [Nn, Vb];
function oR(e, t, n) {
  const r = this;
  let i, o;
  return a;
  function a(f) {
    return !lc(f) || !Yb.call(r, r.previous) || Df(r.events) ? n(f) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), s(f));
  }
  function s(f) {
    return lc(f) ? (e.consume(f), s) : f === 64 ? (e.consume(f), l) : n(f);
  }
  function l(f) {
    return f === 46 ? e.check(rR, c, u)(f) : f === 45 || f === 95 || Tt(f) ? (o = !0, e.consume(f), l) : c(f);
  }
  function u(f) {
    return e.consume(f), i = !0, l;
  }
  function c(f) {
    return o && i && Dt(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(f)) : n(f);
  }
}
function aR(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return a !== 87 && a !== 119 || !qb.call(r, r.previous) || Df(r.events) ? n(a) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(nR, e.attempt(Wb, e.attempt(Ub, o), n), n)(a));
  }
  function o(a) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(a);
  }
}
function sR(e, t, n) {
  const r = this;
  let i = "", o = !1;
  return a;
  function a(f) {
    return (f === 72 || f === 104) && Gb.call(r, r.previous) && !Df(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(f), e.consume(f), s) : n(f);
  }
  function s(f) {
    if (Dt(f) && i.length < 5)
      return i += String.fromCodePoint(f), e.consume(f), s;
    if (f === 58) {
      const p = i.toLowerCase();
      if (p === "http" || p === "https")
        return e.consume(f), l;
    }
    return n(f);
  }
  function l(f) {
    return f === 47 ? (e.consume(f), o ? u : (o = !0, l)) : n(f);
  }
  function u(f) {
    return f === null || ja(f) || ze(f) || mr(f) || ps(f) ? n(f) : e.attempt(Wb, e.attempt(Ub, c), n)(f);
  }
  function c(f) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(f);
  }
}
function lR(e, t, n) {
  let r = 0;
  return i;
  function i(a) {
    return (a === 87 || a === 119) && r < 3 ? (r++, e.consume(a), i) : a === 46 && r === 3 ? (e.consume(a), o) : n(a);
  }
  function o(a) {
    return a === null ? n(a) : t(a);
  }
}
function uR(e, t, n) {
  let r, i, o;
  return a;
  function a(u) {
    return u === 46 || u === 95 ? e.check(Hb, l, s)(u) : u === null || ze(u) || mr(u) || u !== 45 && ps(u) ? l(u) : (o = !0, e.consume(u), a);
  }
  function s(u) {
    return u === 95 ? r = !0 : (i = r, r = void 0), e.consume(u), a;
  }
  function l(u) {
    return i || r || !o ? n(u) : t(u);
  }
}
function cR(e, t) {
  let n = 0, r = 0;
  return i;
  function i(a) {
    return a === 40 ? (n++, e.consume(a), i) : a === 41 && r < n ? o(a) : a === 33 || a === 34 || a === 38 || a === 39 || a === 41 || a === 42 || a === 44 || a === 46 || a === 58 || a === 59 || a === 60 || a === 63 || a === 93 || a === 95 || a === 126 ? e.check(Hb, t, o)(a) : a === null || ze(a) || mr(a) ? t(a) : (e.consume(a), i);
  }
  function o(a) {
    return a === 41 && r++, e.consume(a), i;
  }
}
function fR(e, t, n) {
  return r;
  function r(s) {
    return s === 33 || s === 34 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 63 || s === 95 || s === 126 ? (e.consume(s), r) : s === 38 ? (e.consume(s), o) : s === 93 ? (e.consume(s), i) : (
      // `<` is an end.
      s === 60 || // So is whitespace.
      s === null || ze(s) || mr(s) ? t(s) : n(s)
    );
  }
  function i(s) {
    return s === null || s === 40 || s === 91 || ze(s) || mr(s) ? t(s) : r(s);
  }
  function o(s) {
    return Dt(s) ? a(s) : n(s);
  }
  function a(s) {
    return s === 59 ? (e.consume(s), r) : Dt(s) ? (e.consume(s), a) : n(s);
  }
}
function dR(e, t, n) {
  return r;
  function r(o) {
    return e.consume(o), i;
  }
  function i(o) {
    return Tt(o) ? n(o) : t(o);
  }
}
function qb(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || ze(e);
}
function Gb(e) {
  return !Dt(e);
}
function Yb(e) {
  return !(e === 47 || lc(e));
}
function lc(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || Tt(e);
}
function Df(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const pR = {
  tokenize: wR,
  partial: !0
};
function hR() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: yR,
        continuation: {
          tokenize: bR
        },
        exit: xR
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: gR
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: vR,
        resolveTo: mR
      }
    }
  };
}
function vR(e, t, n) {
  const r = this;
  let i = r.events.length;
  const o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a;
  for (; i--; ) {
    const l = r.events[i][1];
    if (l.type === "labelImage") {
      a = l;
      break;
    }
    if (l.type === "gfmFootnoteCall" || l.type === "labelLink" || l.type === "label" || l.type === "image" || l.type === "link")
      break;
  }
  return s;
  function s(l) {
    if (!a || !a._balanced)
      return n(l);
    const u = ln(r.sliceSerialize({
      start: a.end,
      end: r.now()
    }));
    return u.codePointAt(0) !== 94 || !o.includes(u.slice(1)) ? n(l) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(l), e.exit("gfmFootnoteCallLabelMarker"), t(l));
  }
}
function mR(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const o = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, a = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, o.start),
    end: Object.assign({}, o.end)
  }, s = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", i, t],
    ["exit", i, t],
    // Everything in between.
    ["enter", o, t],
    ["enter", a, t],
    ["exit", a, t],
    ["exit", o, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...s), e;
}
function gR(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o = 0, a;
  return s;
  function s(f) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), l;
  }
  function l(f) {
    return f !== 94 ? n(f) : (e.enter("gfmFootnoteCallMarker"), e.consume(f), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", u);
  }
  function u(f) {
    if (
      // Too long.
      o > 999 || // Closing brace with nothing.
      f === 93 && !a || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      f === null || f === 91 || ze(f)
    )
      return n(f);
    if (f === 93) {
      e.exit("chunkString");
      const p = e.exit("gfmFootnoteCallString");
      return i.includes(ln(r.sliceSerialize(p))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(f);
    }
    return ze(f) || (a = !0), o++, e.consume(f), f === 92 ? c : u;
  }
  function c(f) {
    return f === 91 || f === 92 || f === 93 ? (e.consume(f), o++, u) : u(f);
  }
}
function yR(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o, a = 0, s;
  return l;
  function l(v) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(v), e.exit("gfmFootnoteDefinitionLabelMarker"), u;
  }
  function u(v) {
    return v === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(v), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", c) : n(v);
  }
  function c(v) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      v === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      v === null || v === 91 || ze(v)
    )
      return n(v);
    if (v === 93) {
      e.exit("chunkString");
      const h = e.exit("gfmFootnoteDefinitionLabelString");
      return o = ln(r.sliceSerialize(h)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(v), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), p;
    }
    return ze(v) || (s = !0), a++, e.consume(v), v === 92 ? f : c;
  }
  function f(v) {
    return v === 91 || v === 92 || v === 93 ? (e.consume(v), a++, c) : c(v);
  }
  function p(v) {
    return v === 58 ? (e.enter("definitionMarker"), e.consume(v), e.exit("definitionMarker"), i.includes(o) || i.push(o), ke(e, d, "gfmFootnoteDefinitionWhitespace")) : n(v);
  }
  function d(v) {
    return t(v);
  }
}
function bR(e, t, n) {
  return e.check(po, t, e.attempt(pR, t, n));
}
function xR(e) {
  e.exit("gfmFootnoteDefinition");
}
function wR(e, t, n) {
  const r = this;
  return ke(e, i, "gfmFootnoteDefinitionIndent", 5);
  function i(o) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "gfmFootnoteDefinitionIndent" && a[2].sliceSerialize(a[1], !0).length === 4 ? t(o) : n(o);
  }
}
function SR(e) {
  let n = (e || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: o,
    resolveAll: i
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(a, s) {
    let l = -1;
    for (; ++l < a.length; )
      if (a[l][0] === "enter" && a[l][1].type === "strikethroughSequenceTemporary" && a[l][1]._close) {
        let u = l;
        for (; u--; )
          if (a[u][0] === "exit" && a[u][1].type === "strikethroughSequenceTemporary" && a[u][1]._open && // If the sizes are the same:
          a[l][1].end.offset - a[l][1].start.offset === a[u][1].end.offset - a[u][1].start.offset) {
            a[l][1].type = "strikethroughSequence", a[u][1].type = "strikethroughSequence";
            const c = {
              type: "strikethrough",
              start: Object.assign({}, a[u][1].start),
              end: Object.assign({}, a[l][1].end)
            }, f = {
              type: "strikethroughText",
              start: Object.assign({}, a[u][1].end),
              end: Object.assign({}, a[l][1].start)
            }, p = [["enter", c, s], ["enter", a[u][1], s], ["exit", a[u][1], s], ["enter", f, s]], d = s.parser.constructs.insideSpan.null;
            d && Zt(p, p.length, 0, hs(d, a.slice(u + 1, l), s)), Zt(p, p.length, 0, [["exit", f, s], ["enter", a[l][1], s], ["exit", a[l][1], s], ["exit", c, s]]), Zt(a, u - 1, l - u + 3, p), l = u + p.length - 2;
            break;
          }
      }
    for (l = -1; ++l < a.length; )
      a[l][1].type === "strikethroughSequenceTemporary" && (a[l][1].type = "data");
    return a;
  }
  function o(a, s, l) {
    const u = this.previous, c = this.events;
    let f = 0;
    return p;
    function p(v) {
      return u === 126 && c[c.length - 1][1].type !== "characterEscape" ? l(v) : (a.enter("strikethroughSequenceTemporary"), d(v));
    }
    function d(v) {
      const h = Na(u);
      if (v === 126)
        return f > 1 ? l(v) : (a.consume(v), f++, d);
      if (f < 2 && !n) return l(v);
      const g = a.exit("strikethroughSequenceTemporary"), m = Na(v);
      return g._open = !m || m === 2 && !!h, g._close = !h || h === 2 && !!m, s(v);
    }
  }
}
class ER {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    kR(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(o, a) {
      return o[0] - a[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push([...t]), t.length = 0;
    let i = r.pop();
    for (; i; )
      t.push(...i), i = r.pop();
    this.map.length = 0;
  }
}
function kR(e, t, n, r) {
  let i = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === t) {
        e.map[i][1] += n, e.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    e.map.push([t, n, r]);
  }
}
function CR(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const i = e[t];
    if (n) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const o = r.length - 1;
          r[o] = r[o] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function $R() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: TR,
        resolveAll: OR
      }
    }
  };
}
function TR(e, t, n) {
  const r = this;
  let i = 0, o = 0, a;
  return s;
  function s(O) {
    let _ = r.events.length - 1;
    for (; _ > -1; ) {
      const I = r.events[_][1].type;
      if (I === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      I === "linePrefix") _--;
      else break;
    }
    const V = _ > -1 ? r.events[_][1].type : null, L = V === "tableHead" || V === "tableRow" ? E : l;
    return L === E && r.parser.lazy[r.now().line] ? n(O) : L(O);
  }
  function l(O) {
    return e.enter("tableHead"), e.enter("tableRow"), u(O);
  }
  function u(O) {
    return O === 124 || (a = !0, o += 1), c(O);
  }
  function c(O) {
    return O === null ? n(O) : de(O) ? o > 1 ? (o = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(O), e.exit("lineEnding"), d) : n(O) : be(O) ? ke(e, c, "whitespace")(O) : (o += 1, a && (a = !1, i += 1), O === 124 ? (e.enter("tableCellDivider"), e.consume(O), e.exit("tableCellDivider"), a = !0, c) : (e.enter("data"), f(O)));
  }
  function f(O) {
    return O === null || O === 124 || ze(O) ? (e.exit("data"), c(O)) : (e.consume(O), O === 92 ? p : f);
  }
  function p(O) {
    return O === 92 || O === 124 ? (e.consume(O), f) : f(O);
  }
  function d(O) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(O) : (e.enter("tableDelimiterRow"), a = !1, be(O) ? ke(e, v, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(O) : v(O));
  }
  function v(O) {
    return O === 45 || O === 58 ? g(O) : O === 124 ? (a = !0, e.enter("tableCellDivider"), e.consume(O), e.exit("tableCellDivider"), h) : S(O);
  }
  function h(O) {
    return be(O) ? ke(e, g, "whitespace")(O) : g(O);
  }
  function g(O) {
    return O === 58 ? (o += 1, a = !0, e.enter("tableDelimiterMarker"), e.consume(O), e.exit("tableDelimiterMarker"), m) : O === 45 ? (o += 1, m(O)) : O === null || de(O) ? C(O) : S(O);
  }
  function m(O) {
    return O === 45 ? (e.enter("tableDelimiterFiller"), b(O)) : S(O);
  }
  function b(O) {
    return O === 45 ? (e.consume(O), b) : O === 58 ? (a = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(O), e.exit("tableDelimiterMarker"), x) : (e.exit("tableDelimiterFiller"), x(O));
  }
  function x(O) {
    return be(O) ? ke(e, C, "whitespace")(O) : C(O);
  }
  function C(O) {
    return O === 124 ? v(O) : O === null || de(O) ? !a || i !== o ? S(O) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(O)) : S(O);
  }
  function S(O) {
    return n(O);
  }
  function E(O) {
    return e.enter("tableRow"), T(O);
  }
  function T(O) {
    return O === 124 ? (e.enter("tableCellDivider"), e.consume(O), e.exit("tableCellDivider"), T) : O === null || de(O) ? (e.exit("tableRow"), t(O)) : be(O) ? ke(e, T, "whitespace")(O) : (e.enter("data"), N(O));
  }
  function N(O) {
    return O === null || O === 124 || ze(O) ? (e.exit("data"), T(O)) : (e.consume(O), O === 92 ? j : N);
  }
  function j(O) {
    return O === 92 || O === 124 ? (e.consume(O), N) : N(O);
  }
}
function OR(e, t) {
  let n = -1, r = !0, i = 0, o = [0, 0, 0, 0], a = [0, 0, 0, 0], s = !1, l = 0, u, c, f;
  const p = new ER();
  for (; ++n < e.length; ) {
    const d = e[n], v = d[1];
    d[0] === "enter" ? v.type === "tableHead" ? (s = !1, l !== 0 && (kh(p, t, l, u, c), c = void 0, l = 0), u = {
      type: "table",
      start: Object.assign({}, v.start),
      // Note: correct end is set later.
      end: Object.assign({}, v.end)
    }, p.add(n, 0, [["enter", u, t]])) : v.type === "tableRow" || v.type === "tableDelimiterRow" ? (r = !0, f = void 0, o = [0, 0, 0, 0], a = [0, n + 1, 0, 0], s && (s = !1, c = {
      type: "tableBody",
      start: Object.assign({}, v.start),
      // Note: correct end is set later.
      end: Object.assign({}, v.end)
    }, p.add(n, 0, [["enter", c, t]])), i = v.type === "tableDelimiterRow" ? 2 : c ? 3 : 1) : i && (v.type === "data" || v.type === "tableDelimiterMarker" || v.type === "tableDelimiterFiller") ? (r = !1, a[2] === 0 && (o[1] !== 0 && (a[0] = a[1], f = Vo(p, t, o, i, void 0, f), o = [0, 0, 0, 0]), a[2] = n)) : v.type === "tableCellDivider" && (r ? r = !1 : (o[1] !== 0 && (a[0] = a[1], f = Vo(p, t, o, i, void 0, f)), o = a, a = [o[1], n, 0, 0])) : v.type === "tableHead" ? (s = !0, l = n) : v.type === "tableRow" || v.type === "tableDelimiterRow" ? (l = n, o[1] !== 0 ? (a[0] = a[1], f = Vo(p, t, o, i, n, f)) : a[1] !== 0 && (f = Vo(p, t, a, i, n, f)), i = 0) : i && (v.type === "data" || v.type === "tableDelimiterMarker" || v.type === "tableDelimiterFiller") && (a[3] = n);
  }
  for (l !== 0 && kh(p, t, l, u, c), p.consume(t.events), n = -1; ++n < t.events.length; ) {
    const d = t.events[n];
    d[0] === "enter" && d[1].type === "table" && (d[1]._align = CR(t.events, n));
  }
  return e;
}
function Vo(e, t, n, r, i, o) {
  const a = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", s = "tableContent";
  n[0] !== 0 && (o.end = Object.assign({}, Nr(t.events, n[0])), e.add(n[0], 0, [["exit", o, t]]));
  const l = Nr(t.events, n[1]);
  if (o = {
    type: a,
    start: Object.assign({}, l),
    // Note: correct end is set later.
    end: Object.assign({}, l)
  }, e.add(n[1], 0, [["enter", o, t]]), n[2] !== 0) {
    const u = Nr(t.events, n[2]), c = Nr(t.events, n[3]), f = {
      type: s,
      start: Object.assign({}, u),
      end: Object.assign({}, c)
    };
    if (e.add(n[2], 0, [["enter", f, t]]), r !== 2) {
      const p = t.events[n[2]], d = t.events[n[3]];
      if (p[1].end = Object.assign({}, d[1].end), p[1].type = "chunkText", p[1].contentType = "text", n[3] > n[2] + 1) {
        const v = n[2] + 1, h = n[3] - n[2] - 1;
        e.add(v, h, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", f, t]]);
  }
  return i !== void 0 && (o.end = Object.assign({}, Nr(t.events, i)), e.add(i, 0, [["exit", o, t]]), o = void 0), o;
}
function kh(e, t, n, r, i) {
  const o = [], a = Nr(t.events, n);
  i && (i.end = Object.assign({}, a), o.push(["exit", i, t])), r.end = Object.assign({}, a), o.push(["exit", r, t]), e.add(n + 1, 0, o);
}
function Nr(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const IR = {
  name: "tasklistCheck",
  tokenize: PR
};
function RR() {
  return {
    text: {
      91: IR
    }
  };
}
function PR(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return (
      // Exit if there’s stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(l) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), o)
    );
  }
  function o(l) {
    return ze(l) ? (e.enter("taskListCheckValueUnchecked"), e.consume(l), e.exit("taskListCheckValueUnchecked"), a) : l === 88 || l === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(l), e.exit("taskListCheckValueChecked"), a) : n(l);
  }
  function a(l) {
    return l === 93 ? (e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), s) : n(l);
  }
  function s(l) {
    return de(l) ? t(l) : be(l) ? e.check({
      tokenize: AR
    }, t, n)(l) : n(l);
  }
}
function AR(e, t, n) {
  return ke(e, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : t(i);
  }
}
function DR(e) {
  return rb([
    iR(),
    hR(),
    SR(e),
    $R(),
    RR()
  ]);
}
const _R = {};
function MR(e) {
  const t = (
    /** @type {Processor} */
    this
  ), n = e || _R, r = t.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), o = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), a = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(DR(n)), o.push(eR()), a.push(tR(n));
}
const Te = {
  container: {
    className: "bpReset bpContainer bpFont",
    dropzone: {
      overlay: {
        className: "bpDropzoneOverlay"
      },
      container: {
        className: "bpDropzoneContainer"
      }
    }
  },
  loader: {
    className: "bpReset bpLoader"
  },
  modal: {
    overlay: {
      className: "bpModalOverlay"
    },
    dialog: {
      container: {
        className: "bpReset bpModalContainer"
      },
      title: {
        className: "bpModalTitle"
      },
      description: {
        className: "bpModalDescription"
      },
      content: {
        container: {
          className: "bpModalContentContainer"
        },
        textarea: {
          className: "bpModalContentTextArea"
        }
      },
      button: {
        container: {
          className: "bpModalButtonContainer"
        },
        confirm: {
          className: "bpModalButtonConfirm"
        },
        cancel: {
          className: "bpModalButtonCancel"
        }
      }
    }
  },
  fab: {
    container: {
      className: "bpReset bpFabContainer"
    },
    icon: {
      className: "bpFabIcon"
    },
    image: {
      className: "bpFabImage"
    }
  },
  notification: {
    container: {
      className: "bpReset bpNotificationContainer"
    },
    title: {
      className: "bpNotificationTitle"
    },
    description: {
      className: "bpNotificationDescription"
    },
    icon: {
      className: "bpNotificationIcon"
    },
    closeIcon: {
      className: "bpNotificationCloseIcon"
    }
  },
  header: {
    container: {
      className: "bpReset bpHeaderContainer bpFont"
    },
    content: {
      container: {
        className: "bpReset bpHeaderContentContainer"
      },
      title: {
        className: "bpHeaderContentTitle"
      },
      description: {
        className: "bpHeaderContentDescription"
      },
      avatar: {
        container: {
          className: "bpReset bpHeaderContentAvatarContainer"
        },
        image: {
          className: "bpHeaderContentAvatarImage"
        },
        fallback: {
          className: "bpHeaderContentAvatarFallback"
        }
      },
      actions: {
        container: {
          className: "bpReset bpHeaderContentActionsContainer"
        },
        icons: {
          className: "bpHeaderContentActionsIcons"
        }
      }
    },
    expandedContent: {
      container: {
        className: "bpReset bpHeaderExpandedContentContainer"
      },
      descriptionItems: {
        container: {
          className: "bpReset bpHeaderExpandedContentDescriptionItemsContainer"
        },
        icon: {
          className: "bpHeaderExpandedContentDescriptionItemsIcon"
        },
        text: {
          className: "bpHeaderExpandedContentDescriptionItemsText"
        },
        link: {
          className: "bpHeaderExpandedContentDescriptionItemsLink"
        }
      },
      group: {
        className: "bpHeaderExpandedContentGroup"
      }
    },
    newConversationIcon: {
      className: "bpHeaderNewConversationIcon"
    }
  },
  composer: {
    wrapper: {
      className: "bpReset bpComposerWrapper"
    },
    container: {
      className: "bpReset bpComposerContainer bpFont"
    },
    footer: {
      className: "bpComposerFooter"
    },
    inputContainer: {
      className: "bpComposerInputContainer"
    },
    input: {
      className: "bpComposerInput"
    },
    sendbutton: {
      className: "bpComposerSendButton"
    },
    uploadButton: {
      className: "bpComposerUploadButton"
    },
    voiceButton: {
      className: "bpComposerVoiceButton"
    },
    fileContainer: {
      className: "bpComposerFileContainer"
    },
    fileWidget: {
      container: {
        className: "bpComposerFileAttachement"
      },
      loader: {
        className: "bpComposerFileLoader"
      },
      fileIcon: {
        container: {
          className: "bpComposerFileIconWrapper"
        },
        icon: {
          className: "bpComposerFileIcon"
        }
      },
      metadata: {
        container: {
          className: "bpComposerFileMetadata"
        },
        name: {
          className: "bpComposerFileName"
        },
        type: {
          className: "bpComposerFileExtension"
        }
      },
      removeIcon: {
        className: "bpComposerFileRemoveIcon"
      },
      errorIcon: {
        className: "bpComposerFileErrorIcon"
      },
      previewImage: {
        className: "bpComposerFilePreviewImage"
      }
    }
  },
  messageList: {
    scrollDownButton: {
      className: "bpMessageListScrollDownButton"
    },
    container: {
      className: "bpReset bpMessageListContainer bpFont"
    },
    viewPort: {
      className: "bpMessageListViewport"
    },
    marquee: {
      container: {
        className: "bpReset bpMessageListMarqueeContainer"
      },
      content: {
        className: "bpMessageListMarqueeContent"
      },
      title: {
        className: "bpMessageListMarqueeTitle"
      },
      description: {
        className: "bpMessageListMarqueeDescription"
      },
      avatar: {
        container: {
          className: "bpReset bpMessageListMarqueeAvatarContainer"
        },
        image: {
          className: "bpMessageListMarqueeAvatarImage"
        },
        fallback: {
          className: "bpMessageListMarqueeAvatarFallback"
        }
      }
    },
    headerMessage: {
      className: "bpMessageListHeaderMessage"
    }
  },
  message: {
    container: {
      className: "bpReset bpMessageContainer"
    },
    avatar: {
      container: {
        className: "bpReset bpMessageAvatarContainer"
      },
      image: {
        className: "bpMessageAvatarImage"
      },
      fallback: {
        className: "bpMessageAvatarFallback"
      }
    },
    blocks: {
      text: {
        heading1: {
          className: "bpMessageBlocksTextHeading1"
        },
        heading2: {
          className: "bpMessageBlocksTextHeading2"
        },
        heading3: {
          className: "bpMessageBlocksTextHeading3"
        },
        heading4: {
          className: "bpMessageBlocksTextHeading4"
        },
        unorderedList: {
          className: "bpMessageBlocksTextUnorderedList"
        },
        orderedList: {
          className: "bpMessageBlocksTextOrderedList"
        },
        listItem: {
          className: "bpMessageBlocksTextListItem"
        },
        link: {
          className: "bpMessageBlocksTextLink"
        },
        italic: {
          className: "bpMessageBlocksTextItalic"
        },
        bold: {
          className: "bpMessageBlocksTextBold"
        },
        text: {
          className: "bpMessageBlocksTextText"
        },
        image: {
          className: "bpMessageBlocksTextImage"
        },
        horizontalRule: {
          className: "bpMessageBlocksTextHorizontalRule"
        },
        lineBreak: {
          className: "bpMessageBlocksTextLineBreak"
        },
        input: {
          className: "bpMessageBlocksTextInput"
        },
        codeBlockContainer: {
          className: "bpMessageBlocksTextCodeBlockContainer"
        },
        codeBlockTitle: {
          className: "bpMessageBlocksTextCodeBlockTitle"
        },
        codeBlockCopyIcon: {
          className: "bpMessageBlocksTextCodeBlockCopyIcon"
        },
        codeBlock: {
          className: "bpMessageBlocksTextCodeBlock"
        },
        code: {
          className: "bpMessageBlocksTextCode"
        },
        tableContainer: {
          className: "bpMessageBlocksTextTableContainer"
        },
        table: {
          className: "bpMessageBlocksTextTable"
        },
        tableHeader: {
          className: "bpMessageBlocksTextTableHeader"
        },
        tableData: {
          className: "bpMessageBlocksTextTableData"
        },
        tableRow: {
          className: "bpMessageBlocksTextTableRow"
        }
      },
      audio: {
        className: "bpMessageBlocksAudio"
      },
      image: {
        image: {
          className: "bpMessageBlocksImageImage"
        },
        placeholder: {
          className: "bpMessageBlocksImagePlaceholder"
        }
      },
      video: {
        className: "bpMessageBlocksVideo"
      },
      location: {
        container: {
          className: "bpMessageBlocksLocationContainer"
        },
        title: {
          className: "bpMessageBlocksLocationTitle"
        },
        icon: {
          className: "bpMessageBlocksLocationIcon"
        }
      },
      file: {
        container: {
          className: "bpMessageBlocksFileContainer"
        },
        title: {
          className: "bpMessageBlocksFileTitle"
        },
        icon: {
          className: "bpMessageBlocksFileIcon"
        }
      },
      row: {
        className: "bpMessageBlocksRow"
      },
      column: {
        className: "bpMessageBlocksColumn"
      },
      bubble: {
        container: {
          className: "bpMessageBlocksBubble"
        },
        feedbackContainer: {
          className: "bpMessageBlocksBubbleFeedbackContainer"
        },
        feedbackIcon: {
          className: "bpMessageBlocksBubbleFeedbackIcon"
        }
      },
      carousel: {
        container: {
          className: "bpMessageBlocksCarouselContainer"
        },
        slidesContainer: {
          className: "bpMessageBlocksCarouselSlidesContainer"
        },
        backButton: {
          className: "bpMessageBlocksCarouselBackButton"
        },
        nextButton: {
          className: "bpMessageBlocksCarouselNextButton"
        }
      },
      dropdown: {
        button: {
          container: {
            className: "bpMessageBlocksDropdownButtonContainer"
          },
          text: {
            className: "bpMessageBlocksDropdownButtonText"
          },
          icon: {
            className: "bpMessageBlocksDropdownButtonIcon"
          }
        },
        content: {
          container: {
            className: "bpMessageBlocksDropdownContentContainer"
          },
          item: {
            className: "bpMessageBlocksDropdownContentItem"
          }
        }
      },
      button: {
        className: "bpMessageBlocksButton"
      }
    }
  },
  typingIndicator: {
    container: {
      className: "bpTypingIndicatorContainer"
    },
    loader: {
      className: "bpTypingIndicatorLoader"
    }
  }
};
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const jR = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), Xb = (...e) => e.filter((t, n, r) => !!t && r.indexOf(t) === n).join(" ");
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var NR = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const LR = Ot(
  ({
    color: e = "currentColor",
    size: t = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: r,
    className: i = "",
    children: o,
    iconNode: a,
    ...s
  }, l) => Yu(
    "svg",
    {
      ref: l,
      ...NR,
      width: t,
      height: t,
      stroke: e,
      strokeWidth: r ? Number(n) * 24 / Number(t) : n,
      className: Xb("lucide", i),
      ...s
    },
    [
      ...a.map(([u, c]) => Yu(u, c)),
      ...Array.isArray(o) ? o : [o]
    ]
  )
);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ue = (e, t) => {
  const n = Ot(
    ({ className: r, ...i }, o) => Yu(LR, {
      ref: o,
      iconNode: t,
      className: Xb(`lucide-${jR(e)}`, r),
      ...i
    })
  );
  return n.displayName = `${e}`, n;
};
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const FR = Ue("ArrowUp", [
  ["path", { d: "m5 12 7-7 7 7", key: "hav0vg" }],
  ["path", { d: "M12 19V5", key: "x0mq9r" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const BR = Ue("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const zR = Ue("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const WR = Ue("ChevronLeft", [
  ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const UR = Ue("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const HR = Ue("CircleAlert", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
  ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Jb = Ue("CircleX", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m15 9-6 6", key: "1uzhvr" }],
  ["path", { d: "m9 9 6 6", key: "z0biqf" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const VR = Ue("CloudUpload", [
  ["path", { d: "M12 13v8", key: "1l5pq0" }],
  ["path", { d: "M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242", key: "1pljnt" }],
  ["path", { d: "m8 17 4-4 4 4", key: "1quai1" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const KR = Ue("ExternalLink", [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "M10 14 21 3", key: "gplh6r" }],
  ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const qR = Ue("FileDown", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M12 18v-6", key: "17g6i2" }],
  ["path", { d: "m9 15 3 3 3-3", key: "1npd3o" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Zb = Ue("FileText", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M10 9H8", key: "b1mrlr" }],
  ["path", { d: "M16 13H8", key: "t4e002" }],
  ["path", { d: "M16 17H8", key: "z1uh3a" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const GR = Ue("Files", [
  ["path", { d: "M20 7h-3a2 2 0 0 1-2-2V2", key: "x099mo" }],
  ["path", { d: "M9 18a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h7l4 4v10a2 2 0 0 1-2 2Z", key: "18t6ie" }],
  ["path", { d: "M3 7.6v12.8A1.6 1.6 0 0 0 4.6 22h9.8", key: "1nja0z" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const YR = Ue("Globe", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" }],
  ["path", { d: "M2 12h20", key: "9i4pu4" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const XR = Ue("Image", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2", key: "1m3agn" }],
  ["circle", { cx: "9", cy: "9", r: "2", key: "af1f0g" }],
  ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21", key: "1xmnt7" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const JR = Ue("Lock", [
  ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }],
  ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4", key: "fwvmzm" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ZR = Ue("Mail", [
  ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }],
  ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7", key: "1ocrg3" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const QR = Ue("MapPin", [
  [
    "path",
    {
      d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0",
      key: "1r0f0z"
    }
  ],
  ["circle", { cx: "12", cy: "10", r: "3", key: "ilqhr7" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const eP = Ue("Mic", [
  ["path", { d: "M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z", key: "131961" }],
  ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2", key: "1vc78b" }],
  ["line", { x1: "12", x2: "12", y1: "19", y2: "22", key: "x3vr5v" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const tP = Ue("Phone", [
  [
    "path",
    {
      d: "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z",
      key: "foiqr5"
    }
  ]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const nP = Ue("Plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const rP = Ue("RotateCcw", [
  ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const iP = Ue("ThumbsDown", [
  ["path", { d: "M17 14V2", key: "8ymqnk" }],
  [
    "path",
    {
      d: "M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22a3.13 3.13 0 0 1-3-3.88Z",
      key: "m61m77"
    }
  ]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const oP = Ue("ThumbsUp", [
  ["path", { d: "M7 10v12", key: "1qc93n" }],
  [
    "path",
    {
      d: "M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2a3.13 3.13 0 0 1 3 3.88Z",
      key: "emmmcr"
    }
  ]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const aP = Ue("Video", [
  [
    "path",
    {
      d: "m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5",
      key: "ftymec"
    }
  ],
  ["rect", { x: "2", y: "6", width: "14", height: "12", rx: "2", key: "158x01" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const sP = Ue("Volume2", [
  ["polygon", { points: "11 5 6 9 2 9 2 15 6 15 11 19 11 5", key: "16drj5" }],
  ["path", { d: "M15.54 8.46a5 5 0 0 1 0 7.07", key: "ltjumu" }],
  ["path", { d: "M19.07 4.93a10 10 0 0 1 0 14.14", key: "1kegas" }]
]);
/**
 * @license lucide-react v0.424.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const lP = Ue("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]), uP = ({ text: e }) => {
  const {
    message: {
      blocks: { text: t }
    }
  } = Te, n = {
    h1: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("h1", { ...i, ...t.heading1 }),
    h2: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("h2", { ...i, ...t.heading2 }),
    h3: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("h3", { ...i, ...t.heading3 }),
    h4: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("h4", { ...i, ...t.heading4 }),
    h5: "h4",
    h6: "h4",
    em: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("em", { ...i, ...t.italic }),
    strong: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("strong", { ...i, ...t.bold }),
    p: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("p", { ...i, ...t.text }),
    hr: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("hr", { ...i, ...t.horizontalRule }),
    a: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("a", { ...i, ...t.link, target: "_blank" }),
    img: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("img", { ...i, ...t.image }),
    ol: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("ol", { ...i, ...t.orderedList }),
    ul: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("ul", { ...i, ...t.unorderedList }),
    li: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("li", { ...i, ...t.listItem }),
    br: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("br", { ...i, ...t.lineBreak }),
    pre: ({ node: r, ...i }) => {
      var f, p;
      const o = r == null ? void 0 : r.children[0], a = cP(((p = (f = o == null ? void 0 : o.properties) == null ? void 0 : f.className) == null ? void 0 : p[0]) || ""), [s, l] = ge(!1), u = Ve(null), c = () => {
        if (!u.current) return;
        const d = u.current.textContent || "";
        navigator.clipboard.writeText(d).then(() => {
          l(!0), setTimeout(() => {
            l(!1);
          }, 1500);
        }).catch((v) => {
          console.error("Failed to copy code to clipboard:", v);
        });
      };
      return /* @__PURE__ */ $.jsxs("div", { ...t.codeBlockContainer, children: [
        /* @__PURE__ */ $.jsxs("div", { ...t.codeBlockTitle, children: [
          a ? /* @__PURE__ */ $.jsx("span", { children: a }) : "Code",
          s ? /* @__PURE__ */ $.jsx(BR, { ...t.codeBlockCopyIcon }) : /* @__PURE__ */ $.jsx(GR, { ...t.codeBlockCopyIcon, onClick: c })
        ] }),
        /* @__PURE__ */ $.jsx("pre", { ref: u, ...i, ...t.codeBlock })
      ] });
    },
    input: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("input", { ...i, ...t.input, disabled: !1 }),
    code: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("code", { ...i, ...t.code }),
    table: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("div", { ...t.tableContainer, children: /* @__PURE__ */ $.jsx("table", { ...i, ...t.table }) }),
    th: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("th", { ...i, ...t.tableHeader }),
    tr: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("tr", { ...i, ...t.tableRow }),
    td: ({ node: r, ...i }) => /* @__PURE__ */ $.jsx("td", { ...i, ...t.tableData })
  };
  return /* @__PURE__ */ $.jsx(
    Cb,
    {
      urlTransform: (r) => r.startsWith("tel:") ? r : $b(r),
      components: n,
      remarkPlugins: [MR, RO],
      children: e
    }
  );
}, cP = (e) => {
  if (!e) return "";
  const t = e.match(/language-(\w+)/);
  return t ? t[1] : "";
}, fP = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, Ch = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (c, f) => {
    const p = typeof c == "function" ? c(t) : c;
    if (!Object.is(p, t)) {
      const d = t;
      t = f ?? (typeof p != "object" || p === null) ? p : Object.assign({}, t, p), n.forEach((v) => v(t, d));
    }
  }, i = () => t, l = { setState: r, getState: i, getInitialState: () => u, subscribe: (c) => (n.add(c), () => n.delete(c)), destroy: () => {
    (fP ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), n.clear();
  } }, u = t = e(r, i, l);
  return l;
}, dP = (e) => e ? Ch(e) : Ch;
var uc = { exports: {} }, Sl = {}, Ko = { exports: {} }, El = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $h;
function pP() {
  if ($h) return El;
  $h = 1;
  var e = Ne;
  function t(f, p) {
    return f === p && (f !== 0 || 1 / f === 1 / p) || f !== f && p !== p;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, o = e.useLayoutEffect, a = e.useDebugValue;
  function s(f, p) {
    var d = p(), v = r({ inst: { value: d, getSnapshot: p } }), h = v[0].inst, g = v[1];
    return o(function() {
      h.value = d, h.getSnapshot = p, l(h) && g({ inst: h });
    }, [f, d, p]), i(function() {
      return l(h) && g({ inst: h }), f(function() {
        l(h) && g({ inst: h });
      });
    }, [f]), a(d), d;
  }
  function l(f) {
    var p = f.getSnapshot;
    f = f.value;
    try {
      var d = p();
      return !n(f, d);
    } catch {
      return !0;
    }
  }
  function u(f, p) {
    return p();
  }
  var c = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? u : s;
  return El.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : c, El;
}
var kl = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Th;
function hP() {
  return Th || (Th = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = Ne, t = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function n(x) {
      {
        for (var C = arguments.length, S = new Array(C > 1 ? C - 1 : 0), E = 1; E < C; E++)
          S[E - 1] = arguments[E];
        r("error", x, S);
      }
    }
    function r(x, C, S) {
      {
        var E = t.ReactDebugCurrentFrame, T = E.getStackAddendum();
        T !== "" && (C += "%s", S = S.concat([T]));
        var N = S.map(function(j) {
          return String(j);
        });
        N.unshift("Warning: " + C), Function.prototype.apply.call(console[x], console, N);
      }
    }
    function i(x, C) {
      return x === C && (x !== 0 || 1 / x === 1 / C) || x !== x && C !== C;
    }
    var o = typeof Object.is == "function" ? Object.is : i, a = e.useState, s = e.useEffect, l = e.useLayoutEffect, u = e.useDebugValue, c = !1, f = !1;
    function p(x, C, S) {
      c || e.startTransition !== void 0 && (c = !0, n("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var E = C();
      if (!f) {
        var T = C();
        o(E, T) || (n("The result of getSnapshot should be cached to avoid an infinite loop"), f = !0);
      }
      var N = a({
        inst: {
          value: E,
          getSnapshot: C
        }
      }), j = N[0].inst, O = N[1];
      return l(function() {
        j.value = E, j.getSnapshot = C, d(j) && O({
          inst: j
        });
      }, [x, E, C]), s(function() {
        d(j) && O({
          inst: j
        });
        var _ = function() {
          d(j) && O({
            inst: j
          });
        };
        return x(_);
      }, [x]), u(E), E;
    }
    function d(x) {
      var C = x.getSnapshot, S = x.value;
      try {
        var E = C();
        return !o(S, E);
      } catch {
        return !0;
      }
    }
    function v(x, C, S) {
      return C();
    }
    var h = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", g = !h, m = g ? v : p, b = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : m;
    kl.useSyncExternalStore = b, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), kl;
}
var Oh;
function Qb() {
  return Oh || (Oh = 1, process.env.NODE_ENV === "production" ? Ko.exports = pP() : Ko.exports = hP()), Ko.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ih;
function vP() {
  if (Ih) return Sl;
  Ih = 1;
  var e = Ne, t = Qb();
  function n(u, c) {
    return u === c && (u !== 0 || 1 / u === 1 / c) || u !== u && c !== c;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, a = e.useEffect, s = e.useMemo, l = e.useDebugValue;
  return Sl.useSyncExternalStoreWithSelector = function(u, c, f, p, d) {
    var v = o(null);
    if (v.current === null) {
      var h = { hasValue: !1, value: null };
      v.current = h;
    } else h = v.current;
    v = s(function() {
      function m(E) {
        if (!b) {
          if (b = !0, x = E, E = p(E), d !== void 0 && h.hasValue) {
            var T = h.value;
            if (d(T, E)) return C = T;
          }
          return C = E;
        }
        if (T = C, r(x, E)) return T;
        var N = p(E);
        return d !== void 0 && d(T, N) ? T : (x = E, C = N);
      }
      var b = !1, x, C, S = f === void 0 ? null : f;
      return [function() {
        return m(c());
      }, S === null ? void 0 : function() {
        return m(S());
      }];
    }, [c, f, p, d]);
    var g = i(u, v[0], v[1]);
    return a(function() {
      h.hasValue = !0, h.value = g;
    }, [g]), l(g), g;
  }, Sl;
}
var Cl = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Rh;
function mP() {
  return Rh || (Rh = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = Ne, t = Qb();
    function n(c, f) {
      return c === f && (c !== 0 || 1 / c === 1 / f) || c !== c && f !== f;
    }
    var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, a = e.useEffect, s = e.useMemo, l = e.useDebugValue;
    function u(c, f, p, d, v) {
      var h = o(null), g;
      h.current === null ? (g = {
        hasValue: !1,
        value: null
      }, h.current = g) : g = h.current;
      var m = s(function() {
        var S = !1, E, T, N = function(V) {
          if (!S) {
            S = !0, E = V;
            var L = d(V);
            if (v !== void 0 && g.hasValue) {
              var I = g.value;
              if (v(I, L))
                return T = I, I;
            }
            return T = L, L;
          }
          var A = E, M = T;
          if (r(A, V))
            return M;
          var q = d(V);
          return v !== void 0 && v(M, q) ? M : (E = V, T = q, q);
        }, j = p === void 0 ? null : p, O = function() {
          return N(f());
        }, _ = j === null ? void 0 : function() {
          return N(j());
        };
        return [O, _];
      }, [f, p, d, v]), b = m[0], x = m[1], C = i(c, b, x);
      return a(function() {
        g.hasValue = !0, g.value = C;
      }, [C]), l(C), C;
    }
    Cl.useSyncExternalStoreWithSelector = u, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Cl;
}
process.env.NODE_ENV === "production" ? uc.exports = vP() : uc.exports = mP();
var gP = uc.exports;
const yP = /* @__PURE__ */ Ce(gP), ex = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, { useDebugValue: bP } = Ne, { useSyncExternalStoreWithSelector: xP } = yP;
let Ph = !1;
const wP = (e) => e;
function SP(e, t = wP, n) {
  (ex ? "production" : void 0) !== "production" && n && !Ph && (console.warn(
    "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
  ), Ph = !0);
  const r = xP(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return bP(r), r;
}
const EP = (e) => {
  (ex ? "production" : void 0) !== "production" && typeof e != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const t = typeof e == "function" ? dP(e) : e, n = (r, i) => SP(t, r, i);
  return Object.assign(n, t), n;
}, di = (e) => EP, xa = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, cc = /* @__PURE__ */ new Map(), qo = (e) => {
  const t = cc.get(e);
  return t ? Object.fromEntries(
    Object.entries(t.stores).map(([n, r]) => [n, r.getState()])
  ) : {};
}, kP = (e, t, n) => {
  if (e === void 0)
    return {
      type: "untracked",
      connection: t.connect(n)
    };
  const r = cc.get(n.name);
  if (r)
    return { type: "tracked", store: e, ...r };
  const i = {
    connection: t.connect(n),
    stores: {}
  };
  return cc.set(n.name, i), { type: "tracked", store: e, ...i };
}, CP = (e, t = {}) => (n, r, i) => {
  const { enabled: o, anonymousActionType: a, store: s, ...l } = t;
  let u;
  try {
    u = (o ?? (xa ? "production" : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch {
  }
  if (!u)
    return (xa ? "production" : void 0) !== "production" && o && console.warn(
      "[zustand devtools middleware] Please install/enable Redux devtools extension"
    ), e(n, r, i);
  const { connection: c, ...f } = kP(s, u, l);
  let p = !0;
  i.setState = (h, g, m) => {
    const b = n(h, g);
    if (!p) return b;
    const x = m === void 0 ? { type: a || "anonymous" } : typeof m == "string" ? { type: m } : m;
    return s === void 0 ? (c == null || c.send(x, r()), b) : (c == null || c.send(
      {
        ...x,
        type: `${s}/${x.type}`
      },
      {
        ...qo(l.name),
        [s]: i.getState()
      }
    ), b);
  };
  const d = (...h) => {
    const g = p;
    p = !1, n(...h), p = g;
  }, v = e(i.setState, r, i);
  if (f.type === "untracked" ? c == null || c.init(v) : (f.stores[f.store] = i, c == null || c.init(
    Object.fromEntries(
      Object.entries(f.stores).map(([h, g]) => [
        h,
        h === f.store ? v : g.getState()
      ])
    )
  )), i.dispatchFromDevtools && typeof i.dispatch == "function") {
    let h = !1;
    const g = i.dispatch;
    i.dispatch = (...m) => {
      (xa ? "production" : void 0) !== "production" && m[0].type === "__setState" && !h && (console.warn(
        '[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'
      ), h = !0), g(...m);
    };
  }
  return c.subscribe((h) => {
    var g;
    switch (h.type) {
      case "ACTION":
        if (typeof h.payload != "string") {
          console.error(
            "[zustand devtools middleware] Unsupported action format"
          );
          return;
        }
        return $l(
          h.payload,
          (m) => {
            if (m.type === "__setState") {
              if (s === void 0) {
                d(m.state);
                return;
              }
              Object.keys(m.state).length !== 1 && console.error(
                `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
              );
              const b = m.state[s];
              if (b == null)
                return;
              JSON.stringify(i.getState()) !== JSON.stringify(b) && d(b);
              return;
            }
            i.dispatchFromDevtools && typeof i.dispatch == "function" && i.dispatch(m);
          }
        );
      case "DISPATCH":
        switch (h.payload.type) {
          case "RESET":
            return d(v), s === void 0 ? c == null ? void 0 : c.init(i.getState()) : c == null ? void 0 : c.init(qo(l.name));
          case "COMMIT":
            if (s === void 0) {
              c == null || c.init(i.getState());
              return;
            }
            return c == null ? void 0 : c.init(qo(l.name));
          case "ROLLBACK":
            return $l(h.state, (m) => {
              if (s === void 0) {
                d(m), c == null || c.init(i.getState());
                return;
              }
              d(m[s]), c == null || c.init(qo(l.name));
            });
          case "JUMP_TO_STATE":
          case "JUMP_TO_ACTION":
            return $l(h.state, (m) => {
              if (s === void 0) {
                d(m);
                return;
              }
              JSON.stringify(i.getState()) !== JSON.stringify(m[s]) && d(m[s]);
            });
          case "IMPORT_STATE": {
            const { nextLiftedState: m } = h.payload, b = (g = m.computedStates.slice(-1)[0]) == null ? void 0 : g.state;
            if (!b) return;
            d(s === void 0 ? b : b[s]), c == null || c.send(
              null,
              // FIXME no-any
              m
            );
            return;
          }
          case "PAUSE_RECORDING":
            return p = !p;
        }
        return;
    }
  }), v;
}, ys = CP, $l = (e, t) => {
  let n;
  try {
    n = JSON.parse(e);
  } catch (r) {
    console.error(
      "[zustand devtools middleware] Could not parse the received json",
      r
    );
  }
  n !== void 0 && t(n);
};
function tx(e, t) {
  let n;
  try {
    n = e();
  } catch {
    return;
  }
  return {
    getItem: (i) => {
      var o;
      const a = (l) => l === null ? null : JSON.parse(l, void 0), s = (o = n.getItem(i)) != null ? o : null;
      return s instanceof Promise ? s.then(a) : a(s);
    },
    setItem: (i, o) => n.setItem(
      i,
      JSON.stringify(o, void 0)
    ),
    removeItem: (i) => n.removeItem(i)
  };
}
const Ji = (e) => (t) => {
  try {
    const n = e(t);
    return n instanceof Promise ? n : {
      then(r) {
        return Ji(r)(n);
      },
      catch(r) {
        return this;
      }
    };
  } catch (n) {
    return {
      then(r) {
        return this;
      },
      catch(r) {
        return Ji(r)(n);
      }
    };
  }
}, $P = (e, t) => (n, r, i) => {
  let o = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (g) => g,
    version: 0,
    merge: (g, m) => ({
      ...m,
      ...g
    }),
    ...t
  }, a = !1;
  const s = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  let u;
  try {
    u = o.getStorage();
  } catch {
  }
  if (!u)
    return e(
      (...g) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`
        ), n(...g);
      },
      r,
      i
    );
  const c = Ji(o.serialize), f = () => {
    const g = o.partialize({ ...r() });
    let m;
    const b = c({ state: g, version: o.version }).then(
      (x) => u.setItem(o.name, x)
    ).catch((x) => {
      m = x;
    });
    if (m)
      throw m;
    return b;
  }, p = i.setState;
  i.setState = (g, m) => {
    p(g, m), f();
  };
  const d = e(
    (...g) => {
      n(...g), f();
    },
    r,
    i
  );
  let v;
  const h = () => {
    var g;
    if (!u) return;
    a = !1, s.forEach((b) => b(r()));
    const m = ((g = o.onRehydrateStorage) == null ? void 0 : g.call(o, r())) || void 0;
    return Ji(u.getItem.bind(u))(o.name).then((b) => {
      if (b)
        return o.deserialize(b);
    }).then((b) => {
      if (b)
        if (typeof b.version == "number" && b.version !== o.version) {
          if (o.migrate)
            return o.migrate(
              b.state,
              b.version
            );
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return b.state;
    }).then((b) => {
      var x;
      return v = o.merge(
        b,
        (x = r()) != null ? x : d
      ), n(v, !0), f();
    }).then(() => {
      m == null || m(v, void 0), a = !0, l.forEach((b) => b(v));
    }).catch((b) => {
      m == null || m(void 0, b);
    });
  };
  return i.persist = {
    setOptions: (g) => {
      o = {
        ...o,
        ...g
      }, g.getStorage && (u = g.getStorage());
    },
    clearStorage: () => {
      u == null || u.removeItem(o.name);
    },
    getOptions: () => o,
    rehydrate: () => h(),
    hasHydrated: () => a,
    onHydrate: (g) => (s.add(g), () => {
      s.delete(g);
    }),
    onFinishHydration: (g) => (l.add(g), () => {
      l.delete(g);
    })
  }, h(), v || d;
}, TP = (e, t) => (n, r, i) => {
  let o = {
    storage: tx(() => localStorage),
    partialize: (h) => h,
    version: 0,
    merge: (h, g) => ({
      ...g,
      ...h
    }),
    ...t
  }, a = !1;
  const s = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  let u = o.storage;
  if (!u)
    return e(
      (...h) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`
        ), n(...h);
      },
      r,
      i
    );
  const c = () => {
    const h = o.partialize({ ...r() });
    return u.setItem(o.name, {
      state: h,
      version: o.version
    });
  }, f = i.setState;
  i.setState = (h, g) => {
    f(h, g), c();
  };
  const p = e(
    (...h) => {
      n(...h), c();
    },
    r,
    i
  );
  i.getInitialState = () => p;
  let d;
  const v = () => {
    var h, g;
    if (!u) return;
    a = !1, s.forEach((b) => {
      var x;
      return b((x = r()) != null ? x : p);
    });
    const m = ((g = o.onRehydrateStorage) == null ? void 0 : g.call(o, (h = r()) != null ? h : p)) || void 0;
    return Ji(u.getItem.bind(u))(o.name).then((b) => {
      if (b)
        if (typeof b.version == "number" && b.version !== o.version) {
          if (o.migrate)
            return [
              !0,
              o.migrate(
                b.state,
                b.version
              )
            ];
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return [!1, b.state];
      return [!1, void 0];
    }).then((b) => {
      var x;
      const [C, S] = b;
      if (d = o.merge(
        S,
        (x = r()) != null ? x : p
      ), n(d, !0), C)
        return c();
    }).then(() => {
      m == null || m(d, void 0), d = r(), a = !0, l.forEach((b) => b(d));
    }).catch((b) => {
      m == null || m(void 0, b);
    });
  };
  return i.persist = {
    setOptions: (h) => {
      o = {
        ...o,
        ...h
      }, h.storage && (u = h.storage);
    },
    clearStorage: () => {
      u == null || u.removeItem(o.name);
    },
    getOptions: () => o,
    rehydrate: () => v(),
    hasHydrated: () => a,
    onHydrate: (h) => (s.add(h), () => {
      s.delete(h);
    }),
    onFinishHydration: (h) => (l.add(h), () => {
      l.delete(h);
    })
  }, o.skipHydration || v(), d || p;
}, OP = (e, t) => "getStorage" in t || "serialize" in t || "deserialize" in t ? ((xa ? "production" : void 0) !== "production" && console.warn(
  "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
), $P(e, t)) : TP(e, t), nx = OP, rx = di()(
  ys(
    nx(
      (e) => ({
        messageHistory: [],
        addMessageToHistory: (t) => e((n) => ({
          ...n,
          messageHistory: [t, ...(n.messageHistory ?? []).slice(0, 100)]
        }))
      }),
      {
        name: "botpress-message-history"
        // Dynamically set the store name
      }
    )
  )
);
function fc(e) {
  var a;
  const { metadata: t, conversationId: n, userId: r } = e, { payload: i, disableInput: o } = IP(e.payload);
  return {
    id: e.id,
    conversationId: n,
    authorId: r,
    timestamp: new Date(e.createdAt),
    block: i,
    feedback: (a = e.feedback) == null ? void 0 : a.value,
    disableInput: o,
    metadata: t
  };
}
const IP = (e) => {
  switch (e.type) {
    case "audio":
      return ix(e);
    case "card":
      return RP(e);
    case "carousel":
      return PP(e);
    case "choice":
      return AP(e);
    case "dropdown":
      return DP(e);
    case "file":
      return ox(e);
    case "image":
      return ax(e);
    case "location":
      return sx(e);
    case "markdown":
      return lx(e);
    case "text":
      return ux(e);
    case "video":
      return cx(e);
    case "bloc":
      return _P(e);
    case "custom":
      return { payload: e };
    default: {
      const t = e;
      throw new Error(`Unsuported message type ${t}`);
    }
  }
}, vo = (e) => ({
  block: e,
  type: "bubble"
}), ix = (e) => ({
  payload: { type: "audio", url: e.audioUrl }
}), RP = (e) => ({
  payload: vo(fx(e))
}), PP = (e) => ({
  payload: {
    type: "carousel",
    blocks: e.items.map((t) => fx({ type: "card", ...t }))
  }
}), AP = (e) => {
  const t = e.options.map((o) => ({ title: o.label, value: o.value })), n = e.text, r = By(), i = vo({
    type: "text",
    text: n
  });
  return t.length === 0 ? {
    disableInput: e.disableFreeText,
    payload: i
  } : {
    disableInput: e.disableFreeText,
    payload: {
      type: "column",
      blocks: [
        i,
        {
          type: "row",
          blocks: t.map(({ title: o, value: a }) => ({
            type: "button",
            variant: "action",
            text: o,
            buttonValue: a,
            groupId: r
          }))
        }
      ]
    }
  };
}, DP = (e) => {
  const t = e.options.map((i) => ({ label: i.label, value: i.value })), n = e.text, r = [
    {
      type: "dropdown",
      label: n ?? "Select an option",
      options: t
    }
  ];
  return n && r.unshift({
    type: "text",
    text: n
  }), {
    disableInput: !0,
    payload: vo({
      type: "column",
      blocks: r
    })
  };
}, ox = (e) => ({
  payload: {
    type: "file",
    url: e.fileUrl,
    title: e.title
  }
}), ax = (e) => ({
  payload: { type: "image", url: e.imageUrl }
}), sx = (e) => ({
  payload: {
    type: "location",
    latitude: e.latitude,
    longitude: e.longitude,
    title: e.title ?? e.address ?? "View on map"
  }
}), lx = (e) => ({
  payload: vo({ type: "text", text: e.markdown })
}), ux = (e) => ({
  payload: vo({ type: "text", text: e.text, value: e.value })
}), cx = (e) => ({
  payload: { type: "video", url: e.videoUrl }
}), _P = (e) => ({ payload: {
  type: "column",
  blocks: e.items.map((n) => {
    switch (n.type) {
      case "audio":
        return ix({ ...n.payload, type: n.type }).payload;
      case "file":
        return ox({ ...n.payload, type: n.type }).payload;
      case "image":
        return ax({ ...n.payload, type: n.type }).payload;
      case "location":
        return sx({ ...n.payload, type: n.type }).payload;
      case "markdown":
        return lx({ ...n.payload, type: n.type }).payload;
      case "text":
        return ux({ ...n.payload, type: n.type }).payload;
      case "video":
        return cx({ ...n.payload, type: n.type }).payload;
      default:
        throw new Error("Unsuported message type");
    }
  })
} }), fx = (e) => {
  const t = e.title, n = e.subtitle, r = e.imageUrl, i = e.actions.map((a) => {
    switch (a.action) {
      case "postback":
        return {
          type: "button",
          variant: "action",
          text: a.label,
          buttonValue: a.value,
          reusable: !0
        };
      case "url":
        return {
          type: "button",
          variant: "link",
          text: a.label,
          buttonValue: a.value,
          reusable: !0
        };
      case "say":
        return {
          type: "button",
          variant: "action",
          text: a.label,
          buttonValue: a.value,
          reusable: !0
        };
      default:
        throw new Error(`Unknown action type ${a.action}`);
    }
  }), o = [];
  return r && o.push({
    type: "image",
    url: r
  }), t && o.push({
    type: "text",
    text: `#### ${t}`
  }), n && o.push({
    type: "text",
    text: n
  }), i.length > 0 && o.push({
    type: "row",
    blocks: i
  }), {
    type: "column",
    horizontalAlignment: "center",
    blocks: [...o]
  };
}, Tr = di()(
  ys(
    (e) => ({
      messages: [],
      isFetching: !1,
      setMessages: (t) => e({ messages: t }),
      saveMessage: (t) => e(({ messages: n }) => {
        var i;
        const r = (i = t.metadata) == null ? void 0 : i.clientMessageId;
        if (r) {
          const o = n.findIndex((a) => {
            var s;
            return ((s = a.metadata) == null ? void 0 : s.clientMessageId) === r;
          });
          if (o !== -1)
            return {
              messages: [...n.slice(0, o), t, ...n.slice(o + 1)]
            };
        }
        return { messages: [...n.filter((o) => o.id !== t.id), t] };
      }),
      updateMessage: (t, n) => e(({ messages: r }) => ({
        messages: r.map((i) => i.id === t ? { ...i, ...n } : i)
      })),
      clearMessages: () => e({ messages: [] }),
      fetchMessages: async ({ client: t, conversationId: n }) => {
        const r = [];
        e({ isFetching: !0 });
        let i;
        do {
          const { messages: o, meta: a } = await t.listConversationMessages({ conversationId: n, nextToken: i });
          r.push(...o), i = a.nextToken;
        } while (i);
        return e({ isFetching: !1 }), r.reverse().map((o) => fc(o)).filter(Boolean);
      }
    }),
    { name: "messagesStore" }
  )
), MP = (e, t) => di()(
  ys(
    nx(
      (n) => ({
        setUser: (r) => n((i) => ({
          ...i,
          user: r
        })),
        setConversationId: (r) => n((i) => ({
          ...i,
          conversationId: r
        })),
        clearAll: () => {
          n((r) => ({
            ...r,
            messageHistory: {},
            user: void 0,
            conversationId: void 0
          }));
        }
      }),
      {
        name: e,
        // Dynamically set the store name
        storage: tx(() => t === "sessionStorage" ? sessionStorage : localStorage)
      }
    )
  )
), Hr = class Hr {
  constructor() {
  }
  static getInstance(t = "bp-webchat", n) {
    return Hr._instances[t] || (Hr._instances[t] = MP(t, n)), Hr._instances[t];
  }
};
al(Hr, "_instances", {});
let dc = Hr;
const jP = dc.getInstance, _f = di()(
  ys(
    (e) => ({
      eventEmitter: LE,
      messageContainerRef: { current: null },
      setMessageContainerRef: (t) => e({ messageContainerRef: t })
    }),
    { name: "webchatStore" }
  )
), NP = 8, Fi = di()((e, t) => ({
  files: [],
  setFiles: (n) => e({ files: n }),
  upsertFile: (n) => e(({ files: r }) => ({ files: r.some((a) => a.name === n.name) ? r.map((a) => a.name === n.name ? { ...a, ...n } : a) : [...r, { ...n }] })),
  uploadFile: async (n, r) => {
    const i = t().files.some((a) => a.name === n.name), o = t().files.length === NP;
    if (!(!i && o)) {
      t().upsertFile({
        name: n.name,
        type: "file",
        instance: n,
        status: "loading"
      });
      try {
        const { fileUrl: a, type: s } = await r(n);
        t().upsertFile({
          name: n.name,
          type: s,
          url: a,
          instance: n,
          status: "uploaded"
        });
      } catch (a) {
        console.error("Error sending file:", a), t().upsertFile({
          name: n.name,
          type: "file",
          instance: n,
          status: "error"
        });
      }
    }
  },
  deleteFile: (n) => e(({ files: r }) => ({ files: r.filter((i) => i.name != n) }))
})), LP = ({ text: e, buttonValue: t, variant: n, groupId: r, reusable: i, sendMessage: o, isReadOnly: a, ...s }) => {
  const l = _f((x) => x.eventEmitter), [u, c] = ge(!1), [f, p] = ge(!1), [d, v] = ge(!1), {
    message: {
      blocks: { button: h }
    }
  } = Te;
  ft(() => {
    if (r)
      return l.on(`button-group-${r}-click`, () => {
        p(!0), i || v(!0);
      });
  }, [l, r, i]);
  const m = {
    ...s,
    onClick: (x) => {
      if ((d || a) && n === "link") {
        x.preventDefault();
        return;
      }
      c(!0), i || v(!0), r && l.emit(`button-group-${r}-click`), n !== "link" && o && (o == null || o({ type: "text", text: e, value: t }));
    },
    "data-activated": u ? "" : void 0,
    "data-group-activated": f ? "" : void 0,
    "data-type": n,
    ...h
  }, b = d || a;
  return n === "link" ? /* @__PURE__ */ $.jsx(
    "a",
    {
      ...m,
      style: a ? { pointerEvents: "none" } : void 0,
      href: t,
      target: "_blank",
      rel: "noopener noreferrer",
      children: e
    }
  ) : /* @__PURE__ */ $.jsx("button", { ...m, style: a ? { pointerEvents: "none" } : void 0, disabled: b, children: e });
}, dx = Iy(null);
function FP() {
  const e = li(dx);
  if (!e)
    throw new Error("useMessageContext must be used within a Message");
  return e;
}
const px = Iy({
  open: void 0,
  showModal: void 0,
  hideModal: void 0
});
function Mf() {
  return li(px);
}
const hx = Ot(
  ({
    block: e,
    direction: t,
    sender: n,
    timestamp: r,
    messageId: i,
    feedback: o,
    metadata: a,
    isReadOnly: s,
    sendMessage: l,
    addMessageFeedback: u,
    ...c
  }, f) => {
    const [p, d] = ge(""), { showModal: v, hideModal: h } = Mf(), {
      message: {
        blocks: {
          bubble: { container: g, feedbackContainer: m, feedbackIcon: b }
        }
      }
    } = Te;
    return t == "incoming" ? /* @__PURE__ */ $.jsxs("div", { "data-direction": "incoming", "data-feedback": !!o, ...c, ...g, ref: f, children: [
      /* @__PURE__ */ $.jsx(
        ri,
        {
          block: {
            ...e,
            direction: t,
            timestamp: r,
            sender: n,
            messageId: i,
            isReadOnly: s,
            metadata: a,
            sendMessage: l,
            addMessageFeedback: u
          }
        }
      ),
      u && v && h && /* @__PURE__ */ $.jsxs("div", { ...m, children: [
        /* @__PURE__ */ $.jsx(
          oP,
          {
            ...b,
            "data-selected": o === "positive",
            onClick: () => {
              u(i, { value: "positive" });
            }
          }
        ),
        /* @__PURE__ */ $.jsx(
          iP,
          {
            ...b,
            "data-selected": o === "negative",
            onClick: () => v({
              title: "Help us improve",
              description: "Please provide feedback to help us improve.",
              confirmButton: "Send feedback",
              cancelButton: "Cancel",
              onConfirm: () => {
                u(i, { value: "negative", comment: p }), h();
              },
              content: /* @__PURE__ */ $.jsx(BP, { setFeedbackComment: d })
            })
          }
        )
      ] })
    ] }) : /* @__PURE__ */ $.jsx("div", { "data-direction": "outgoing", ...c, ...g, ref: f, children: /* @__PURE__ */ $.jsx(
      ri,
      {
        block: {
          ...e,
          direction: t,
          timestamp: r,
          sender: n,
          messageId: i,
          isReadOnly: s,
          metadata: a,
          sendMessage: l,
          addMessageFeedback: u
        }
      }
    ) });
  }
);
hx.displayName = "Bubble";
const BP = ({ setFeedbackComment: e }) => {
  const {
    modal: {
      dialog: { content: t }
    }
  } = Te;
  return /* @__PURE__ */ $.jsx(
    "textarea",
    {
      ...t.textarea,
      placeholder: "Let us know what went wrong...",
      onChange: (n) => e(n.target.value)
    }
  );
};
var Jt = function() {
  return Jt = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, Jt.apply(this, arguments);
};
function vx(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
function pi(e, t, n, r) {
  function i(o) {
    return o instanceof n ? o : new n(function(a) {
      a(o);
    });
  }
  return new (n || (n = Promise))(function(o, a) {
    function s(c) {
      try {
        u(r.next(c));
      } catch (f) {
        a(f);
      }
    }
    function l(c) {
      try {
        u(r.throw(c));
      } catch (f) {
        a(f);
      }
    }
    function u(c) {
      c.done ? o(c.value) : i(c.value).then(s, l);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function hi(e, t) {
  var n = { label: 0, sent: function() {
    if (o[0] & 1) throw o[1];
    return o[1];
  }, trys: [], ops: [] }, r, i, o, a = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return a.next = s(0), a.throw = s(1), a.return = s(2), typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function s(u) {
    return function(c) {
      return l([u, c]);
    };
  }
  function l(u) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; a && (a = 0, u[0] && (n = 0)), n; ) try {
      if (r = 1, i && (o = u[0] & 2 ? i.return : u[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, u[1])).done) return o;
      switch (i = 0, o && (u = [u[0] & 2, o.value]), u[0]) {
        case 0:
        case 1:
          o = u;
          break;
        case 4:
          return n.label++, { value: u[1], done: !1 };
        case 5:
          n.label++, i = u[1], u = [0];
          continue;
        case 7:
          u = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (o = n.trys, !(o = o.length > 0 && o[o.length - 1]) && (u[0] === 6 || u[0] === 2)) {
            n = 0;
            continue;
          }
          if (u[0] === 3 && (!o || u[1] > o[0] && u[1] < o[3])) {
            n.label = u[1];
            break;
          }
          if (u[0] === 6 && n.label < o[1]) {
            n.label = o[1], o = u;
            break;
          }
          if (o && n.label < o[2]) {
            n.label = o[2], n.ops.push(u);
            break;
          }
          o[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      u = t.call(e, n);
    } catch (c) {
      u = [6, c], i = 0;
    } finally {
      r = o = 0;
    }
    if (u[0] & 5) throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function Ah(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n) return e;
  var r = n.call(e), i, o = [], a;
  try {
    for (; (t === void 0 || t-- > 0) && !(i = r.next()).done; ) o.push(i.value);
  } catch (s) {
    a = { error: s };
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r);
    } finally {
      if (a) throw a.error;
    }
  }
  return o;
}
function pc(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, i = t.length, o; r < i; r++)
    (o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)), o[r] = t[r]);
  return e.concat(o || Array.prototype.slice.call(t));
}
function zP() {
  var e = Ve(!1), t = Oe(function() {
    return e.current;
  }, []);
  return ft(function() {
    return e.current = !0, function() {
      e.current = !1;
    };
  }, []), t;
}
function WP(e, t, n) {
  t === void 0 && (t = []), n === void 0 && (n = { loading: !1 });
  var r = Ve(0), i = zP(), o = ge(n), a = o[0], s = o[1], l = Oe(function() {
    for (var u = [], c = 0; c < arguments.length; c++)
      u[c] = arguments[c];
    var f = ++r.current;
    return a.loading || s(function(p) {
      return Jt(Jt({}, p), { loading: !0 });
    }), e.apply(void 0, u).then(function(p) {
      return i() && f === r.current && s({ value: p, loading: !1 }), p;
    }, function(p) {
      return i() && f === r.current && s({ error: p, loading: !1 }), p;
    });
  }, t);
  return [a, l];
}
function UP(e, t) {
  t === void 0 && (t = []);
  var n = WP(e, t, {
    loading: !0
  }), r = n[0], i = n[1];
  return ft(function() {
    i();
  }, [i]), r;
}
const mx = Ot(({ url: e, type: t, orientation: n = "auto", ...r }, i) => {
  const o = nE(), { setIsLoading: a } = FP(), [s, l] = ge(n), [u, c] = ge(!1), {
    message: {
      blocks: { image: f }
    }
  } = Te;
  return ui(() => {
    a((p) => [...p, o]);
  }, []), UP(async () => {
    if (e) {
      try {
        const { width: p, height: d } = await nk(e);
        s === "auto" && l(HP(p, d));
      } catch (p) {
        l("square"), console.error(p);
      }
      a((p) => p.filter((d) => d !== o));
    }
  }, [e]), /* @__PURE__ */ $.jsxs($.Fragment, { children: [
    u ? null : /* @__PURE__ */ $.jsx("div", { "data-orientation": s, ...f.placeholder }),
    /* @__PURE__ */ $.jsx(
      "img",
      {
        "data-orientation": s,
        "data-loaded": u,
        ...r,
        ...f.image,
        src: e,
        alt: "",
        ref: i,
        loading: "lazy",
        onLoad: () => {
          c(!0);
        }
      }
    )
  ] });
});
mx.displayName = "Image";
function HP(e, t) {
  const n = {
    square: 1,
    portrait: 0.75,
    landscape: 1.3333333333333333
  }, r = e / t;
  return Object.keys(n).reduce((o, a) => Math.abs(n[a] - r) < Math.abs(n[o] - r) ? a : o);
}
const gx = Ot(({ url: e, isReadOnly: t, ...n }, r) => {
  const {
    message: {
      blocks: { video: i }
    }
  } = Te;
  return /* @__PURE__ */ $.jsx("div", { children: /* @__PURE__ */ $.jsx(
    "video",
    {
      ...n,
      "data-chromatic": "ignore",
      style: t ? { pointerEvents: "none" } : void 0,
      controls: !0,
      src: e,
      ...i,
      ref: r
    }
  ) });
});
gx.displayName = "Video";
const yx = Ot(({ url: e, isReadOnly: t, ...n }, r) => {
  const {
    message: {
      blocks: { audio: i }
    }
  } = Te;
  return /* @__PURE__ */ $.jsx("div", { children: /* @__PURE__ */ $.jsx(
    "audio",
    {
      ...n,
      controls: !0,
      style: t ? { pointerEvents: "none" } : void 0,
      src: e,
      ...i,
      ref: r
    }
  ) });
});
yx.displayName = "Audio";
const bx = Ot(
  ({ latitude: e, longitude: t, title: n, isReadOnly: r, ...i }, o) => {
    const a = `https://www.google.com/maps/search/?api=1&query=${e},${t}`, {
      message: {
        blocks: { location: s }
      }
    } = Te;
    return /* @__PURE__ */ $.jsxs(
      "a",
      {
        ...i,
        ...s.container,
        style: r ? { pointerEvents: "none" } : void 0,
        href: a,
        type: "_blank",
        rel: "noopener",
        ref: o,
        children: [
          /* @__PURE__ */ $.jsx("p", { ...s.title, children: n }),
          /* @__PURE__ */ $.jsx(QR, { ...s.icon })
        ]
      }
    );
  }
);
bx.displayName = "Location";
const xx = Ot(
  ({
    blocks: e,
    horizontalAlignment: t,
    verticalAlignment: n,
    direction: r,
    sender: i,
    timestamp: o,
    messageId: a,
    isReadOnly: s,
    sendMessage: l,
    ...u
  }, c) => {
    const {
      message: {
        blocks: { column: f }
      }
    } = Te;
    return /* @__PURE__ */ $.jsx("div", { "data-horizontal": t, "data-vertical": n, ...u, ...f, ref: c, children: e.map((p, d) => /* @__PURE__ */ $.jsx(
      ri,
      {
        block: {
          ...p,
          direction: r,
          timestamp: o,
          sender: i,
          messageId: a,
          isReadOnly: s,
          sendMessage: l
        }
      },
      d
    )) });
  }
);
xx.displayName = "Column";
const wx = Ot(
  ({
    blocks: e,
    horizontalAlignment: t,
    verticalAlignment: n,
    direction: r,
    sender: i,
    timestamp: o,
    metadata: a,
    messageId: s,
    isReadOnly: l,
    sendMessage: u,
    ...c
  }, f) => {
    const {
      message: {
        blocks: { row: p }
      }
    } = Te;
    return /* @__PURE__ */ $.jsx("div", { "data-horizontal": t, "data-vertical": n, ...c, ...p, ref: f, children: e.map((d, v) => /* @__PURE__ */ $.jsx(ri, { block: { ...d, direction: r, timestamp: o, sender: i, messageId: s, isReadOnly: l, sendMessage: u } }, v)) });
  }
);
wx.displayName = "Row";
function VP(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Dh(e) {
  return VP(e) || Array.isArray(e);
}
function KP() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function jf(e, t) {
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length) return !1;
  const i = JSON.stringify(Object.keys(e.breakpoints || {})), o = JSON.stringify(Object.keys(t.breakpoints || {}));
  return i !== o ? !1 : n.every((a) => {
    const s = e[a], l = t[a];
    return typeof s == "function" ? `${s}` == `${l}` : !Dh(s) || !Dh(l) ? s === l : jf(s, l);
  });
}
function _h(e) {
  return e.concat().sort((t, n) => t.name > n.name ? 1 : -1).map((t) => t.options);
}
function qP(e, t) {
  if (e.length !== t.length) return !1;
  const n = _h(e), r = _h(t);
  return n.every((i, o) => {
    const a = r[o];
    return jf(i, a);
  });
}
function Nf(e) {
  return typeof e == "number";
}
function Mh(e) {
  return typeof e == "string";
}
function Lf(e) {
  return typeof e == "boolean";
}
function jh(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function et(e) {
  return Math.abs(e);
}
function Ff(e) {
  return Math.sign(e);
}
function wa(e, t) {
  return et(e - t);
}
function GP(e, t) {
  if (e === 0 || t === 0 || et(e) <= et(t)) return 0;
  const n = wa(et(e), et(t));
  return et(n / e);
}
function Zi(e) {
  return za(e).map(Number);
}
function Dn(e) {
  return e[bs(e)];
}
function bs(e) {
  return Math.max(0, e.length - 1);
}
function za(e) {
  return Object.keys(e);
}
function Sx(e, t) {
  return [e, t].reduce((n, r) => (za(r).forEach((i) => {
    const o = n[i], a = r[i], s = jh(o) && jh(a);
    n[i] = s ? Sx(o, a) : a;
  }), n), {});
}
function Ex(e, t) {
  return typeof t.MouseEvent < "u" && e instanceof t.MouseEvent;
}
function YP(e, t) {
  const n = {
    start: r,
    center: i,
    end: o
  };
  function r() {
    return 0;
  }
  function i(u) {
    return o(u) / 2;
  }
  function o(u) {
    return t - u;
  }
  function a() {
    return t * Number(e);
  }
  function s(u) {
    return Nf(e) ? a() : n[e](u);
  }
  return {
    measure: s
  };
}
function XP(e, t) {
  const n = e === "y" ? "y" : "x", r = e === "y" ? "x" : "y", i = s(), o = l();
  function a(c) {
    const {
      width: f,
      height: p
    } = c;
    return n === "x" ? f : p;
  }
  function s() {
    return n === "y" ? "top" : t === "rtl" ? "right" : "left";
  }
  function l() {
    return n === "y" ? "bottom" : t === "rtl" ? "left" : "right";
  }
  return {
    scroll: n,
    cross: r,
    startEdge: i,
    endEdge: o,
    measureSize: a
  };
}
function Qn(e, t) {
  const n = et(e - t);
  function r(u) {
    return u < e;
  }
  function i(u) {
    return u > t;
  }
  function o(u) {
    return r(u) || i(u);
  }
  function a(u) {
    return o(u) ? r(u) ? e : t : u;
  }
  function s(u) {
    return n ? u - n * Math.ceil((u - t) / n) : u;
  }
  return {
    length: n,
    max: t,
    min: e,
    constrain: a,
    reachedAny: o,
    reachedMax: i,
    reachedMin: r,
    removeOffset: s
  };
}
function kx(e, t, n) {
  const {
    constrain: r
  } = Qn(0, e), i = e + 1;
  let o = a(t);
  function a(p) {
    return n ? et((i + p) % i) : r(p);
  }
  function s() {
    return o;
  }
  function l(p) {
    return o = a(p), f;
  }
  function u(p) {
    return c().set(s() + p);
  }
  function c() {
    return kx(e, s(), n);
  }
  const f = {
    get: s,
    set: l,
    add: u,
    clone: c
  };
  return f;
}
function JP(e) {
  const t = e === "rtl" ? -1 : 1;
  function n(i) {
    return i * t;
  }
  return {
    apply: n
  };
}
function Qi() {
  let e = [];
  function t(i, o, a, s = {
    passive: !0
  }) {
    return i.addEventListener(o, a, s), e.push(() => i.removeEventListener(o, a, s)), r;
  }
  function n() {
    e = e.filter((i) => i());
  }
  const r = {
    add: t,
    clear: n
  };
  return r;
}
function ZP(e, t, n, r, i, o, a, s, l, u, c, f, p, d, v, h, g, m, b) {
  const {
    cross: x
  } = e, C = ["INPUT", "SELECT", "TEXTAREA"], S = {
    passive: !1
  }, E = Qi(), T = Qi(), N = Qn(50, 225).constrain(v.measure(20)), j = {
    mouse: 300,
    touch: 400
  }, O = {
    mouse: 500,
    touch: 600
  }, _ = h ? 43 : 25;
  let V = !1, L = 0, I = 0, A = !1, M = !1, q = !1, W = !1;
  function P(J, H) {
    if (!H) return;
    function re(fe) {
      (Lf(H) || H(J, fe)) && Y(fe);
    }
    const se = n;
    E.add(se, "dragstart", (fe) => fe.preventDefault(), S).add(se, "touchmove", () => {
    }, S).add(se, "touchend", () => {
    }).add(se, "touchstart", re).add(se, "mousedown", re).add(se, "touchcancel", G).add(se, "contextmenu", G).add(se, "click", Z, !0);
  }
  function y() {
    E.clear(), T.clear();
  }
  function D() {
    const J = W ? r : n;
    T.add(J, "touchmove", K, S).add(J, "touchend", G).add(J, "mousemove", K, S).add(J, "mouseup", G);
  }
  function B(J) {
    const H = J.nodeName || "";
    return C.includes(H);
  }
  function w() {
    return (h ? O : j)[W ? "mouse" : "touch"];
  }
  function U(J, H) {
    const re = p.add(Ff(J) * -1), se = f.byDistance(J, !h).distance;
    return h || et(J) < N ? se : m && H ? se * 0.5 : f.byIndex(re.get(), 0).distance;
  }
  function Y(J) {
    const H = Ex(J, i);
    W = H, !(H && J.button !== 0) && (B(J.target) || (q = h && H && !J.buttons && V, V = wa(o.get(), s.get()) >= 2, A = !0, a.pointerDown(J), c.useFriction(0).useDuration(0), o.set(s), D(), L = a.readPoint(J), I = a.readPoint(J, x), d.emit("pointerDown")));
  }
  function K(J) {
    const H = a.readPoint(J), re = a.readPoint(J, x), se = wa(H, L), fe = wa(re, I);
    if (!M && !W && (!J.cancelable || (M = se > fe, !M)))
      return G(J);
    const oe = a.pointerMove(J);
    se > g && (q = !0), c.useFriction(0.3).useDuration(1), l.start(), o.add(t.apply(oe)), J.preventDefault();
  }
  function G(J) {
    const re = f.byDistance(0, !1).index !== p.get(), se = a.pointerUp(J) * w(), fe = U(t.apply(se), re), oe = GP(se, fe), me = _ - 10 * oe, we = b + oe / 50;
    M = !1, A = !1, T.clear(), c.useDuration(me).useFriction(we), u.distance(fe, !h), W = !1, d.emit("pointerUp");
  }
  function Z(J) {
    q && (J.stopPropagation(), J.preventDefault());
  }
  function Q() {
    return A;
  }
  return {
    init: P,
    pointerDown: Q,
    destroy: y
  };
}
function QP(e, t) {
  let r, i;
  function o(f) {
    return f.timeStamp;
  }
  function a(f, p) {
    const v = `client${(p || e.scroll) === "x" ? "X" : "Y"}`;
    return (Ex(f, t) ? f : f.touches[0])[v];
  }
  function s(f) {
    return r = f, i = f, a(f);
  }
  function l(f) {
    const p = a(f) - a(i), d = o(f) - o(r) > 170;
    return i = f, d && (r = f), p;
  }
  function u(f) {
    if (!r || !i) return 0;
    const p = a(i) - a(r), d = o(f) - o(r), v = o(f) - o(i) > 170, h = p / d;
    return d && !v && et(h) > 0.1 ? h : 0;
  }
  return {
    pointerDown: s,
    pointerMove: l,
    pointerUp: u,
    readPoint: a
  };
}
function eA(e) {
  function t(r) {
    return e * (r / 100);
  }
  return {
    measure: t
  };
}
function tA(e, t, n, r, i) {
  let o, a, s = [], l = !1;
  function u(d) {
    return i.measureSize(d.getBoundingClientRect());
  }
  function c(d, v) {
    if (!v) return;
    a = u(e), s = r.map(u);
    function h(m) {
      for (const b of m) {
        const x = b.target === e, C = r.indexOf(b.target), S = x ? a : s[C], E = u(x ? e : r[C]);
        if (S !== E) {
          n.requestAnimationFrame(() => {
            d.reInit(), t.emit("resize");
          });
          break;
        }
      }
    }
    o = new ResizeObserver((m) => {
      l || (Lf(v) || v(d, m)) && h(m);
    }), [e].concat(r).forEach((m) => o.observe(m));
  }
  function f() {
    o && o.disconnect(), l = !0;
  }
  return {
    init: c,
    destroy: f
  };
}
function nA(e, t, n, r) {
  let i = !0, o = 0, a = 0, s = n, l = r, u = e.get(), c = 0;
  function f() {
    const S = t.get() - e.get(), E = !s;
    let T = 0;
    return E ? (o = 0, e.set(t), T = S) : (o += S / s, o *= l, u += o, e.add(o), T = u - c), a = Ff(T), c = u, i = et(S) < 1e-3, C;
  }
  function p() {
    return i;
  }
  function d() {
    return s;
  }
  function v() {
    return a;
  }
  function h() {
    return o;
  }
  function g() {
    return b(n);
  }
  function m() {
    return x(r);
  }
  function b(S) {
    return s = S, C;
  }
  function x(S) {
    return l = S, C;
  }
  const C = {
    direction: v,
    duration: d,
    velocity: h,
    seek: f,
    settled: p,
    useBaseFriction: m,
    useBaseDuration: g,
    useFriction: x,
    useDuration: b
  };
  return C;
}
function rA(e, t, n, r, i) {
  const o = i.measure(10), a = i.measure(50), s = Qn(0.1, 0.99);
  let l = !1;
  function u() {
    return !(l || !e.reachedAny(n.get()) || !e.reachedAny(t.get()));
  }
  function c(d) {
    if (!u()) return;
    const v = e.reachedMin(t.get()) ? "min" : "max", h = et(e[v] - t.get()), g = n.get() - t.get(), m = s.constrain(h / a);
    n.subtract(g * m), !d && et(g) < o && (n.set(e.constrain(n.get())), r.useDuration(25).useBaseFriction());
  }
  function f(d) {
    l = !d;
  }
  return {
    constrain: c,
    toggleActive: f
  };
}
function iA(e, t, n, r) {
  const i = Qn(-t + e, n[0]), o = l(), a = u();
  function s() {
    const f = o[0], p = Dn(o), d = o.lastIndexOf(f), v = o.indexOf(p) + 1;
    return Qn(d, v);
  }
  function l() {
    return n.map(i.constrain).map((f) => parseFloat(f.toFixed(3)));
  }
  function u() {
    if (t <= e) return [i.max];
    if (r === "keepSnaps") return o;
    const {
      min: f,
      max: p
    } = s();
    return o.slice(f, p);
  }
  return {
    snapsContained: a
  };
}
function oA(e, t, n) {
  const r = t[0], i = n ? r - e : Dn(t);
  return {
    limit: Qn(i, r)
  };
}
function aA(e, t, n, r) {
  const o = t.min + 0.1, a = t.max + 0.1, {
    reachedMin: s,
    reachedMax: l
  } = Qn(o, a);
  function u(p) {
    return p === 1 ? l(n.get()) : p === -1 ? s(n.get()) : !1;
  }
  function c(p) {
    if (!u(p)) return;
    const d = e * (p * -1);
    r.forEach((v) => v.add(d));
  }
  return {
    loop: c
  };
}
function sA(e) {
  const {
    max: t,
    length: n
  } = e;
  function r(o) {
    return (o - t) / -n;
  }
  return {
    get: r
  };
}
function lA(e, t, n, r, i, o, a) {
  const {
    startEdge: s,
    endEdge: l
  } = e, {
    groupSlides: u
  } = o, c = d().map(t.measure), f = v(), p = h();
  function d() {
    return u(r).map((m) => Dn(m)[l] - m[0][s]).map(et);
  }
  function v() {
    return r.map((m) => n[s] - m[s]).map((m) => -et(m));
  }
  function h() {
    const b = Dn(f) - Dn(i);
    return u(f).map((x) => x[0]).map((x, C, S) => {
      const E = !C, T = C === bs(S);
      return a && E ? 0 : a && T ? b : x + c[C];
    });
  }
  return {
    snaps: f,
    snapsAligned: p
  };
}
function uA(e, t, n, r, i) {
  const {
    reachedAny: o,
    removeOffset: a,
    constrain: s
  } = r;
  function l(v) {
    return v.concat().sort((h, g) => et(h) - et(g))[0];
  }
  function u(v) {
    const h = e ? a(v) : s(v), g = t.map((b) => b - h).map((b) => c(b, 0)).map((b, x) => ({
      diff: b,
      index: x
    })).sort((b, x) => et(b.diff) - et(x.diff)), {
      index: m
    } = g[0];
    return {
      index: m,
      distance: h
    };
  }
  function c(v, h) {
    const g = [v, v + n, v - n];
    if (!e) return g[0];
    if (!h) return l(g);
    const m = g.filter((b) => Ff(b) === h);
    return l(m);
  }
  function f(v, h) {
    const g = t[v] - i.get(), m = c(g, h);
    return {
      index: v,
      distance: m
    };
  }
  function p(v, h) {
    const g = i.get() + v, {
      index: m,
      distance: b
    } = u(g), x = !e && o(g);
    if (!h || x) return {
      index: m,
      distance: v
    };
    const C = t[m] - b, S = v + c(C, 0);
    return {
      index: m,
      distance: S
    };
  }
  return {
    byDistance: p,
    byIndex: f,
    shortcut: c
  };
}
function cA(e, t, n, r, i, o, a) {
  function s(f) {
    const p = f.distance, d = f.index !== t.get();
    o.add(p), p && (i.duration() ? e.start() : (e.update(), e.render(1), e.update())), d && (n.set(t.get()), t.set(f.index), a.emit("select"));
  }
  function l(f, p) {
    const d = r.byDistance(f, p);
    s(d);
  }
  function u(f, p) {
    const d = t.clone().set(f), v = r.byIndex(d.get(), p);
    s(v);
  }
  return {
    distance: l,
    index: u
  };
}
function Sa(e) {
  let t = e;
  function n() {
    return t;
  }
  function r(l) {
    t = a(l);
  }
  function i(l) {
    t += a(l);
  }
  function o(l) {
    t -= a(l);
  }
  function a(l) {
    return Nf(l) ? l : l.get();
  }
  return {
    get: n,
    set: r,
    add: i,
    subtract: o
  };
}
function Cx(e, t, n) {
  const r = e.scroll === "x" ? a : s, i = n.style;
  let o = !1;
  function a(p) {
    return `translate3d(${p}px,0px,0px)`;
  }
  function s(p) {
    return `translate3d(0px,${p}px,0px)`;
  }
  function l(p) {
    o || (i.transform = r(t.apply(p)));
  }
  function u(p) {
    o = !p;
  }
  function c() {
    o || (i.transform = "", n.getAttribute("style") || n.removeAttribute("style"));
  }
  return {
    clear: c,
    to: l,
    toggleActive: u
  };
}
function fA(e, t, n, r, i, o, a, s, l) {
  const u = Zi(i), c = Zi(i).reverse(), f = h().concat(g());
  function p(S, E) {
    return S.reduce((T, N) => T - i[N], E);
  }
  function d(S, E) {
    return S.reduce((T, N) => p(T, E) > 0 ? T.concat([N]) : T, []);
  }
  function v(S, E) {
    const T = E === "start", N = T ? -r : r, j = a.findSlideBounds([N]);
    return S.map((O) => {
      const _ = T ? 0 : -r, V = T ? r : 0, I = j.filter((A) => A.index === O)[0][T ? "end" : "start"];
      return {
        index: O,
        slideLocation: Sa(-1),
        translate: Cx(e, t, l[O]),
        target: () => s.get() > I ? _ : V
      };
    });
  }
  function h() {
    const S = o[0] - 1, E = d(c, S);
    return v(E, "end");
  }
  function g() {
    const S = n - o[0] - 1, E = d(u, S);
    return v(E, "start");
  }
  function m() {
    return f.every(({
      index: S
    }) => {
      const E = u.filter((T) => T !== S);
      return p(E, n) <= 0.1;
    });
  }
  function b() {
    f.forEach((S) => {
      const {
        target: E,
        translate: T,
        slideLocation: N
      } = S, j = E();
      j !== N.get() && (T.to(j), N.set(j));
    });
  }
  function x() {
    f.forEach((S) => S.translate.clear());
  }
  return {
    canLoop: m,
    clear: x,
    loop: b,
    loopPoints: f
  };
}
function dA(e, t) {
  let n, r = !1;
  function i(s, l) {
    if (!l) return;
    function u(c) {
      for (const f of c)
        if (f.type === "childList") {
          s.reInit(), t.emit("slidesChanged");
          break;
        }
    }
    n = new MutationObserver((c) => {
      r || (Lf(l) || l(s, c)) && u(c);
    }), n.observe(e, {
      childList: !0
    });
  }
  function o() {
    n && n.disconnect(), r = !0;
  }
  return {
    init: i,
    destroy: o
  };
}
function pA(e, t, n, r, i, o, a) {
  const {
    removeOffset: s,
    constrain: l
  } = i, u = 0.5, c = o ? [0, t, -t] : [0], f = d(c, a);
  function p(g) {
    const m = g || 0;
    return n.map((b) => Qn(u, b - u).constrain(b * m));
  }
  function d(g, m) {
    const b = g || c, x = p(m);
    return b.reduce((C, S) => {
      const E = r.map((T, N) => ({
        start: T - n[N] + x[N] + S,
        end: T + e - x[N] + S,
        index: N
      }));
      return C.concat(E);
    }, []);
  }
  function v(g, m) {
    const b = o ? s(g) : l(g);
    return (m || f).reduce((C, S) => {
      const {
        index: E,
        start: T,
        end: N
      } = S, j = C.includes(E), O = T < b && N > b;
      return !j && O ? C.concat([E]) : C;
    }, []);
  }
  return {
    check: v,
    findSlideBounds: d
  };
}
function hA(e, t, n, r, i, o) {
  const {
    measureSize: a,
    startEdge: s,
    endEdge: l
  } = e, u = n[0] && i, c = v(), f = h(), p = n.map(a), d = g();
  function v() {
    if (!u) return 0;
    const b = n[0];
    return et(t[s] - b[s]);
  }
  function h() {
    if (!u) return 0;
    const b = o.getComputedStyle(Dn(r));
    return parseFloat(b.getPropertyValue(`margin-${l}`));
  }
  function g() {
    return n.map((b, x, C) => {
      const S = !x, E = x === bs(C);
      return S ? p[x] + c : E ? p[x] + f : C[x + 1][s] - b[s];
    }).map(et);
  }
  return {
    slideSizes: p,
    slideSizesWithGaps: d
  };
}
function vA(e, t, n) {
  const r = Nf(n);
  function i(l, u) {
    return Zi(l).filter((c) => c % u === 0).map((c) => l.slice(c, c + u));
  }
  function o(l) {
    return Zi(l).reduce((u, c) => {
      const p = t.slice(Dn(u), c + 1).reduce((d, v) => d + v, 0);
      return !c || p > e ? u.concat(c) : u;
    }, []).map((u, c, f) => l.slice(u, f[c + 1]));
  }
  function a(l) {
    return r ? i(l, n) : o(l);
  }
  return {
    groupSlides: a
  };
}
function mA(e, t, n, r, i, o, a, s) {
  const {
    align: l,
    axis: u,
    direction: c,
    startIndex: f,
    inViewThreshold: p,
    loop: d,
    duration: v,
    dragFree: h,
    dragThreshold: g,
    slidesToScroll: m,
    skipSnaps: b,
    containScroll: x
  } = o, C = t.getBoundingClientRect(), S = n.map((we) => we.getBoundingClientRect()), E = JP(c), T = XP(u, c), N = T.measureSize(C), j = eA(N), O = YP(l, N), _ = !d && !!x, V = d || !!x, {
    slideSizes: L,
    slideSizesWithGaps: I
  } = hA(T, C, S, n, V, i), A = vA(N, I, m), {
    snaps: M,
    snapsAligned: q
  } = lA(T, O, C, S, I, A, _), W = -Dn(M) + Dn(I), {
    snapsContained: P
  } = iA(N, W, q, x), y = _ ? P : q, {
    limit: D
  } = oA(W, y, d), B = kx(bs(y), f, d), w = B.clone(), U = Zi(n), Y = ({
    dragHandler: we,
    scrollBody: Ie,
    scrollBounds: nt,
    eventHandler: St,
    animation: Et,
    options: {
      loop: kt
    }
  }) => {
    const ie = we.pointerDown();
    kt || nt.constrain(ie);
    const ue = Ie.seek().settled();
    ue && !ie && (Et.stop(), St.emit("settle")), ue || St.emit("scroll");
  }, K = ({
    scrollBody: we,
    translate: Ie,
    location: nt,
    offsetLocation: St,
    scrollLooper: Et,
    slideLooper: kt,
    options: {
      loop: ie
    }
  }, ue) => {
    const z = we.velocity();
    St.set(nt.get() - z + z * ue), ie && (Et.loop(we.direction()), kt.loop()), Ie.to(St.get());
  }, G = {
    start: () => s.start(me),
    stop: () => s.stop(me),
    update: () => Y(me),
    render: (we) => K(me, we)
  }, Z = 0.68, Q = y[B.get()], X = Sa(Q), J = Sa(Q), H = Sa(Q), re = nA(X, H, v, Z), se = uA(d, y, W, D, H), fe = cA(G, B, w, se, re, H, a), oe = pA(N, W, L, M, D, d, p), me = {
    ownerDocument: r,
    ownerWindow: i,
    eventHandler: a,
    containerRect: C,
    slideRects: S,
    animation: G,
    axis: T,
    direction: E,
    dragHandler: ZP(T, E, e, r, i, H, QP(T, i), X, G, fe, re, se, B, a, j, h, g, b, Z),
    eventStore: Qi(),
    percentOfView: j,
    index: B,
    indexPrevious: w,
    limit: D,
    location: X,
    offsetLocation: J,
    options: o,
    resizeHandler: tA(t, a, i, n, T),
    scrollBody: re,
    scrollBounds: rA(D, X, H, re, j),
    scrollLooper: aA(W, D, J, [X, J, H]),
    scrollProgress: sA(D),
    scrollSnaps: y,
    scrollTarget: se,
    scrollTo: fe,
    slideLooper: fA(T, E, N, W, I, y, oe, J, n),
    slidesHandler: dA(t, a),
    slidesInView: oe,
    slideIndexes: U,
    slidesToScroll: A,
    target: H,
    translate: Cx(T, E, t)
  };
  return me;
}
function gA(e) {
  const t = 16.666666666666668;
  let n = [], r = null, i = 0, o = 0;
  function a(f) {
    r || (r = f);
    const p = f - r;
    for (r = f, i += p; i >= t; )
      n.forEach(({
        animation: v
      }) => v.update()), i -= t;
    const d = et(i / t);
    n.forEach(({
      animation: v
    }) => v.render(d)), o && e.requestAnimationFrame(a);
  }
  function s(f) {
    n.includes(f) || n.push(f), !o && (o = e.requestAnimationFrame(a));
  }
  function l(f) {
    n = n.filter((p) => p !== f), !n.length && (e.cancelAnimationFrame(o), r = null, i = 0, o = 0);
  }
  function u() {
    r = null, i = 0;
  }
  return {
    start: s,
    stop: l,
    reset: u,
    window: e
  };
}
function yA() {
  const e = {};
  let t;
  function n(l) {
    t = l;
  }
  function r(l) {
    return e[l] || [];
  }
  function i(l) {
    return r(l).forEach((u) => u(t, l)), s;
  }
  function o(l, u) {
    return e[l] = r(l).concat([u]), s;
  }
  function a(l, u) {
    return e[l] = r(l).filter((c) => c !== u), s;
  }
  const s = {
    init: n,
    emit: i,
    off: a,
    on: o
  };
  return s;
}
const bA = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  breakpoints: {},
  dragFree: !1,
  dragThreshold: 10,
  inViewThreshold: 0,
  loop: !1,
  skipSnaps: !1,
  duration: 25,
  startIndex: 0,
  active: !0,
  watchDrag: !0,
  watchResize: !0,
  watchSlides: !0
};
function xA(e) {
  function t(o, a) {
    return Sx(o, a || {});
  }
  function n(o) {
    const a = o.breakpoints || {}, s = za(a).filter((l) => e.matchMedia(l).matches).map((l) => a[l]).reduce((l, u) => t(l, u), {});
    return t(o, s);
  }
  function r(o) {
    return o.map((a) => za(a.breakpoints || {})).reduce((a, s) => a.concat(s), []).map(e.matchMedia);
  }
  return {
    mergeOptions: t,
    optionsAtMedia: n,
    optionsMediaQueries: r
  };
}
function wA(e) {
  let t = [];
  function n(o, a) {
    return t = o.filter(({
      options: s
    }) => e.optionsAtMedia(s).active !== !1), t.forEach((s) => s.init(a, e)), o.reduce((s, l) => Object.assign(s, {
      [l.name]: l
    }), {});
  }
  function r() {
    t = t.filter((o) => o.destroy());
  }
  return {
    init: n,
    destroy: r
  };
}
function Zr(e, t, n) {
  const r = e.ownerDocument, i = r.defaultView, o = xA(i), a = wA(o), s = Qi(), l = Qi(), u = yA(), {
    animationRealms: c
  } = Zr, {
    mergeOptions: f,
    optionsAtMedia: p,
    optionsMediaQueries: d
  } = o, {
    on: v,
    off: h,
    emit: g
  } = u, m = L;
  let b = !1, x, C = f(bA, Zr.globalOptions), S = f(C), E = [], T, N, j;
  function O() {
    const {
      container: re,
      slides: se
    } = S;
    N = (Mh(re) ? e.querySelector(re) : re) || e.children[0];
    const oe = Mh(se) ? N.querySelectorAll(se) : se;
    j = [].slice.call(oe || N.children);
  }
  function _(re, se) {
    const fe = mA(e, N, j, r, i, re, u, se);
    if (re.loop && !fe.slideLooper.canLoop()) {
      const oe = Object.assign({}, re, {
        loop: !1
      });
      return _(oe, se);
    }
    return fe;
  }
  function V(re, se) {
    if (b) return;
    const fe = c.find((me) => me.window === i), oe = fe || gA(i);
    fe || c.push(oe), C = f(C, re), S = p(C), E = se || E, O(), x = _(S, oe), d([C, ...E.map(({
      options: me
    }) => me)]).forEach((me) => s.add(me, "change", L)), S.active && (x.translate.to(x.location.get()), x.eventHandler.init(H), x.resizeHandler.init(H, S.watchResize), x.slidesHandler.init(H, S.watchSlides), l.add(r, "visibilitychange", () => {
      r.hidden && oe.reset();
    }), x.options.loop && x.slideLooper.loop(), N.offsetParent && j.length && x.dragHandler.init(H, S.watchDrag), T = a.init(E, H));
  }
  function L(re, se) {
    const fe = Y();
    I(), V(f({
      startIndex: fe
    }, re), se), u.emit("reInit");
  }
  function I() {
    x.dragHandler.destroy(), x.animation.stop(), x.eventStore.clear(), x.translate.clear(), x.slideLooper.clear(), x.resizeHandler.destroy(), x.slidesHandler.destroy(), a.destroy(), s.clear(), l.clear();
  }
  function A() {
    b || (b = !0, s.clear(), I(), u.emit("destroy"));
  }
  function M(re) {
    const se = x[re ? "target" : "location"].get(), fe = S.loop ? "removeOffset" : "constrain";
    return x.slidesInView.check(x.limit[fe](se));
  }
  function q(re) {
    const se = M(re);
    return x.slideIndexes.filter((fe) => !se.includes(fe));
  }
  function W(re, se, fe) {
    !S.active || b || (x.scrollBody.useBaseFriction().useDuration(se ? 0 : S.duration), x.scrollTo.index(re, fe || 0));
  }
  function P(re) {
    const se = x.index.add(1).get();
    W(se, re === !0, -1);
  }
  function y(re) {
    const se = x.index.add(-1).get();
    W(se, re === !0, 1);
  }
  function D() {
    return x.index.add(1).get() !== Y();
  }
  function B() {
    return x.index.add(-1).get() !== Y();
  }
  function w() {
    return x.scrollSnaps.map(x.scrollProgress.get);
  }
  function U() {
    return x.scrollProgress.get(x.location.get());
  }
  function Y() {
    return x.index.get();
  }
  function K() {
    return x.indexPrevious.get();
  }
  function G() {
    return T;
  }
  function Z() {
    return x;
  }
  function Q() {
    return e;
  }
  function X() {
    return N;
  }
  function J() {
    return j;
  }
  const H = {
    canScrollNext: D,
    canScrollPrev: B,
    containerNode: X,
    internalEngine: Z,
    destroy: A,
    off: h,
    on: v,
    emit: g,
    plugins: G,
    previousScrollSnap: K,
    reInit: m,
    rootNode: Q,
    scrollNext: P,
    scrollPrev: y,
    scrollProgress: U,
    scrollSnapList: w,
    scrollTo: W,
    selectedScrollSnap: Y,
    slideNodes: J,
    slidesInView: M,
    slidesNotInView: q
  };
  return V(t, n), setTimeout(() => u.emit("init"), 0), H;
}
Zr.animationRealms = [];
Zr.globalOptions = void 0;
function Bf(e = {}, t = []) {
  const n = Ve(e), r = Ve(t), [i, o] = ge(), [a, s] = ge(), l = Oe(() => {
    i && i.reInit(n.current, r.current);
  }, [i]);
  return ft(() => {
    if (KP() && a) {
      Zr.globalOptions = Bf.globalOptions;
      const u = Zr(a, n.current, r.current);
      return o(u), () => u.destroy();
    } else
      o(void 0);
  }, [a, o]), ft(() => {
    jf(n.current, e) || (n.current = e, l());
  }, [e, l]), ft(() => {
    qP(r.current, t) || (r.current = t, l());
  }, [t, l]), [s, i];
}
Bf.globalOptions = void 0;
const $x = Ot(
  ({ blocks: e, direction: t, sender: n, timestamp: r, messageId: i, isReadOnly: o, sendMessage: a, addMessageFeedback: s }, l) => {
    const [u, c] = Bf({ skipSnaps: !0, loop: !0 }), [f, p] = ge(!0), [d, v] = ge(!0), h = Oe(() => c == null ? void 0 : c.scrollPrev(), [c]), g = Oe(() => c == null ? void 0 : c.scrollNext(), [c]), {
      message: {
        blocks: { carousel: m }
      }
    } = Te, b = Oe((x) => {
      p(!x.canScrollPrev()), v(!x.canScrollNext());
    }, []);
    return ft(() => {
      c && (b(c), c.on("reInit", b), c.on("select", b));
    }, [c, b]), /* @__PURE__ */ $.jsxs("div", { ...m == null ? void 0 : m.container, "data-container": "carousel", ref: u, children: [
      /* @__PURE__ */ $.jsx("div", { ref: l, ...m == null ? void 0 : m.slidesContainer, children: e.map((x, C) => /* @__PURE__ */ $.jsx(ri, { block: { ...x, direction: t, timestamp: r, sender: n, messageId: i, sendMessage: a, isReadOnly: o } }, C)) }),
      e.length > 1 && /* @__PURE__ */ $.jsxs($.Fragment, { children: [
        /* @__PURE__ */ $.jsx(
          WR,
          {
            ...m == null ? void 0 : m.backButton,
            "data-disabled": f ? "" : void 0,
            onClick: h
          }
        ),
        /* @__PURE__ */ $.jsx(
          UR,
          {
            ...m == null ? void 0 : m.nextButton,
            "data-disabled": d ? "" : void 0,
            onClick: g
          }
        )
      ] })
    ] });
  }
);
$x.displayName = "Carousel";
const Nh = Math.floor;
function Tx(e) {
  return Ox(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function mo(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function SA(e) {
  var t;
  return (t = (Ox(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Ox(e) {
  return e instanceof Node || e instanceof mo(e).Node;
}
function Xt(e) {
  return e instanceof Element || e instanceof mo(e).Element;
}
function Qr(e) {
  return e instanceof HTMLElement || e instanceof mo(e).HTMLElement;
}
function hc(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof mo(e).ShadowRoot;
}
function EA(e) {
  return ["html", "body", "#document"].includes(Tx(e));
}
function kA(e) {
  return mo(e).getComputedStyle(e);
}
function CA(e) {
  if (Tx(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    hc(e) && e.host || // Fallback.
    SA(e)
  );
  return hc(t) ? t.host : t;
}
function Hn(e) {
  let t = e.activeElement;
  for (; ((n = t) == null || (r = n.shadowRoot) == null ? void 0 : r.activeElement) != null; ) {
    var n, r;
    t = t.shadowRoot.activeElement;
  }
  return t;
}
function jt(e, t) {
  if (!e || !t)
    return !1;
  const n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && hc(n)) {
    let r = t;
    for (; r; ) {
      if (e === r)
        return !0;
      r = r.parentNode || r.host;
    }
  }
  return !1;
}
function Ix() {
  const e = navigator.userAgentData;
  return e != null && e.platform ? e.platform : navigator.platform;
}
function $A() {
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? e.brands.map((t) => {
    let {
      brand: n,
      version: r
    } = t;
    return n + "/" + r;
  }).join(" ") : navigator.userAgent;
}
function Rx(e) {
  if (e.mozInputSource === 0 && e.isTrusted)
    return !0;
  const t = /Android/i;
  return (t.test(Ix()) || t.test($A())) && e.pointerType ? e.type === "click" && e.buttons === 1 : e.detail === 0 && !e.pointerType;
}
function Px(e) {
  return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType !== "mouse" || // iOS VoiceOver returns 0.333• for width/height.
  e.width < 1 && e.height < 1 && e.pressure === 0 && e.detail === 0;
}
function Ax() {
  return /apple/i.test(navigator.vendor);
}
function TA() {
  return Ix().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function Lh(e, t) {
  return ["mouse", "pen"].includes(e);
}
function OA(e) {
  return "nativeEvent" in e;
}
function IA(e) {
  return e.matches("html,body");
}
function on(e) {
  return (e == null ? void 0 : e.ownerDocument) || document;
}
function Tl(e, t) {
  if (t == null)
    return !1;
  if ("composedPath" in e)
    return e.composedPath().includes(t);
  const n = e;
  return n.target != null && t.contains(n.target);
}
function Dx(e) {
  return "composedPath" in e ? e.composedPath()[0] : e.target;
}
const RA = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function _x(e) {
  return Qr(e) && e.matches(RA);
}
function bt(e) {
  e.preventDefault(), e.stopPropagation();
}
const ei = Math.min, Wt = Math.max, Wa = Math.round, Go = Math.floor, wn = (e) => ({
  x: e,
  y: e
});
function Fh(e, t, n) {
  return Wt(e, ei(t, n));
}
function xs(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function go(e) {
  return e.split("-")[0];
}
function zf(e) {
  return e.split("-")[1];
}
function Mx(e) {
  return e === "x" ? "y" : "x";
}
function PA(e) {
  return e === "y" ? "height" : "width";
}
function yo(e) {
  return ["top", "bottom"].includes(go(e)) ? "y" : "x";
}
function AA(e) {
  return Mx(yo(e));
}
function DA(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function _A(e) {
  return typeof e != "number" ? DA(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Ua(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: i
  } = e;
  return {
    width: r,
    height: i,
    top: n,
    left: t,
    right: t + r,
    bottom: n + i,
    x: t,
    y: n
  };
}
function Bh(e, t, n) {
  let {
    reference: r,
    floating: i
  } = e;
  const o = yo(t), a = AA(t), s = PA(a), l = go(t), u = o === "y", c = r.x + r.width / 2 - i.width / 2, f = r.y + r.height / 2 - i.height / 2, p = r[s] / 2 - i[s] / 2;
  let d;
  switch (l) {
    case "top":
      d = {
        x: c,
        y: r.y - i.height
      };
      break;
    case "bottom":
      d = {
        x: c,
        y: r.y + r.height
      };
      break;
    case "right":
      d = {
        x: r.x + r.width,
        y: f
      };
      break;
    case "left":
      d = {
        x: r.x - i.width,
        y: f
      };
      break;
    default:
      d = {
        x: r.x,
        y: r.y
      };
  }
  switch (zf(t)) {
    case "start":
      d[a] -= p * (n && u ? -1 : 1);
      break;
    case "end":
      d[a] += p * (n && u ? -1 : 1);
      break;
  }
  return d;
}
const MA = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: o = [],
    platform: a
  } = n, s = o.filter(Boolean), l = await (a.isRTL == null ? void 0 : a.isRTL(t));
  let u = await a.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: c,
    y: f
  } = Bh(u, r, l), p = r, d = {}, v = 0;
  for (let h = 0; h < s.length; h++) {
    const {
      name: g,
      fn: m
    } = s[h], {
      x: b,
      y: x,
      data: C,
      reset: S
    } = await m({
      x: c,
      y: f,
      initialPlacement: r,
      placement: p,
      strategy: i,
      middlewareData: d,
      rects: u,
      platform: a,
      elements: {
        reference: e,
        floating: t
      }
    });
    c = b ?? c, f = x ?? f, d = {
      ...d,
      [g]: {
        ...d[g],
        ...C
      }
    }, S && v <= 50 && (v++, typeof S == "object" && (S.placement && (p = S.placement), S.rects && (u = S.rects === !0 ? await a.getElementRects({
      reference: e,
      floating: t,
      strategy: i
    }) : S.rects), {
      x: c,
      y: f
    } = Bh(u, p, l)), h = -1);
  }
  return {
    x: c,
    y: f,
    placement: p,
    strategy: i,
    middlewareData: d
  };
};
async function jx(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: i,
    platform: o,
    rects: a,
    elements: s,
    strategy: l
  } = e, {
    boundary: u = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: f = "floating",
    altBoundary: p = !1,
    padding: d = 0
  } = xs(t, e), v = _A(d), g = s[p ? f === "floating" ? "reference" : "floating" : f], m = Ua(await o.getClippingRect({
    element: (n = await (o.isElement == null ? void 0 : o.isElement(g))) == null || n ? g : g.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(s.floating)),
    boundary: u,
    rootBoundary: c,
    strategy: l
  })), b = f === "floating" ? {
    x: r,
    y: i,
    width: a.floating.width,
    height: a.floating.height
  } : a.reference, x = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(s.floating)), C = await (o.isElement == null ? void 0 : o.isElement(x)) ? await (o.getScale == null ? void 0 : o.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, S = Ua(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: s,
    rect: b,
    offsetParent: x,
    strategy: l
  }) : b);
  return {
    top: (m.top - S.top + v.top) / C.y,
    bottom: (S.bottom - m.bottom + v.bottom) / C.y,
    left: (m.left - S.left + v.left) / C.x,
    right: (S.right - m.right + v.right) / C.x
  };
}
async function jA(e, t) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = e, o = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), a = go(n), s = zf(n), l = yo(n) === "y", u = ["left", "top"].includes(a) ? -1 : 1, c = o && l ? -1 : 1, f = xs(t, e);
  let {
    mainAxis: p,
    crossAxis: d,
    alignmentAxis: v
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return s && typeof v == "number" && (d = s === "end" ? v * -1 : v), l ? {
    x: d * c,
    y: p * u
  } : {
    x: p * u,
    y: d * c
  };
}
const NA = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: i,
        y: o,
        placement: a,
        middlewareData: s
      } = t, l = await jA(t, e);
      return a === ((n = s.offset) == null ? void 0 : n.placement) && (r = s.arrow) != null && r.alignmentOffset ? {} : {
        x: i + l.x,
        y: o + l.y,
        data: {
          ...l,
          placement: a
        }
      };
    }
  };
}, LA = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: i
      } = t, {
        mainAxis: o = !0,
        crossAxis: a = !1,
        limiter: s = {
          fn: (g) => {
            let {
              x: m,
              y: b
            } = g;
            return {
              x: m,
              y: b
            };
          }
        },
        ...l
      } = xs(e, t), u = {
        x: n,
        y: r
      }, c = await jx(t, l), f = yo(go(i)), p = Mx(f);
      let d = u[p], v = u[f];
      if (o) {
        const g = p === "y" ? "top" : "left", m = p === "y" ? "bottom" : "right", b = d + c[g], x = d - c[m];
        d = Fh(b, d, x);
      }
      if (a) {
        const g = f === "y" ? "top" : "left", m = f === "y" ? "bottom" : "right", b = v + c[g], x = v - c[m];
        v = Fh(b, v, x);
      }
      const h = s.fn({
        ...t,
        [p]: d,
        [f]: v
      });
      return {
        ...h,
        data: {
          x: h.x - n,
          y: h.y - r,
          enabled: {
            [p]: o,
            [f]: a
          }
        }
      };
    }
  };
}, FA = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        rects: o,
        platform: a,
        elements: s
      } = t, {
        apply: l = () => {
        },
        ...u
      } = xs(e, t), c = await jx(t, u), f = go(i), p = zf(i), d = yo(i) === "y", {
        width: v,
        height: h
      } = o.floating;
      let g, m;
      f === "top" || f === "bottom" ? (g = f, m = p === (await (a.isRTL == null ? void 0 : a.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (m = f, g = p === "end" ? "top" : "bottom");
      const b = h - c.top - c.bottom, x = v - c.left - c.right, C = ei(h - c[g], b), S = ei(v - c[m], x), E = !t.middlewareData.shift;
      let T = C, N = S;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (N = x), (r = t.middlewareData.shift) != null && r.enabled.y && (T = b), E && !p) {
        const O = Wt(c.left, 0), _ = Wt(c.right, 0), V = Wt(c.top, 0), L = Wt(c.bottom, 0);
        d ? N = v - 2 * (O !== 0 || _ !== 0 ? O + _ : Wt(c.left, c.right)) : T = h - 2 * (V !== 0 || L !== 0 ? V + L : Wt(c.top, c.bottom));
      }
      await l({
        ...t,
        availableWidth: N,
        availableHeight: T
      });
      const j = await a.getDimensions(s.floating);
      return v !== j.width || h !== j.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function ws() {
  return typeof window < "u";
}
function vi(e) {
  return Nx(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Ut(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Cn(e) {
  var t;
  return (t = (Nx(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Nx(e) {
  return ws() ? e instanceof Node || e instanceof Ut(e).Node : !1;
}
function un(e) {
  return ws() ? e instanceof Element || e instanceof Ut(e).Element : !1;
}
function En(e) {
  return ws() ? e instanceof HTMLElement || e instanceof Ut(e).HTMLElement : !1;
}
function zh(e) {
  return !ws() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Ut(e).ShadowRoot;
}
function bo(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: i
  } = cn(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(i);
}
function BA(e) {
  return ["table", "td", "th"].includes(vi(e));
}
function Ss(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function Wf(e) {
  const t = Uf(), n = un(e) ? cn(e) : e;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function zA(e) {
  let t = er(e);
  for (; En(t) && !ti(t); ) {
    if (Wf(t))
      return t;
    if (Ss(t))
      return null;
    t = er(t);
  }
  return null;
}
function Uf() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function ti(e) {
  return ["html", "body", "#document"].includes(vi(e));
}
function cn(e) {
  return Ut(e).getComputedStyle(e);
}
function Es(e) {
  return un(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function er(e) {
  if (vi(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    zh(e) && e.host || // Fallback.
    Cn(e)
  );
  return zh(t) ? t.host : t;
}
function Lx(e) {
  const t = er(e);
  return ti(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : En(t) && bo(t) ? t : Lx(t);
}
function qn(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = Lx(e), o = i === ((r = e.ownerDocument) == null ? void 0 : r.body), a = Ut(i);
  if (o) {
    const s = vc(a);
    return t.concat(a, a.visualViewport || [], bo(i) ? i : [], s && n ? qn(s) : []);
  }
  return t.concat(i, qn(i, [], n));
}
function vc(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function Fx(e) {
  const t = cn(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = En(e), o = i ? e.offsetWidth : n, a = i ? e.offsetHeight : r, s = Wa(n) !== o || Wa(r) !== a;
  return s && (n = o, r = a), {
    width: n,
    height: r,
    $: s
  };
}
function Hf(e) {
  return un(e) ? e : e.contextElement;
}
function Kr(e) {
  const t = Hf(e);
  if (!En(t))
    return wn(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: o
  } = Fx(t);
  let a = (o ? Wa(n.width) : n.width) / r, s = (o ? Wa(n.height) : n.height) / i;
  return (!a || !Number.isFinite(a)) && (a = 1), (!s || !Number.isFinite(s)) && (s = 1), {
    x: a,
    y: s
  };
}
const WA = /* @__PURE__ */ wn(0);
function Bx(e) {
  const t = Ut(e);
  return !Uf() || !t.visualViewport ? WA : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function UA(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== Ut(e) ? !1 : t;
}
function gr(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), o = Hf(e);
  let a = wn(1);
  t && (r ? un(r) && (a = Kr(r)) : a = Kr(e));
  const s = UA(o, n, r) ? Bx(o) : wn(0);
  let l = (i.left + s.x) / a.x, u = (i.top + s.y) / a.y, c = i.width / a.x, f = i.height / a.y;
  if (o) {
    const p = Ut(o), d = r && un(r) ? Ut(r) : r;
    let v = p, h = vc(v);
    for (; h && r && d !== v; ) {
      const g = Kr(h), m = h.getBoundingClientRect(), b = cn(h), x = m.left + (h.clientLeft + parseFloat(b.paddingLeft)) * g.x, C = m.top + (h.clientTop + parseFloat(b.paddingTop)) * g.y;
      l *= g.x, u *= g.y, c *= g.x, f *= g.y, l += x, u += C, v = Ut(h), h = vc(v);
    }
  }
  return Ua({
    width: c,
    height: f,
    x: l,
    y: u
  });
}
function Vf(e, t) {
  const n = Es(e).scrollLeft;
  return t ? t.left + n : gr(Cn(e)).left + n;
}
function zx(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), i = r.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    Vf(e, r)
  )), o = r.top + t.scrollTop;
  return {
    x: i,
    y: o
  };
}
function HA(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: i
  } = e;
  const o = i === "fixed", a = Cn(r), s = t ? Ss(t.floating) : !1;
  if (r === a || s && o)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = wn(1);
  const c = wn(0), f = En(r);
  if ((f || !f && !o) && ((vi(r) !== "body" || bo(a)) && (l = Es(r)), En(r))) {
    const d = gr(r);
    u = Kr(r), c.x = d.x + r.clientLeft, c.y = d.y + r.clientTop;
  }
  const p = a && !f && !o ? zx(a, l, !0) : wn(0);
  return {
    width: n.width * u.x,
    height: n.height * u.y,
    x: n.x * u.x - l.scrollLeft * u.x + c.x + p.x,
    y: n.y * u.y - l.scrollTop * u.y + c.y + p.y
  };
}
function VA(e) {
  return Array.from(e.getClientRects());
}
function KA(e) {
  const t = Cn(e), n = Es(e), r = e.ownerDocument.body, i = Wt(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), o = Wt(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let a = -n.scrollLeft + Vf(e);
  const s = -n.scrollTop;
  return cn(r).direction === "rtl" && (a += Wt(t.clientWidth, r.clientWidth) - i), {
    width: i,
    height: o,
    x: a,
    y: s
  };
}
function qA(e, t) {
  const n = Ut(e), r = Cn(e), i = n.visualViewport;
  let o = r.clientWidth, a = r.clientHeight, s = 0, l = 0;
  if (i) {
    o = i.width, a = i.height;
    const u = Uf();
    (!u || u && t === "fixed") && (s = i.offsetLeft, l = i.offsetTop);
  }
  return {
    width: o,
    height: a,
    x: s,
    y: l
  };
}
function GA(e, t) {
  const n = gr(e, !0, t === "fixed"), r = n.top + e.clientTop, i = n.left + e.clientLeft, o = En(e) ? Kr(e) : wn(1), a = e.clientWidth * o.x, s = e.clientHeight * o.y, l = i * o.x, u = r * o.y;
  return {
    width: a,
    height: s,
    x: l,
    y: u
  };
}
function Wh(e, t, n) {
  let r;
  if (t === "viewport")
    r = qA(e, n);
  else if (t === "document")
    r = KA(Cn(e));
  else if (un(t))
    r = GA(t, n);
  else {
    const i = Bx(e);
    r = {
      x: t.x - i.x,
      y: t.y - i.y,
      width: t.width,
      height: t.height
    };
  }
  return Ua(r);
}
function Wx(e, t) {
  const n = er(e);
  return n === t || !un(n) || ti(n) ? !1 : cn(n).position === "fixed" || Wx(n, t);
}
function YA(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = qn(e, [], !1).filter((s) => un(s) && vi(s) !== "body"), i = null;
  const o = cn(e).position === "fixed";
  let a = o ? er(e) : e;
  for (; un(a) && !ti(a); ) {
    const s = cn(a), l = Wf(a);
    !l && s.position === "fixed" && (i = null), (o ? !l && !i : !l && s.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || bo(a) && !l && Wx(e, a)) ? r = r.filter((c) => c !== a) : i = s, a = er(a);
  }
  return t.set(e, r), r;
}
function XA(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = e;
  const a = [...n === "clippingAncestors" ? Ss(t) ? [] : YA(t, this._c) : [].concat(n), r], s = a[0], l = a.reduce((u, c) => {
    const f = Wh(t, c, i);
    return u.top = Wt(f.top, u.top), u.right = ei(f.right, u.right), u.bottom = ei(f.bottom, u.bottom), u.left = Wt(f.left, u.left), u;
  }, Wh(t, s, i));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function JA(e) {
  const {
    width: t,
    height: n
  } = Fx(e);
  return {
    width: t,
    height: n
  };
}
function ZA(e, t, n) {
  const r = En(t), i = Cn(t), o = n === "fixed", a = gr(e, !0, o, t);
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = wn(0);
  function u() {
    l.x = Vf(i);
  }
  if (r || !r && !o)
    if ((vi(t) !== "body" || bo(i)) && (s = Es(t)), r) {
      const d = gr(t, !0, o, t);
      l.x = d.x + t.clientLeft, l.y = d.y + t.clientTop;
    } else i && u();
  o && !r && i && u();
  const c = i && !r && !o ? zx(i, s) : wn(0), f = a.left + s.scrollLeft - l.x - c.x, p = a.top + s.scrollTop - l.y - c.y;
  return {
    x: f,
    y: p,
    width: a.width,
    height: a.height
  };
}
function Ol(e) {
  return cn(e).position === "static";
}
function Uh(e, t) {
  if (!En(e) || cn(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return Cn(e) === n && (n = n.ownerDocument.body), n;
}
function Ux(e, t) {
  const n = Ut(e);
  if (Ss(e))
    return n;
  if (!En(e)) {
    let i = er(e);
    for (; i && !ti(i); ) {
      if (un(i) && !Ol(i))
        return i;
      i = er(i);
    }
    return n;
  }
  let r = Uh(e, t);
  for (; r && BA(r) && Ol(r); )
    r = Uh(r, t);
  return r && ti(r) && Ol(r) && !Wf(r) ? n : r || zA(e) || n;
}
const QA = async function(e) {
  const t = this.getOffsetParent || Ux, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: ZA(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function eD(e) {
  return cn(e).direction === "rtl";
}
const tD = {
  convertOffsetParentRelativeRectToViewportRelativeRect: HA,
  getDocumentElement: Cn,
  getClippingRect: XA,
  getOffsetParent: Ux,
  getElementRects: QA,
  getClientRects: VA,
  getDimensions: JA,
  getScale: Kr,
  isElement: un,
  isRTL: eD
};
function Hx(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function nD(e, t) {
  let n = null, r;
  const i = Cn(e);
  function o() {
    var s;
    clearTimeout(r), (s = n) == null || s.disconnect(), n = null;
  }
  function a(s, l) {
    s === void 0 && (s = !1), l === void 0 && (l = 1), o();
    const u = e.getBoundingClientRect(), {
      left: c,
      top: f,
      width: p,
      height: d
    } = u;
    if (s || t(), !p || !d)
      return;
    const v = Go(f), h = Go(i.clientWidth - (c + p)), g = Go(i.clientHeight - (f + d)), m = Go(c), x = {
      rootMargin: -v + "px " + -h + "px " + -g + "px " + -m + "px",
      threshold: Wt(0, ei(1, l)) || 1
    };
    let C = !0;
    function S(E) {
      const T = E[0].intersectionRatio;
      if (T !== l) {
        if (!C)
          return a();
        T ? a(!1, T) : r = setTimeout(() => {
          a(!1, 1e-7);
        }, 1e3);
      }
      T === 1 && !Hx(u, e.getBoundingClientRect()) && a(), C = !1;
    }
    try {
      n = new IntersectionObserver(S, {
        ...x,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(S, x);
    }
    n.observe(e);
  }
  return a(!0), o;
}
function rD(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: o = !0,
    elementResize: a = typeof ResizeObserver == "function",
    layoutShift: s = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = r, u = Hf(e), c = i || o ? [...u ? qn(u) : [], ...qn(t)] : [];
  c.forEach((m) => {
    i && m.addEventListener("scroll", n, {
      passive: !0
    }), o && m.addEventListener("resize", n);
  });
  const f = u && s ? nD(u, n) : null;
  let p = -1, d = null;
  a && (d = new ResizeObserver((m) => {
    let [b] = m;
    b && b.target === u && d && (d.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var x;
      (x = d) == null || x.observe(t);
    })), n();
  }), u && !l && d.observe(u), d.observe(t));
  let v, h = l ? gr(e) : null;
  l && g();
  function g() {
    const m = gr(e);
    h && !Hx(h, m) && n(), h = m, v = requestAnimationFrame(g);
  }
  return n(), () => {
    var m;
    c.forEach((b) => {
      i && b.removeEventListener("scroll", n), o && b.removeEventListener("resize", n);
    }), f == null || f(), (m = d) == null || m.disconnect(), d = null, l && cancelAnimationFrame(v);
  };
}
const iD = NA, oD = LA, aD = FA, sD = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: tD,
    ...n
  }, o = {
    ...i.platform,
    _c: r
  };
  return MA(e, t, {
    ...i,
    platform: o
  });
};
var Ea = typeof document < "u" ? ui : ft;
function Ha(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!Ha(e[r], t[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const o = i[r];
      if (!(o === "_owner" && e.$$typeof) && !Ha(e[o], t[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function Vx(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Hh(e, t) {
  const n = Vx(e);
  return Math.round(t * n) / n;
}
function Il(e) {
  const t = k.useRef(e);
  return Ea(() => {
    t.current = e;
  }), t;
}
function lD(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: o,
      floating: a
    } = {},
    transform: s = !0,
    whileElementsMounted: l,
    open: u
  } = e, [c, f] = k.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [p, d] = k.useState(r);
  Ha(p, r) || d(r);
  const [v, h] = k.useState(null), [g, m] = k.useState(null), b = k.useCallback((W) => {
    W !== E.current && (E.current = W, h(W));
  }, []), x = k.useCallback((W) => {
    W !== T.current && (T.current = W, m(W));
  }, []), C = o || v, S = a || g, E = k.useRef(null), T = k.useRef(null), N = k.useRef(c), j = l != null, O = Il(l), _ = Il(i), V = Il(u), L = k.useCallback(() => {
    if (!E.current || !T.current)
      return;
    const W = {
      placement: t,
      strategy: n,
      middleware: p
    };
    _.current && (W.platform = _.current), sD(E.current, T.current, W).then((P) => {
      const y = {
        ...P,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: V.current !== !1
      };
      I.current && !Ha(N.current, y) && (N.current = y, Ry.flushSync(() => {
        f(y);
      }));
    });
  }, [p, t, n, _, V]);
  Ea(() => {
    u === !1 && N.current.isPositioned && (N.current.isPositioned = !1, f((W) => ({
      ...W,
      isPositioned: !1
    })));
  }, [u]);
  const I = k.useRef(!1);
  Ea(() => (I.current = !0, () => {
    I.current = !1;
  }), []), Ea(() => {
    if (C && (E.current = C), S && (T.current = S), C && S) {
      if (O.current)
        return O.current(C, S, L);
      L();
    }
  }, [C, S, L, O, j]);
  const A = k.useMemo(() => ({
    reference: E,
    floating: T,
    setReference: b,
    setFloating: x
  }), [b, x]), M = k.useMemo(() => ({
    reference: C,
    floating: S
  }), [C, S]), q = k.useMemo(() => {
    const W = {
      position: n,
      left: 0,
      top: 0
    };
    if (!M.floating)
      return W;
    const P = Hh(M.floating, c.x), y = Hh(M.floating, c.y);
    return s ? {
      ...W,
      transform: "translate(" + P + "px, " + y + "px)",
      ...Vx(M.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: P,
      top: y
    };
  }, [n, s, M.floating, c.x, c.y]);
  return k.useMemo(() => ({
    ...c,
    update: L,
    refs: A,
    elements: M,
    floatingStyles: q
  }), [c, L, A, M, q]);
}
const uD = (e, t) => ({
  ...iD(e),
  options: [e, t]
}), cD = (e, t) => ({
  ...oD(e),
  options: [e, t]
}), fD = (e, t) => ({
  ...aD(e),
  options: [e, t]
});
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var dD = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"], mc = /* @__PURE__ */ dD.join(","), Kx = typeof Element > "u", eo = Kx ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, Va = !Kx && Element.prototype.getRootNode ? function(e) {
  var t;
  return e == null || (t = e.getRootNode) === null || t === void 0 ? void 0 : t.call(e);
} : function(e) {
  return e == null ? void 0 : e.ownerDocument;
}, Ka = function e(t, n) {
  var r;
  n === void 0 && (n = !0);
  var i = t == null || (r = t.getAttribute) === null || r === void 0 ? void 0 : r.call(t, "inert"), o = i === "" || i === "true", a = o || n && t && e(t.parentNode);
  return a;
}, pD = function(t) {
  var n, r = t == null || (n = t.getAttribute) === null || n === void 0 ? void 0 : n.call(t, "contenteditable");
  return r === "" || r === "true";
}, hD = function(t, n, r) {
  if (Ka(t))
    return [];
  var i = Array.prototype.slice.apply(t.querySelectorAll(mc));
  return n && eo.call(t, mc) && i.unshift(t), i = i.filter(r), i;
}, vD = function e(t, n, r) {
  for (var i = [], o = Array.from(t); o.length; ) {
    var a = o.shift();
    if (!Ka(a, !1))
      if (a.tagName === "SLOT") {
        var s = a.assignedElements(), l = s.length ? s : a.children, u = e(l, !0, r);
        r.flatten ? i.push.apply(i, u) : i.push({
          scopeParent: a,
          candidates: u
        });
      } else {
        var c = eo.call(a, mc);
        c && r.filter(a) && (n || !t.includes(a)) && i.push(a);
        var f = a.shadowRoot || // check for an undisclosed shadow
        typeof r.getShadowRoot == "function" && r.getShadowRoot(a), p = !Ka(f, !1) && (!r.shadowRootFilter || r.shadowRootFilter(a));
        if (f && p) {
          var d = e(f === !0 ? a.children : f.children, !0, r);
          r.flatten ? i.push.apply(i, d) : i.push({
            scopeParent: a,
            candidates: d
          });
        } else
          o.unshift.apply(o, a.children);
      }
  }
  return i;
}, qx = function(t) {
  return !isNaN(parseInt(t.getAttribute("tabindex"), 10));
}, Gx = function(t) {
  if (!t)
    throw new Error("No node provided");
  return t.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName) || pD(t)) && !qx(t) ? 0 : t.tabIndex;
}, mD = function(t, n) {
  var r = Gx(t);
  return r < 0 && n && !qx(t) ? 0 : r;
}, gD = function(t, n) {
  return t.tabIndex === n.tabIndex ? t.documentOrder - n.documentOrder : t.tabIndex - n.tabIndex;
}, Yx = function(t) {
  return t.tagName === "INPUT";
}, yD = function(t) {
  return Yx(t) && t.type === "hidden";
}, bD = function(t) {
  var n = t.tagName === "DETAILS" && Array.prototype.slice.apply(t.children).some(function(r) {
    return r.tagName === "SUMMARY";
  });
  return n;
}, xD = function(t, n) {
  for (var r = 0; r < t.length; r++)
    if (t[r].checked && t[r].form === n)
      return t[r];
}, wD = function(t) {
  if (!t.name)
    return !0;
  var n = t.form || Va(t), r = function(s) {
    return n.querySelectorAll('input[type="radio"][name="' + s + '"]');
  }, i;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    i = r(window.CSS.escape(t.name));
  else
    try {
      i = r(t.name);
    } catch (a) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", a.message), !1;
    }
  var o = xD(i, t.form);
  return !o || o === t;
}, SD = function(t) {
  return Yx(t) && t.type === "radio";
}, ED = function(t) {
  return SD(t) && !wD(t);
}, kD = function(t) {
  var n, r = t && Va(t), i = (n = r) === null || n === void 0 ? void 0 : n.host, o = !1;
  if (r && r !== t) {
    var a, s, l;
    for (o = !!((a = i) !== null && a !== void 0 && (s = a.ownerDocument) !== null && s !== void 0 && s.contains(i) || t != null && (l = t.ownerDocument) !== null && l !== void 0 && l.contains(t)); !o && i; ) {
      var u, c, f;
      r = Va(i), i = (u = r) === null || u === void 0 ? void 0 : u.host, o = !!((c = i) !== null && c !== void 0 && (f = c.ownerDocument) !== null && f !== void 0 && f.contains(i));
    }
  }
  return o;
}, Vh = function(t) {
  var n = t.getBoundingClientRect(), r = n.width, i = n.height;
  return r === 0 && i === 0;
}, CD = function(t, n) {
  var r = n.displayCheck, i = n.getShadowRoot;
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  var o = eo.call(t, "details>summary:first-of-type"), a = o ? t.parentElement : t;
  if (eo.call(a, "details:not([open]) *"))
    return !0;
  if (!r || r === "full" || r === "legacy-full") {
    if (typeof i == "function") {
      for (var s = t; t; ) {
        var l = t.parentElement, u = Va(t);
        if (l && !l.shadowRoot && i(l) === !0)
          return Vh(t);
        t.assignedSlot ? t = t.assignedSlot : !l && u !== t.ownerDocument ? t = u.host : t = l;
      }
      t = s;
    }
    if (kD(t))
      return !t.getClientRects().length;
    if (r !== "legacy-full")
      return !0;
  } else if (r === "non-zero-area")
    return Vh(t);
  return !1;
}, $D = function(t) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))
    for (var n = t.parentElement; n; ) {
      if (n.tagName === "FIELDSET" && n.disabled) {
        for (var r = 0; r < n.children.length; r++) {
          var i = n.children.item(r);
          if (i.tagName === "LEGEND")
            return eo.call(n, "fieldset[disabled] *") ? !0 : !i.contains(t);
        }
        return !0;
      }
      n = n.parentElement;
    }
  return !1;
}, TD = function(t, n) {
  return !(n.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  Ka(n) || yD(n) || CD(n, t) || // For a details element with a summary, the summary element gets the focus
  bD(n) || $D(n));
}, Kh = function(t, n) {
  return !(ED(n) || Gx(n) < 0 || !TD(t, n));
}, OD = function(t) {
  var n = parseInt(t.getAttribute("tabindex"), 10);
  return !!(isNaN(n) || n >= 0);
}, ID = function e(t) {
  var n = [], r = [];
  return t.forEach(function(i, o) {
    var a = !!i.scopeParent, s = a ? i.scopeParent : i, l = mD(s, a), u = a ? e(i.candidates) : s;
    l === 0 ? a ? n.push.apply(n, u) : n.push(s) : r.push({
      documentOrder: o,
      tabIndex: l,
      item: i,
      isScope: a,
      content: u
    });
  }), r.sort(gD).reduce(function(i, o) {
    return o.isScope ? i.push.apply(i, o.content) : i.push(o.content), i;
  }, []).concat(n);
}, Kf = function(t, n) {
  n = n || {};
  var r;
  return n.getShadowRoot ? r = vD([t], n.includeContainer, {
    filter: Kh.bind(null, n),
    flatten: !1,
    getShadowRoot: n.getShadowRoot,
    shadowRootFilter: OD
  }) : r = hD(t, n.includeContainer, Kh.bind(null, n)), ID(r);
};
const qf = "ArrowUp", ks = "ArrowDown", ni = "ArrowLeft", xo = "ArrowRight";
function Yo(e, t, n) {
  return Math.floor(e / t) !== n;
}
function Vi(e, t) {
  return t < 0 || t >= e.current.length;
}
function Rl(e, t) {
  return $t(e, {
    disabledIndices: t
  });
}
function qh(e, t) {
  return $t(e, {
    decrement: !0,
    startingIndex: e.current.length,
    disabledIndices: t
  });
}
function $t(e, t) {
  let {
    startingIndex: n = -1,
    decrement: r = !1,
    disabledIndices: i,
    amount: o = 1
  } = t === void 0 ? {} : t;
  const a = e.current;
  let s = n;
  do {
    var l, u;
    s = s + (r ? -o : o);
  } while (s >= 0 && s <= a.length - 1 && (i ? i.includes(s) : a[s] == null || (l = a[s]) != null && l.hasAttribute("disabled") || ((u = a[s]) == null ? void 0 : u.getAttribute("aria-disabled")) === "true"));
  return s;
}
function RD(e, t) {
  let {
    event: n,
    orientation: r,
    loop: i,
    cols: o,
    disabledIndices: a,
    minIndex: s,
    maxIndex: l,
    prevIndex: u,
    stopEvent: c = !1
  } = t, f = u;
  if (n.key === qf) {
    if (c && bt(n), u === -1)
      f = l;
    else if (f = $t(e, {
      startingIndex: f,
      amount: o,
      decrement: !0,
      disabledIndices: a
    }), i && (u - o < s || f < 0)) {
      const p = u % o, d = l % o, v = l - (d - p);
      d === p ? f = l : f = d > p ? v : v - o;
    }
    Vi(e, f) && (f = u);
  }
  if (n.key === ks && (c && bt(n), u === -1 ? f = s : (f = $t(e, {
    startingIndex: u,
    amount: o,
    disabledIndices: a
  }), i && u + o > l && (f = $t(e, {
    startingIndex: u % o - o,
    amount: o,
    disabledIndices: a
  }))), Vi(e, f) && (f = u)), r === "both") {
    const p = Nh(u / o);
    n.key === xo && (c && bt(n), u % o !== o - 1 ? (f = $t(e, {
      startingIndex: u,
      disabledIndices: a
    }), i && Yo(f, o, p) && (f = $t(e, {
      startingIndex: u - u % o - 1,
      disabledIndices: a
    }))) : i && (f = $t(e, {
      startingIndex: u - u % o - 1,
      disabledIndices: a
    })), Yo(f, o, p) && (f = u)), n.key === ni && (c && bt(n), u % o !== 0 ? (f = $t(e, {
      startingIndex: u,
      disabledIndices: a,
      decrement: !0
    }), i && Yo(f, o, p) && (f = $t(e, {
      startingIndex: u + (o - u % o),
      decrement: !0,
      disabledIndices: a
    }))) : i && (f = $t(e, {
      startingIndex: u + (o - u % o),
      decrement: !0,
      disabledIndices: a
    })), Yo(f, o, p) && (f = u));
    const d = Nh(l / o) === p;
    Vi(e, f) && (i && d ? f = n.key === ni ? l : $t(e, {
      startingIndex: u - u % o - 1,
      disabledIndices: a
    }) : f = u);
  }
  return f;
}
let Gh = 0;
function An(e, t) {
  t === void 0 && (t = {});
  const {
    preventScroll: n = !1,
    cancelPrevious: r = !0,
    sync: i = !1
  } = t;
  r && cancelAnimationFrame(Gh);
  const o = () => e == null ? void 0 : e.focus({
    preventScroll: n
  });
  i ? o() : Gh = requestAnimationFrame(o);
}
var ct = typeof document < "u" ? ui : ft;
function qa() {
  return qa = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, qa.apply(this, arguments);
}
let Pl = !1, PD = 0;
const Yh = () => "floating-ui-" + PD++;
function AD() {
  const [e, t] = k.useState(() => Pl ? Yh() : void 0);
  return ct(() => {
    e == null && t(Yh());
  }, []), k.useEffect(() => {
    Pl || (Pl = !0);
  }, []), e;
}
const DD = k.useId, Gf = DD || AD;
function _D() {
  const e = /* @__PURE__ */ new Map();
  return {
    emit(t, n) {
      var r;
      (r = e.get(t)) == null || r.forEach((i) => i(n));
    },
    on(t, n) {
      e.set(t, [...e.get(t) || [], n]);
    },
    off(t, n) {
      var r;
      e.set(t, ((r = e.get(t)) == null ? void 0 : r.filter((i) => i !== n)) || []);
    }
  };
}
const MD = /* @__PURE__ */ k.createContext(null), jD = /* @__PURE__ */ k.createContext(null), Xx = () => {
  var e;
  return ((e = k.useContext(MD)) == null ? void 0 : e.id) || null;
}, Cs = () => k.useContext(jD);
function to(e) {
  return "data-floating-ui-" + e;
}
function Gn(e) {
  const t = Ve(e);
  return ct(() => {
    t.current = e;
  }), t;
}
function ND(e, t) {
  var n;
  let r = [], i = (n = e.find((o) => o.id === t)) == null ? void 0 : n.parentId;
  for (; i; ) {
    const o = e.find((a) => a.id === i);
    i = o == null ? void 0 : o.parentId, o && (r = r.concat(o));
  }
  return r;
}
function qr(e, t) {
  let n = e.filter((i) => {
    var o;
    return i.parentId === t && ((o = i.context) == null ? void 0 : o.open);
  }), r = n;
  for (; r.length; )
    r = e.filter((i) => {
      var o;
      return (o = r) == null ? void 0 : o.some((a) => {
        var s;
        return i.parentId === a.id && ((s = i.context) == null ? void 0 : s.open);
      });
    }), n = n.concat(r);
  return n;
}
function LD(e, t) {
  let n, r = -1;
  function i(o, a) {
    a > r && (n = o, r = a), qr(e, o).forEach((l) => {
      i(l.id, a + 1);
    });
  }
  return i(t, 0), e.find((o) => o.id === n);
}
let Or = /* @__PURE__ */ new WeakMap(), Xo = /* @__PURE__ */ new WeakSet(), Jo = {}, Al = 0;
const FD = () => typeof HTMLElement < "u" && "inert" in HTMLElement.prototype, Jx = (e) => e && (e.host || Jx(e.parentNode)), BD = (e, t) => t.map((n) => {
  if (e.contains(n))
    return n;
  const r = Jx(n);
  return e.contains(r) ? r : null;
}).filter((n) => n != null);
function zD(e, t, n, r) {
  const i = "data-floating-ui-inert", o = r ? "inert" : n ? "aria-hidden" : null, a = BD(t, e), s = /* @__PURE__ */ new Set(), l = new Set(a), u = [];
  Jo[i] || (Jo[i] = /* @__PURE__ */ new WeakMap());
  const c = Jo[i];
  a.forEach(f), p(t), s.clear();
  function f(d) {
    !d || s.has(d) || (s.add(d), d.parentNode && f(d.parentNode));
  }
  function p(d) {
    !d || l.has(d) || Array.prototype.forEach.call(d.children, (v) => {
      if (s.has(v))
        p(v);
      else {
        const h = o ? v.getAttribute(o) : null, g = h !== null && h !== "false", m = (Or.get(v) || 0) + 1, b = (c.get(v) || 0) + 1;
        Or.set(v, m), c.set(v, b), u.push(v), m === 1 && g && Xo.add(v), b === 1 && v.setAttribute(i, ""), !g && o && v.setAttribute(o, "true");
      }
    });
  }
  return Al++, () => {
    u.forEach((d) => {
      const v = (Or.get(d) || 0) - 1, h = (c.get(d) || 0) - 1;
      Or.set(d, v), c.set(d, h), v || (!Xo.has(d) && o && d.removeAttribute(o), Xo.delete(d)), h || d.removeAttribute(i);
    }), Al--, Al || (Or = /* @__PURE__ */ new WeakMap(), Or = /* @__PURE__ */ new WeakMap(), Xo = /* @__PURE__ */ new WeakSet(), Jo = {});
  };
}
function Xh(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const r = on(e[0]).body;
  return zD(e.concat(Array.from(r.querySelectorAll("[aria-live]"))), r, t, n);
}
const Yf = () => ({
  getShadowRoot: !0,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver == "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function Zx(e, t) {
  const n = Kf(e, Yf());
  t === "prev" && n.reverse();
  const r = n.indexOf(Hn(on(e)));
  return n.slice(r + 1)[0];
}
function Qx() {
  return Zx(document.body, "next");
}
function ew() {
  return Zx(document.body, "prev");
}
function Ki(e, t) {
  const n = t || e.currentTarget, r = e.relatedTarget;
  return !r || !jt(n, r);
}
function WD(e) {
  Kf(e, Yf()).forEach((n) => {
    n.dataset.tabindex = n.getAttribute("tabindex") || "", n.setAttribute("tabindex", "-1");
  });
}
function UD(e) {
  e.querySelectorAll("[data-tabindex]").forEach((n) => {
    const r = n.dataset.tabindex;
    delete n.dataset.tabindex, r ? n.setAttribute("tabindex", r) : n.removeAttribute("tabindex");
  });
}
const Xf = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
let HD;
function Jh(e) {
  e.key === "Tab" && (e.target, clearTimeout(HD));
}
const Ga = /* @__PURE__ */ k.forwardRef(function(t, n) {
  const [r, i] = k.useState();
  ct(() => (Ax() && i("button"), document.addEventListener("keydown", Jh), () => {
    document.removeEventListener("keydown", Jh);
  }), []);
  const o = {
    ref: n,
    tabIndex: 0,
    // Role is only for VoiceOver
    role: r,
    "aria-hidden": r ? void 0 : !0,
    [to("focus-guard")]: "",
    style: Xf
  };
  return /* @__PURE__ */ k.createElement("span", qa({}, t, o));
}), tw = /* @__PURE__ */ k.createContext(null);
function VD(e) {
  let {
    id: t,
    root: n
  } = e === void 0 ? {} : e;
  const [r, i] = k.useState(null), o = Gf(), a = nw(), s = k.useMemo(() => ({
    id: t,
    root: n,
    portalContext: a,
    uniqueId: o
  }), [t, n, a, o]), l = k.useRef();
  return ct(() => () => {
    r == null || r.remove();
  }, [r, s]), ct(() => {
    if (l.current === s) return;
    l.current = s;
    const {
      id: u,
      root: c,
      portalContext: f,
      uniqueId: p
    } = s, d = u ? document.getElementById(u) : null, v = to("portal");
    if (d) {
      const h = document.createElement("div");
      h.id = p, h.setAttribute(v, ""), d.appendChild(h), i(h);
    } else {
      let h = c || (f == null ? void 0 : f.portalNode);
      h && !Xt(h) && (h = h.current), h = h || document.body;
      let g = null;
      u && (g = document.createElement("div"), g.id = u, h.appendChild(g));
      const m = document.createElement("div");
      m.id = p, m.setAttribute(v, ""), h = g || h, h.appendChild(m), i(m);
    }
  }, [s]), r;
}
function KD(e) {
  let {
    children: t,
    id: n,
    root: r = null,
    preserveTabOrder: i = !0
  } = e;
  const o = VD({
    id: n,
    root: r
  }), [a, s] = k.useState(null), l = k.useRef(null), u = k.useRef(null), c = k.useRef(null), f = k.useRef(null), p = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!a && // Guards are only for non-modal focus management.
    !a.modal && // Don't render if unmount is transitioning.
    a.open && i && !!(r || o)
  );
  return k.useEffect(() => {
    if (!o || !i || a != null && a.modal)
      return;
    function d(v) {
      o && Ki(v) && (v.type === "focusin" ? UD : WD)(o);
    }
    return o.addEventListener("focusin", d, !0), o.addEventListener("focusout", d, !0), () => {
      o.removeEventListener("focusin", d, !0), o.removeEventListener("focusout", d, !0);
    };
  }, [o, i, a == null ? void 0 : a.modal]), /* @__PURE__ */ k.createElement(tw.Provider, {
    value: k.useMemo(() => ({
      preserveTabOrder: i,
      beforeOutsideRef: l,
      afterOutsideRef: u,
      beforeInsideRef: c,
      afterInsideRef: f,
      portalNode: o,
      setFocusManagerState: s
    }), [i, o])
  }, p && o && /* @__PURE__ */ k.createElement(Ga, {
    "data-type": "outside",
    ref: l,
    onFocus: (d) => {
      if (Ki(d, o)) {
        var v;
        (v = c.current) == null || v.focus();
      } else {
        const h = ew() || (a == null ? void 0 : a.refs.domReference.current);
        h == null || h.focus();
      }
    }
  }), p && o && /* @__PURE__ */ k.createElement("span", {
    "aria-owns": o.id,
    style: Xf
  }), o && /* @__PURE__ */ aE(t, o), p && o && /* @__PURE__ */ k.createElement(Ga, {
    "data-type": "outside",
    ref: u,
    onFocus: (d) => {
      if (Ki(d, o)) {
        var v;
        (v = f.current) == null || v.focus();
      } else {
        const h = Qx() || (a == null ? void 0 : a.refs.domReference.current);
        h == null || h.focus(), a != null && a.closeOnFocusOut && (a == null || a.onOpenChange(!1, d.nativeEvent));
      }
    }
  }));
}
const nw = () => k.useContext(tw), qD = /* @__PURE__ */ k.forwardRef(function(t, n) {
  return /* @__PURE__ */ k.createElement("button", qa({}, t, {
    type: "button",
    ref: n,
    tabIndex: -1,
    style: Xf
  }));
});
function GD(e) {
  const {
    context: t,
    children: n,
    disabled: r = !1,
    order: i = ["content"],
    guards: o = !0,
    initialFocus: a = 0,
    returnFocus: s = !0,
    modal: l = !0,
    visuallyHiddenDismiss: u = !1,
    closeOnFocusOut: c = !0
  } = e, {
    open: f,
    refs: p,
    nodeId: d,
    onOpenChange: v,
    events: h,
    dataRef: g,
    elements: {
      domReference: m,
      floating: b
    }
  } = t, x = FD() ? o : !0, C = Gn(i), S = Gn(a), E = Gn(s), T = Cs(), N = nw(), j = typeof a == "number" && a < 0, O = k.useRef(null), _ = k.useRef(null), V = k.useRef(!1), L = k.useRef(null), I = k.useRef(!1), A = N != null, M = m && m.getAttribute("role") === "combobox" && _x(m) && j, q = k.useCallback(function(D) {
    return D === void 0 && (D = b), D ? Kf(D, Yf()) : [];
  }, [b]), W = k.useCallback((D) => {
    const B = q(D);
    return C.current.map((w) => m && w === "reference" ? m : b && w === "floating" ? b : B).filter(Boolean).flat();
  }, [m, b, C, q]);
  k.useEffect(() => {
    if (r || !l) return;
    function D(w) {
      if (w.key === "Tab") {
        jt(b, Hn(on(b))) && q().length === 0 && !M && bt(w);
        const U = W(), Y = Dx(w);
        C.current[0] === "reference" && Y === m && (bt(w), w.shiftKey ? An(U[U.length - 1]) : An(U[1])), C.current[1] === "floating" && Y === b && w.shiftKey && (bt(w), An(U[0]));
      }
    }
    const B = on(b);
    return B.addEventListener("keydown", D), () => {
      B.removeEventListener("keydown", D);
    };
  }, [r, m, b, l, C, p, M, q, W]), k.useEffect(() => {
    if (r || !c) return;
    function D() {
      I.current = !0, setTimeout(() => {
        I.current = !1;
      });
    }
    function B(w) {
      const U = w.relatedTarget;
      queueMicrotask(() => {
        const Y = !(jt(m, U) || jt(b, U) || jt(U, b) || jt(N == null ? void 0 : N.portalNode, U) || U != null && U.hasAttribute(to("focus-guard")) || T && (qr(T.nodesRef.current, d).find((K) => {
          var G, Z;
          return jt((G = K.context) == null ? void 0 : G.elements.floating, U) || jt((Z = K.context) == null ? void 0 : Z.elements.domReference, U);
        }) || ND(T.nodesRef.current, d).find((K) => {
          var G, Z;
          return ((G = K.context) == null ? void 0 : G.elements.floating) === U || ((Z = K.context) == null ? void 0 : Z.elements.domReference) === U;
        })));
        U && Y && !I.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
        U !== L.current && (V.current = !0, v(!1, w));
      });
    }
    if (b && Qr(m))
      return m.addEventListener("focusout", B), m.addEventListener("pointerdown", D), !l && b.addEventListener("focusout", B), () => {
        m.removeEventListener("focusout", B), m.removeEventListener("pointerdown", D), !l && b.removeEventListener("focusout", B);
      };
  }, [r, m, b, l, d, T, N, v, c]), k.useEffect(() => {
    var D;
    if (r) return;
    const B = Array.from((N == null || (D = N.portalNode) == null ? void 0 : D.querySelectorAll("[" + to("portal") + "]")) || []);
    if (b) {
      const w = [b, ...B, O.current, _.current, C.current.includes("reference") || M ? m : null].filter((Y) => Y != null), U = l ? Xh(w, x, !x) : Xh(w);
      return () => {
        U();
      };
    }
  }, [r, m, b, l, C, N, M, x]), ct(() => {
    if (r || !b) return;
    const D = on(b), B = Hn(D);
    queueMicrotask(() => {
      const w = W(b), U = S.current, Y = (typeof U == "number" ? w[U] : U.current) || b, K = jt(b, B);
      !j && !K && f && An(Y, {
        preventScroll: Y === b
      });
    });
  }, [r, f, b, j, W, S]), ct(() => {
    if (r || !b) return;
    let D = !1;
    const B = on(b), w = Hn(B), U = g.current;
    L.current = w;
    function Y(K) {
      if (K.type === "escapeKey" && p.domReference.current && (L.current = p.domReference.current), ["referencePress", "escapeKey"].includes(K.type))
        return;
      const G = K.data.returnFocus;
      typeof G == "object" ? (V.current = !1, D = G.preventScroll) : V.current = !G;
    }
    return h.on("dismiss", Y), () => {
      h.off("dismiss", Y);
      const K = Hn(B);
      (jt(b, K) || T && qr(T.nodesRef.current, d).some((Z) => {
        var Q;
        return jt((Q = Z.context) == null ? void 0 : Q.elements.floating, K);
      }) || U.openEvent && ["click", "mousedown"].includes(U.openEvent.type)) && p.domReference.current && (L.current = p.domReference.current), // eslint-disable-next-line react-hooks/exhaustive-deps
      E.current && Qr(L.current) && !V.current && An(L.current, {
        // When dismissing nested floating elements, by the time the rAF has
        // executed, the menus will all have been unmounted. When they try
        // to get focused, the calls get ignored — leaving the root
        // reference focused as desired.
        cancelPrevious: !1,
        preventScroll: D
      });
    };
  }, [r, b, E, g, p, h, T, d]), ct(() => {
    if (!(r || !N))
      return N.setFocusManagerState({
        modal: l,
        closeOnFocusOut: c,
        open: f,
        onOpenChange: v,
        refs: p
      }), () => {
        N.setFocusManagerState(null);
      };
  }, [r, N, l, f, v, p, c]), ct(() => {
    if (!r && b && typeof MutationObserver == "function" && !j) {
      const D = () => {
        const w = b.getAttribute("tabindex");
        C.current.includes("floating") || Hn(on(b)) !== p.domReference.current && q().length === 0 ? w !== "0" && b.setAttribute("tabindex", "0") : w !== "-1" && b.setAttribute("tabindex", "-1");
      };
      D();
      const B = new MutationObserver(D);
      return B.observe(b, {
        childList: !0,
        subtree: !0,
        attributes: !0
      }), () => {
        B.disconnect();
      };
    }
  }, [r, b, p, C, q, j]);
  function P(D) {
    return r || !u || !l ? null : /* @__PURE__ */ k.createElement(qD, {
      ref: D === "start" ? O : _,
      onClick: (B) => v(!1, B.nativeEvent)
    }, typeof u == "string" ? u : "Dismiss");
  }
  const y = !r && x && !M && (A || l);
  return /* @__PURE__ */ k.createElement(k.Fragment, null, y && /* @__PURE__ */ k.createElement(Ga, {
    "data-type": "inside",
    ref: N == null ? void 0 : N.beforeInsideRef,
    onFocus: (D) => {
      if (l) {
        const w = W();
        An(i[0] === "reference" ? w[0] : w[w.length - 1]);
      } else if (N != null && N.preserveTabOrder && N.portalNode)
        if (V.current = !1, Ki(D, N.portalNode)) {
          const w = Qx() || m;
          w == null || w.focus();
        } else {
          var B;
          (B = N.beforeOutsideRef.current) == null || B.focus();
        }
    }
  }), !M && P("start"), n, P("end"), y && /* @__PURE__ */ k.createElement(Ga, {
    "data-type": "inside",
    ref: N == null ? void 0 : N.afterInsideRef,
    onFocus: (D) => {
      if (l)
        An(W()[0]);
      else if (N != null && N.preserveTabOrder && N.portalNode)
        if (c && (V.current = !0), Ki(D, N.portalNode)) {
          const w = ew() || m;
          w == null || w.focus();
        } else {
          var B;
          (B = N.afterOutsideRef.current) == null || B.focus();
        }
    }
  }));
}
function Zh(e) {
  return Qr(e.target) && e.target.tagName === "BUTTON";
}
function Qh(e) {
  return _x(e);
}
function YD(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: r,
    dataRef: i,
    elements: {
      domReference: o
    }
  } = e, {
    enabled: a = !0,
    event: s = "click",
    toggle: l = !0,
    ignoreMouse: u = !1,
    keyboardHandlers: c = !0
  } = t, f = k.useRef(), p = k.useRef(!1);
  return k.useMemo(() => a ? {
    reference: {
      onPointerDown(d) {
        f.current = d.pointerType;
      },
      onMouseDown(d) {
        d.button === 0 && (Lh(f.current) && u || s !== "click" && (n && l && (!i.current.openEvent || i.current.openEvent.type === "mousedown") ? r(!1, d.nativeEvent) : (d.preventDefault(), r(!0, d.nativeEvent))));
      },
      onClick(d) {
        if (s === "mousedown" && f.current) {
          f.current = void 0;
          return;
        }
        Lh(f.current) && u || (n && l && (!i.current.openEvent || i.current.openEvent.type === "click") ? r(!1, d.nativeEvent) : r(!0, d.nativeEvent));
      },
      onKeyDown(d) {
        f.current = void 0, !(d.defaultPrevented || !c || Zh(d)) && (d.key === " " && !Qh(o) && (d.preventDefault(), p.current = !0), d.key === "Enter" && r(!(n && l), d.nativeEvent));
      },
      onKeyUp(d) {
        d.defaultPrevented || !c || Zh(d) || Qh(o) || d.key === " " && p.current && (p.current = !1, r(!(n && l), d.nativeEvent));
      }
    }
  } : {}, [a, i, s, u, c, o, l, n, r]);
}
const XD = k.useInsertionEffect, JD = XD || ((e) => e());
function Yn(e) {
  const t = k.useRef(() => {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return JD(() => {
    t.current = e;
  }), k.useCallback(function() {
    for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
      r[i] = arguments[i];
    return t.current == null ? void 0 : t.current(...r);
  }, []);
}
const ZD = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, QD = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, e_ = (e) => {
  var t, n;
  return {
    escapeKeyBubbles: typeof e == "boolean" ? e : (t = e == null ? void 0 : e.escapeKey) != null ? t : !1,
    outsidePressBubbles: typeof e == "boolean" ? e : (n = e == null ? void 0 : e.outsidePress) != null ? n : !0
  };
};
function t_(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: r,
    events: i,
    nodeId: o,
    elements: {
      reference: a,
      domReference: s,
      floating: l
    },
    dataRef: u
  } = e, {
    enabled: c = !0,
    escapeKey: f = !0,
    outsidePress: p = !0,
    outsidePressEvent: d = "pointerdown",
    referencePress: v = !1,
    referencePressEvent: h = "pointerdown",
    ancestorScroll: g = !1,
    bubbles: m
  } = t, b = Cs(), x = Xx() != null, C = Yn(typeof p == "function" ? p : () => !1), S = typeof p == "function" ? C : p, E = k.useRef(!1), {
    escapeKeyBubbles: T,
    outsidePressBubbles: N
  } = e_(m), j = Yn((_) => {
    if (!n || !c || !f || _.key !== "Escape")
      return;
    const V = b ? qr(b.nodesRef.current, o) : [];
    if (!T && (_.stopPropagation(), V.length > 0)) {
      let L = !0;
      if (V.forEach((I) => {
        var A;
        if ((A = I.context) != null && A.open && !I.context.dataRef.current.__escapeKeyBubbles) {
          L = !1;
          return;
        }
      }), !L)
        return;
    }
    i.emit("dismiss", {
      type: "escapeKey",
      data: {
        returnFocus: {
          preventScroll: !1
        }
      }
    }), r(!1, OA(_) ? _.nativeEvent : _);
  }), O = Yn((_) => {
    const V = E.current;
    if (E.current = !1, V || typeof S == "function" && !S(_))
      return;
    const L = Dx(_), I = "[" + to("inert") + "]", A = on(l).querySelectorAll(I);
    let M = Xt(L) ? L : null;
    for (; M && !EA(M); ) {
      const P = CA(M);
      if (P === on(l).body || !Xt(P))
        break;
      M = P;
    }
    if (A.length && Xt(L) && !IA(L) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !jt(L, l) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(A).every((P) => !jt(M, P)))
      return;
    if (Qr(L) && l) {
      const P = L.clientWidth > 0 && L.scrollWidth > L.clientWidth, y = L.clientHeight > 0 && L.scrollHeight > L.clientHeight;
      let D = y && _.offsetX > L.clientWidth;
      if (y && kA(L).direction === "rtl" && (D = _.offsetX <= L.offsetWidth - L.clientWidth), D || P && _.offsetY > L.clientHeight)
        return;
    }
    const q = b && qr(b.nodesRef.current, o).some((P) => {
      var y;
      return Tl(_, (y = P.context) == null ? void 0 : y.elements.floating);
    });
    if (Tl(_, l) || Tl(_, s) || q)
      return;
    const W = b ? qr(b.nodesRef.current, o) : [];
    if (W.length > 0) {
      let P = !0;
      if (W.forEach((y) => {
        var D;
        if ((D = y.context) != null && D.open && !y.context.dataRef.current.__outsidePressBubbles) {
          P = !1;
          return;
        }
      }), !P)
        return;
    }
    i.emit("dismiss", {
      type: "outsidePress",
      data: {
        returnFocus: x ? {
          preventScroll: !0
        } : Rx(_) || Px(_)
      }
    }), r(!1, _);
  });
  return k.useEffect(() => {
    if (!n || !c)
      return;
    u.current.__escapeKeyBubbles = T, u.current.__outsidePressBubbles = N;
    function _(I) {
      r(!1, I);
    }
    const V = on(l);
    f && V.addEventListener("keydown", j), S && V.addEventListener(d, O);
    let L = [];
    return g && (Xt(s) && (L = qn(s)), Xt(l) && (L = L.concat(qn(l))), !Xt(a) && a && a.contextElement && (L = L.concat(qn(a.contextElement)))), L = L.filter((I) => {
      var A;
      return I !== ((A = V.defaultView) == null ? void 0 : A.visualViewport);
    }), L.forEach((I) => {
      I.addEventListener("scroll", _, {
        passive: !0
      });
    }), () => {
      f && V.removeEventListener("keydown", j), S && V.removeEventListener(d, O), L.forEach((I) => {
        I.removeEventListener("scroll", _);
      });
    };
  }, [u, l, s, a, f, S, d, n, r, g, c, T, N, j, O]), k.useEffect(() => {
    E.current = !1;
  }, [S, d]), k.useMemo(() => c ? {
    reference: {
      onKeyDown: j,
      [ZD[h]]: (_) => {
        v && (i.emit("dismiss", {
          type: "referencePress",
          data: {
            returnFocus: !1
          }
        }), r(!1, _.nativeEvent));
      }
    },
    floating: {
      onKeyDown: j,
      [QD[d]]: () => {
        E.current = !0;
      }
    }
  } : {}, [c, i, v, d, h, r, j]);
}
let gc;
process.env.NODE_ENV !== "production" && (gc = /* @__PURE__ */ new Set());
function n_(e) {
  var t;
  e === void 0 && (e = {});
  const {
    open: n = !1,
    onOpenChange: r,
    nodeId: i
  } = e;
  if (process.env.NODE_ENV !== "production") {
    var o;
    const T = "Floating UI: Cannot pass a virtual element to the `elements.reference` option, as it must be a real DOM element. Use `refs.setPositionReference` instead.";
    if ((o = e.elements) != null && o.reference && !Xt(e.elements.reference)) {
      var a;
      if (!((a = gc) != null && a.has(T))) {
        var s;
        (s = gc) == null || s.add(T), console.error(T);
      }
    }
  }
  const [l, u] = k.useState(null), c = ((t = e.elements) == null ? void 0 : t.reference) || l, f = lD(e), p = Cs(), d = Yn((T, N) => {
    T && (h.current.openEvent = N), r == null || r(T, N);
  }), v = k.useRef(null), h = k.useRef({}), g = k.useState(() => _D())[0], m = Gf(), b = k.useCallback((T) => {
    const N = Xt(T) ? {
      getBoundingClientRect: () => T.getBoundingClientRect(),
      contextElement: T
    } : T;
    f.refs.setReference(N);
  }, [f.refs]), x = k.useCallback((T) => {
    (Xt(T) || T === null) && (v.current = T, u(T)), (Xt(f.refs.reference.current) || f.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    T !== null && !Xt(T)) && f.refs.setReference(T);
  }, [f.refs]), C = k.useMemo(() => ({
    ...f.refs,
    setReference: x,
    setPositionReference: b,
    domReference: v
  }), [f.refs, x, b]), S = k.useMemo(() => ({
    ...f.elements,
    domReference: c
  }), [f.elements, c]), E = k.useMemo(() => ({
    ...f,
    refs: C,
    elements: S,
    dataRef: h,
    nodeId: i,
    floatingId: m,
    events: g,
    open: n,
    onOpenChange: d
  }), [f, i, m, g, n, d, C, S]);
  return ct(() => {
    const T = p == null ? void 0 : p.nodesRef.current.find((N) => N.id === i);
    T && (T.context = E);
  }), k.useMemo(() => ({
    ...f,
    context: E,
    refs: C,
    elements: S
  }), [f, C, S, E]);
}
function Dl(e, t, n) {
  const r = /* @__PURE__ */ new Map();
  return {
    ...n === "floating" && {
      tabIndex: -1
    },
    ...e,
    ...t.map((i) => i ? i[n] : null).concat(e).reduce((i, o) => (o && Object.entries(o).forEach((a) => {
      let [s, l] = a;
      if (s.indexOf("on") === 0) {
        if (r.has(s) || r.set(s, []), typeof l == "function") {
          var u;
          (u = r.get(s)) == null || u.push(l), i[s] = function() {
            for (var c, f = arguments.length, p = new Array(f), d = 0; d < f; d++)
              p[d] = arguments[d];
            return (c = r.get(s)) == null ? void 0 : c.map((v) => v(...p)).find((v) => v !== void 0);
          };
        }
      } else
        i[s] = l;
    }), i), {})
  };
}
function r_(e) {
  e === void 0 && (e = []);
  const t = e, n = k.useCallback(
    (o) => Dl(o, e, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), r = k.useCallback(
    (o) => Dl(o, e, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), i = k.useCallback(
    (o) => Dl(o, e, "item"),
    // Granularly check for `item` changes, because the `getItemProps` getter
    // should be as referentially stable as possible since it may be passed as
    // a prop to many components. All `item` key values must therefore be
    // memoized.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    e.map((o) => o == null ? void 0 : o.item)
  );
  return k.useMemo(() => ({
    getReferenceProps: n,
    getFloatingProps: r,
    getItemProps: i
  }), [n, r, i]);
}
let ev = !1;
function $s(e, t, n) {
  switch (e) {
    case "vertical":
      return t;
    case "horizontal":
      return n;
    default:
      return t || n;
  }
}
function tv(e, t) {
  return $s(t, e === qf || e === ks, e === ni || e === xo);
}
function _l(e, t, n) {
  return $s(t, e === ks, n ? e === ni : e === xo) || e === "Enter" || e == " " || e === "";
}
function i_(e, t, n) {
  return $s(t, n ? e === ni : e === xo, e === ks);
}
function nv(e, t, n) {
  return $s(t, n ? e === xo : e === ni, e === qf);
}
function o_(e, t) {
  const {
    open: n,
    onOpenChange: r,
    refs: i,
    elements: {
      domReference: o,
      floating: a
    }
  } = e, {
    listRef: s,
    activeIndex: l,
    onNavigate: u = () => {
    },
    enabled: c = !0,
    selectedIndex: f = null,
    allowEscape: p = !1,
    loop: d = !1,
    nested: v = !1,
    rtl: h = !1,
    virtual: g = !1,
    focusItemOnOpen: m = "auto",
    focusItemOnHover: b = !0,
    openOnArrowKeyDown: x = !0,
    disabledIndices: C = void 0,
    orientation: S = "vertical",
    cols: E = 1,
    scrollItemIntoView: T = !0,
    virtualItemRef: N
  } = t;
  process.env.NODE_ENV !== "production" && (p && (d || console.warn(["Floating UI: `useListNavigation` looping must be enabled to allow", "escaping."].join(" ")), g || console.warn(["Floating UI: `useListNavigation` must be virtual to allow", "escaping."].join(" "))), S === "vertical" && E > 1 && console.warn(["Floating UI: In grid list navigation mode (`cols` > 1), the", '`orientation` should be either "horizontal" or "both".'].join(" ")));
  const j = Xx(), O = Cs(), _ = Yn(u), V = k.useRef(m), L = k.useRef(f ?? -1), I = k.useRef(null), A = k.useRef(!0), M = k.useRef(_), q = k.useRef(!!a), W = k.useRef(!1), P = k.useRef(!1), y = Gn(C), D = Gn(n), B = Gn(T), [w, U] = k.useState(), [Y, K] = k.useState(), G = Yn(function(X, J, H) {
    H === void 0 && (H = !1);
    const re = X.current[J.current];
    re && (g ? (U(re.id), O == null || O.events.emit("virtualfocus", re), N && (N.current = re)) : An(re, {
      preventScroll: !0,
      // Mac Safari does not move the virtual cursor unless the focus call
      // is sync. However, for the very first focus call, we need to wait
      // for the position to be ready in order to prevent unwanted
      // scrolling. This means the virtual cursor will not move to the first
      // item when first opening the floating element, but will on
      // subsequent calls. `preventScroll` is supported in modern Safari,
      // so we can use that instead.
      // iOS Safari must be async or the first item will not be focused.
      sync: TA() && Ax() ? ev || W.current : !1
    }), requestAnimationFrame(() => {
      const se = B.current;
      se && re && (H || !A.current) && (re.scrollIntoView == null || re.scrollIntoView(typeof se == "boolean" ? {
        block: "nearest",
        inline: "nearest"
      } : se));
    }));
  });
  ct(() => {
    document.createElement("div").focus({
      get preventScroll() {
        return ev = !0, !1;
      }
    });
  }, []), ct(() => {
    c && (n && a ? V.current && f != null && (P.current = !0, _(f)) : q.current && (L.current = -1, M.current(null)));
  }, [c, n, a, f, _]), ct(() => {
    if (c && n && a)
      if (l == null) {
        if (W.current = !1, f != null)
          return;
        if (q.current && (L.current = -1, G(s, L)), !q.current && V.current && (I.current != null || V.current === !0 && I.current == null)) {
          let X = 0;
          const J = () => {
            s.current[0] == null ? (X < 2 && (X ? requestAnimationFrame : queueMicrotask)(J), X++) : (L.current = I.current == null || _l(I.current, S, h) || v ? Rl(s, y.current) : qh(s, y.current), I.current = null, _(L.current));
          };
          J();
        }
      } else Vi(s, l) || (L.current = l, G(s, L, P.current), P.current = !1);
  }, [c, n, a, l, f, v, s, S, h, _, G, y]), ct(() => {
    var X, J;
    if (!c || a || !O || g || !q.current)
      return;
    const H = O.nodesRef.current, re = (X = H.find((oe) => oe.id === j)) == null || (J = X.context) == null ? void 0 : J.elements.floating, se = Hn(on(a)), fe = H.some((oe) => oe.context && jt(oe.context.elements.floating, se));
    re && !fe && A.current && re.focus({
      preventScroll: !0
    });
  }, [c, a, O, j, g]), ct(() => {
    if (!c || !O || !g || j) return;
    function X(J) {
      K(J.id), N && (N.current = J);
    }
    return O.events.on("virtualfocus", X), () => {
      O.events.off("virtualfocus", X);
    };
  }, [c, O, g, j, N]), ct(() => {
    M.current = _, q.current = !!a;
  }), ct(() => {
    n || (I.current = null);
  }, [n]);
  const Z = l != null, Q = k.useMemo(() => {
    function X(H) {
      if (!n) return;
      const re = s.current.indexOf(H);
      re !== -1 && _(re);
    }
    return {
      onFocus(H) {
        let {
          currentTarget: re
        } = H;
        X(re);
      },
      onClick: (H) => {
        let {
          currentTarget: re
        } = H;
        return re.focus({
          preventScroll: !0
        });
      },
      // Safari
      ...b && {
        onMouseMove(H) {
          let {
            currentTarget: re
          } = H;
          X(re);
        },
        onPointerLeave(H) {
          let {
            pointerType: re
          } = H;
          !A.current || re === "touch" || (L.current = -1, G(s, L), _(null), g || An(i.floating.current, {
            preventScroll: !0
          }));
        }
      }
    };
  }, [n, i, G, b, s, _, g]);
  return k.useMemo(() => {
    if (!c)
      return {};
    const X = y.current;
    function J(oe) {
      if (A.current = !1, W.current = !0, !D.current && oe.currentTarget === i.floating.current)
        return;
      if (v && nv(oe.key, S, h)) {
        bt(oe), r(!1, oe.nativeEvent), Qr(o) && !g && o.focus();
        return;
      }
      const me = L.current, we = Rl(s, X), Ie = qh(s, X);
      if (oe.key === "Home" && (bt(oe), L.current = we, _(L.current)), oe.key === "End" && (bt(oe), L.current = Ie, _(L.current)), !(E > 1 && (L.current = RD(s, {
        event: oe,
        orientation: S,
        loop: d,
        cols: E,
        disabledIndices: X,
        minIndex: we,
        maxIndex: Ie,
        prevIndex: L.current,
        stopEvent: !0
      }), _(L.current), S === "both")) && tv(oe.key, S)) {
        if (bt(oe), n && !g && Hn(oe.currentTarget.ownerDocument) === oe.currentTarget) {
          L.current = _l(oe.key, S, h) ? we : Ie, _(L.current);
          return;
        }
        _l(oe.key, S, h) ? d ? L.current = me >= Ie ? p && me !== s.current.length ? -1 : we : $t(s, {
          startingIndex: me,
          disabledIndices: X
        }) : L.current = Math.min(Ie, $t(s, {
          startingIndex: me,
          disabledIndices: X
        })) : d ? L.current = me <= we ? p && me !== -1 ? s.current.length : Ie : $t(s, {
          startingIndex: me,
          decrement: !0,
          disabledIndices: X
        }) : L.current = Math.max(we, $t(s, {
          startingIndex: me,
          decrement: !0,
          disabledIndices: X
        })), Vi(s, L.current) ? _(null) : _(L.current);
      }
    }
    function H(oe) {
      m === "auto" && Rx(oe.nativeEvent) && (V.current = !0);
    }
    function re(oe) {
      V.current = m, m === "auto" && Px(oe.nativeEvent) && (V.current = !0);
    }
    const se = g && n && Z && {
      "aria-activedescendant": Y || w
    }, fe = s.current.find((oe) => (oe == null ? void 0 : oe.id) === w);
    return {
      reference: {
        ...se,
        onKeyDown(oe) {
          A.current = !1;
          const me = oe.key.indexOf("Arrow") === 0, we = i_(oe.key, S, h), Ie = nv(oe.key, S, h), nt = tv(oe.key, S), St = (v ? we : nt) || oe.key === "Enter" || oe.key.trim() === "";
          if (g && n) {
            const ue = O == null ? void 0 : O.nodesRef.current.find((F) => F.parentId == null), z = O && ue ? LD(O.nodesRef.current, ue.id) : null;
            if (me && z && N) {
              const F = new KeyboardEvent("keydown", {
                key: oe.key,
                bubbles: !0
              });
              if (we || Ie) {
                var Et, kt;
                const te = ((Et = z.context) == null ? void 0 : Et.elements.domReference) === oe.currentTarget, ae = Ie && !te ? (kt = z.context) == null ? void 0 : kt.elements.domReference : we ? fe : null;
                ae && (bt(oe), ae.dispatchEvent(F), K(void 0));
              }
              if (nt && z.context && z.context.open && z.parentId && oe.currentTarget !== z.context.elements.domReference) {
                var ie;
                bt(oe), (ie = z.context.elements.domReference) == null || ie.dispatchEvent(F);
                return;
              }
            }
            return J(oe);
          }
          if (!(!n && !x && me)) {
            if (St && (I.current = v && nt ? null : oe.key), v) {
              we && (bt(oe), n ? (L.current = Rl(s, X), _(L.current)) : r(!0, oe.nativeEvent));
              return;
            }
            nt && (f != null && (L.current = f), bt(oe), !n && x ? r(!0, oe.nativeEvent) : J(oe), n && _(L.current));
          }
        },
        onFocus() {
          n && _(null);
        },
        onPointerDown: re,
        onMouseDown: H,
        onClick: H
      },
      floating: {
        "aria-orientation": S === "both" ? void 0 : S,
        ...se,
        onKeyDown: J,
        onPointerMove() {
          A.current = !0;
        }
      },
      item: Q
    };
  }, [o, i, w, Y, y, D, s, c, S, h, g, n, Z, v, f, x, p, E, d, m, _, r, Q, O, N]);
}
function a_(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    floatingId: r
  } = e, {
    enabled: i = !0,
    role: o = "dialog"
  } = t, a = Gf();
  return k.useMemo(() => {
    const s = {
      id: r,
      role: o
    };
    return i ? o === "tooltip" ? {
      reference: {
        "aria-describedby": n ? r : void 0
      },
      floating: s
    } : {
      reference: {
        "aria-expanded": n ? "true" : "false",
        "aria-haspopup": o === "alertdialog" ? "dialog" : o,
        "aria-controls": n ? r : void 0,
        ...o === "listbox" && {
          role: "combobox"
        },
        ...o === "menu" && {
          id: a
        }
      },
      floating: {
        ...s,
        ...o === "menu" && {
          "aria-labelledby": a
        }
      }
    } : {};
  }, [i, o, n, r, a]);
}
function s_(e, t) {
  var n;
  const {
    open: r,
    dataRef: i
  } = e, {
    listRef: o,
    activeIndex: a,
    onMatch: s,
    onTypingChange: l,
    enabled: u = !0,
    findMatch: c = null,
    resetMs: f = 750,
    ignoreKeys: p = [],
    selectedIndex: d = null
  } = t, v = k.useRef(), h = k.useRef(""), g = k.useRef((n = d ?? a) != null ? n : -1), m = k.useRef(null), b = Yn(s), x = Yn(l), C = Gn(c), S = Gn(p);
  return ct(() => {
    r && (clearTimeout(v.current), m.current = null, h.current = "");
  }, [r]), ct(() => {
    if (r && h.current === "") {
      var E;
      g.current = (E = d ?? a) != null ? E : -1;
    }
  }, [r, d, a]), k.useMemo(() => {
    if (!u)
      return {};
    function E(j) {
      j ? i.current.typing || (i.current.typing = j, x(j)) : i.current.typing && (i.current.typing = j, x(j));
    }
    function T(j, O, _) {
      const V = C.current ? C.current(O, _) : O.find((L) => (L == null ? void 0 : L.toLocaleLowerCase().indexOf(_.toLocaleLowerCase())) === 0);
      return V ? j.indexOf(V) : -1;
    }
    function N(j) {
      const O = o.current;
      if (h.current.length > 0 && h.current[0] !== " " && (T(O, O, h.current) === -1 ? E(!1) : j.key === " " && bt(j)), O == null || S.current.includes(j.key) || // Character key.
      j.key.length !== 1 || // Modifier key.
      j.ctrlKey || j.metaKey || j.altKey)
        return;
      r && j.key !== " " && (bt(j), E(!0)), O.every((I) => {
        var A, M;
        return I ? ((A = I[0]) == null ? void 0 : A.toLocaleLowerCase()) !== ((M = I[1]) == null ? void 0 : M.toLocaleLowerCase()) : !0;
      }) && h.current === j.key && (h.current = "", g.current = m.current), h.current += j.key, clearTimeout(v.current), v.current = setTimeout(() => {
        h.current = "", g.current = m.current, E(!1);
      }, f);
      const V = g.current, L = T(O, [...O.slice((V || 0) + 1), ...O.slice(0, (V || 0) + 1)], h.current);
      L !== -1 ? (b(L), m.current = L) : j.key !== " " && (h.current = "", E(!1));
    }
    return {
      reference: {
        onKeyDown: N
      },
      floating: {
        onKeyDown: N,
        onKeyUp(j) {
          j.key === " " && E(!1);
        }
      }
    };
  }, [u, r, i, o, f, S, C, b, x]);
}
const l_ = ({ options: e, reusable: t, sendMessage: n, isReadOnly: r }) => {
  var I, A, M, q, W;
  const i = _f((P) => P.messageContainerRef), [o, a] = k.useState(!1), [s, l] = k.useState(null), [u, c] = k.useState(null), {
    message: {
      blocks: { dropdown: f }
    }
  } = Te, p = e.reduce(
    (P, y) => (P[y.label] = y.value, P),
    {}
  ), d = p ? Object.keys(p) : [], v = (P) => {
    a(u !== null && !t ? !1 : P);
  }, { refs: h, floatingStyles: g, context: m } = n_({
    placement: "bottom-start",
    open: o,
    onOpenChange: v,
    whileElementsMounted: rD,
    middleware: [
      uD(5),
      cD({
        padding: 10,
        boundary: (i == null ? void 0 : i.current) ?? void 0,
        crossAxis: !0
      }),
      fD({
        apply({ rects: P, elements: y, availableHeight: D }) {
          Object.assign(y.floating.style, {
            maxHeight: `${D}px`,
            minWidth: `${P.reference.width}px`
          });
        },
        padding: 10
      })
    ]
  }), b = k.useRef([]), x = k.useRef(d), C = k.useRef(!1), S = YD(m, { event: "mousedown" }), E = t_(m), T = a_(m, { role: "listbox" }), N = o_(m, {
    listRef: b,
    activeIndex: s,
    selectedIndex: u,
    onNavigate: l,
    // This is a large list, allow looping.
    loop: !0
  }), j = s_(m, {
    listRef: x,
    activeIndex: s,
    selectedIndex: u,
    onMatch: o ? l : c,
    onTypingChange(P) {
      C.current = P;
    }
  }), { getReferenceProps: O, getFloatingProps: _, getItemProps: V } = r_([
    E,
    T,
    N,
    j,
    S
  ]), L = (P) => {
    c(P), d[P] !== void 0 && (n == null || n({
      type: "text",
      text: d[P] ?? "",
      value: p[d[P]] ?? ""
    })), a(!1);
  };
  return /* @__PURE__ */ $.jsxs($.Fragment, { children: [
    /* @__PURE__ */ $.jsxs(
      "div",
      {
        tabIndex: 0,
        ref: h.setReference,
        "aria-labelledby": "select-label",
        "aria-autocomplete": "none",
        "data-disabled": u !== null && !t ? "" : void 0,
        style: r ? { pointerEvents: "none" } : void 0,
        ...(I = f.button) == null ? void 0 : I.container,
        ...O(),
        children: [
          /* @__PURE__ */ $.jsx("span", { ...(A = f.button) == null ? void 0 : A.text, children: u ? d[u] : "Select..." }),
          /* @__PURE__ */ $.jsx(zR, { ...(M = f.button) == null ? void 0 : M.icon })
        ]
      }
    ),
    o && /* @__PURE__ */ $.jsx(KD, { children: /* @__PURE__ */ $.jsx(GD, { context: m, modal: !1, children: /* @__PURE__ */ $.jsx(
      "div",
      {
        ref: h.setFloating,
        className: (W = (q = f.content) == null ? void 0 : q.container) == null ? void 0 : W.className,
        style: { ...g },
        ..._(),
        children: d.map((P, y) => {
          var D;
          return /* @__PURE__ */ $.jsx(
            "div",
            {
              ref: (B) => {
                b.current[y] = B;
              },
              role: "option",
              tabIndex: y === s ? 0 : -1,
              "aria-selected": y === u && y === s,
              "data-active": y === s ? "" : void 0,
              ...(D = f.content) == null ? void 0 : D.item,
              ...V({
                onClick() {
                  L(y);
                },
                onKeyDown(B) {
                  B.key === "Enter" && (B.preventDefault(), L(y)), B.key === " " && !C.current && (B.preventDefault(), L(y));
                }
              }),
              children: P
            },
            P
          );
        })
      }
    ) }) })
  ] });
}, rw = Ot(({ title: e, url: t, isReadOnly: n, ...r }, i) => {
  const {
    message: {
      blocks: { file: o }
    }
  } = Te;
  return /* @__PURE__ */ $.jsxs(
    "a",
    {
      ...r,
      ...o.container,
      href: t,
      style: n ? { pointerEvents: "none" } : void 0,
      download: !0,
      ref: i,
      target: "_blank",
      rel: "noreferrer",
      children: [
        /* @__PURE__ */ $.jsx("p", { ...o.title, children: e || t }),
        /* @__PURE__ */ $.jsx(qR, { ...o.icon })
      ]
    }
  );
});
rw.displayName = "File";
const u_ = di()((e, t) => ({
  components: {},
  getCustomComponent: async (n) => {
    const r = t().components[n];
    if (r)
      return r;
    const i = await fetch(n).then((u) => u.text()), o = new Blob([i], { type: "application/javascript" }), s = await import(URL.createObjectURL(o)), l = () => s.default;
    return e((u) => ({ components: { ...u.components, [n]: l } })), l;
  }
}));
globalThis.React = Ne;
const c_ = ({ url: e, name: t, data: n, ...r }) => {
  const i = u_((u) => u.getCustomComponent), [o, a] = ge(null), [s, l] = ge(null);
  return ft(() => {
    i(e).then(a).catch((u) => {
      l(u.message);
    });
  }, [e]), s ? /* @__PURE__ */ $.jsx("div", { style: { color: "red" }, children: s }) : o ? /* @__PURE__ */ $.jsx(o, { ...n, ...r }) : null;
}, f_ = {
  audio: yx,
  bubble: hx,
  button: LP,
  carousel: $x,
  column: xx,
  dropdown: l_,
  file: rw,
  image: mx,
  location: bx,
  row: wx,
  text: uP,
  video: gx,
  custom: c_
}, ri = ({ block: e, renderers: t, ...n }) => {
  const r = (t == null ? void 0 : t[e.type]) ?? f_[e.type], i = { ...n, ...e };
  return /* @__PURE__ */ $.jsx(r, { ...i });
};
function iw(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (n = iw(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function no() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++) (e = arguments[n]) && (t = iw(e)) && (r && (r += " "), r += t);
  return r;
}
const d_ = ({ disabled: e, onFileSelected: t }) => {
  const n = Ve(null), { uploadButton: r } = Te.composer, i = () => {
    n.current && n.current.click();
  }, o = (a) => {
    const s = a.target.files;
    s && s.length > 0 && Array.from(s).forEach((l) => {
      t(l);
    });
  };
  return /* @__PURE__ */ $.jsxs($.Fragment, { children: [
    /* @__PURE__ */ $.jsx(
      nP,
      {
        ...r,
        role: "button",
        tabIndex: 0,
        "aria-label": "Upload File Button",
        "data-disabled": e,
        onClick: i
      }
    ),
    /* @__PURE__ */ $.jsx(
      "input",
      {
        value: "",
        multiple: !0,
        type: "file",
        ref: n,
        style: { display: "none" },
        onChange: o
      }
    )
  ] });
}, p_ = ({ name: e, type: t, instance: n, status: r, removeFile: i }) => {
  const { loader: o, fileIcon: a, removeIcon: s, errorIcon: l, previewImage: u } = Te.composer.fileWidget, c = ["PNG", "JPEG", "JPG"].includes(Qo(e)), f = ut(() => c ? URL.createObjectURL(n) : "", [n]);
  return r === "loading" ? /* @__PURE__ */ $.jsx(Zo, { name: e, status: r, removeButton: /* @__PURE__ */ $.jsx("div", { ...o }), extension: Qo(e), children: /* @__PURE__ */ $.jsx("div", { ...a.container, children: /* @__PURE__ */ $.jsx(Ml, { type: t, ...a.icon }) }) }) : r === "error" ? /* @__PURE__ */ $.jsx(
    Zo,
    {
      name: e,
      status: r,
      removeButton: /* @__PURE__ */ $.jsx(rv, { removeFile: () => i(e) }),
      extension: "Upload Error",
      children: /* @__PURE__ */ $.jsxs("div", { ...a.container, children: [
        /* @__PURE__ */ $.jsx(HR, { ...l }),
        /* @__PURE__ */ $.jsx(Ml, { type: t, ...a.icon })
      ] })
    }
  ) : r == "uploaded" && c ? /* @__PURE__ */ $.jsx(
    Zo,
    {
      name: e,
      status: r,
      removeButton: /* @__PURE__ */ $.jsx(rv, { removeFile: () => i(e) }),
      extension: Qo(e),
      children: /* @__PURE__ */ $.jsx("div", { ...a.container, children: /* @__PURE__ */ $.jsx("img", { src: f, alt: e, ...u }) })
    }
  ) : /* @__PURE__ */ $.jsx(
    Zo,
    {
      name: e,
      status: r,
      removeButton: /* @__PURE__ */ $.jsx(Jb, { onClick: () => i(e), ...s }),
      extension: Qo(e),
      children: /* @__PURE__ */ $.jsx("div", { ...a.container, children: /* @__PURE__ */ $.jsx(Ml, { type: t, ...a.icon }) })
    }
  );
}, Zo = ({ name: e, status: t, removeButton: n, children: r, extension: i }) => {
  const { container: o, metadata: a } = Te.composer.fileWidget;
  return /* @__PURE__ */ $.jsxs("div", { "data-status": t, title: e, ...o, children: [
    n,
    r,
    /* @__PURE__ */ $.jsxs("div", { ...a.container, children: [
      /* @__PURE__ */ $.jsx("div", { ...a.name, children: e }),
      /* @__PURE__ */ $.jsx("div", { ...a.type, children: i })
    ] })
  ] });
}, Ml = ({ type: e, ...t }) => e === "image" ? /* @__PURE__ */ $.jsx(XR, { ...t }) : e === "video" ? /* @__PURE__ */ $.jsx(aP, { ...t }) : e === "audio" ? /* @__PURE__ */ $.jsx(sP, { ...t }) : /* @__PURE__ */ $.jsx(Zb, { ...t }), Qo = (e) => {
  const t = e.split(".").pop();
  return t ? t.toUpperCase() : "File";
}, rv = ({ removeFile: e }) => {
  const {
    composer: {
      fileWidget: { removeIcon: t }
    }
  } = Te;
  return /* @__PURE__ */ $.jsx(Jb, { role: "button", tabIndex: 0, "aria-label": "Remove File Button", onClick: () => e(), ...t });
};
function yc() {
  return yc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, yc.apply(null, arguments);
}
function h_(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
var v_ = ui, m_ = function(t) {
  var n = k.useRef(t);
  return v_(function() {
    n.current = t;
  }), n;
}, iv = function(t, n) {
  if (typeof t == "function") {
    t(n);
    return;
  }
  t.current = n;
}, g_ = function(t, n) {
  var r = Ve();
  return Oe(function(i) {
    t.current = i, r.current && iv(r.current, null), r.current = n, n && iv(n, i);
  }, [n]);
}, ov = {
  "min-height": "0",
  "max-height": "none",
  height: "0",
  visibility: "hidden",
  overflow: "hidden",
  position: "absolute",
  "z-index": "-1000",
  top: "0",
  right: "0",
  display: "block"
}, y_ = function(t) {
  Object.keys(ov).forEach(function(n) {
    t.style.setProperty(n, ov[n], "important");
  });
}, av = y_, At = null, sv = function(t, n) {
  var r = t.scrollHeight;
  return n.sizingStyle.boxSizing === "border-box" ? r + n.borderSize : r - n.paddingSize;
};
function b_(e, t, n, r) {
  n === void 0 && (n = 1), r === void 0 && (r = 1 / 0), At || (At = document.createElement("textarea"), At.setAttribute("tabindex", "-1"), At.setAttribute("aria-hidden", "true"), av(At)), At.parentNode === null && document.body.appendChild(At);
  var i = e.paddingSize, o = e.borderSize, a = e.sizingStyle, s = a.boxSizing;
  Object.keys(a).forEach(function(p) {
    var d = p;
    At.style[d] = a[d];
  }), av(At), At.value = t;
  var l = sv(At, e);
  At.value = t, l = sv(At, e), At.value = "x";
  var u = At.scrollHeight - i, c = u * n;
  s === "border-box" && (c = c + i + o), l = Math.max(c, l);
  var f = u * r;
  return s === "border-box" && (f = f + i + o), l = Math.min(f, l), [l, u];
}
var lv = function() {
}, x_ = function(t, n) {
  return t.reduce(function(r, i) {
    return r[i] = n[i], r;
  }, {});
}, w_ = [
  "borderBottomWidth",
  "borderLeftWidth",
  "borderRightWidth",
  "borderTopWidth",
  "boxSizing",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "lineHeight",
  "paddingBottom",
  "paddingLeft",
  "paddingRight",
  "paddingTop",
  // non-standard
  "tabSize",
  "textIndent",
  // non-standard
  "textRendering",
  "textTransform",
  "width",
  "wordBreak"
], S_ = !!document.documentElement.currentStyle, E_ = function(t) {
  var n = window.getComputedStyle(t);
  if (n === null)
    return null;
  var r = x_(w_, n), i = r.boxSizing;
  if (i === "")
    return null;
  S_ && i === "border-box" && (r.width = parseFloat(r.width) + parseFloat(r.borderRightWidth) + parseFloat(r.borderLeftWidth) + parseFloat(r.paddingRight) + parseFloat(r.paddingLeft) + "px");
  var o = parseFloat(r.paddingBottom) + parseFloat(r.paddingTop), a = parseFloat(r.borderBottomWidth) + parseFloat(r.borderTopWidth);
  return {
    sizingStyle: r,
    paddingSize: o,
    borderSize: a
  };
}, k_ = E_;
function ow(e, t, n) {
  var r = m_(n);
  k.useLayoutEffect(function() {
    var i = function(a) {
      return r.current(a);
    };
    if (e)
      return e.addEventListener(t, i), function() {
        return e.removeEventListener(t, i);
      };
  }, []);
}
var C_ = function(t) {
  ow(window, "resize", t);
}, $_ = function(t) {
  ow(document.fonts, "loadingdone", t);
}, T_ = ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"], O_ = function(t, n) {
  var r = t.cacheMeasurements, i = t.maxRows, o = t.minRows, a = t.onChange, s = a === void 0 ? lv : a, l = t.onHeightChange, u = l === void 0 ? lv : l, c = h_(t, T_), f = c.value !== void 0, p = k.useRef(null), d = g_(p, n), v = k.useRef(0), h = k.useRef(), g = function() {
    var x = p.current, C = r && h.current ? h.current : k_(x);
    if (C) {
      h.current = C;
      var S = b_(C, x.value || x.placeholder || "x", o, i), E = S[0], T = S[1];
      v.current !== E && (v.current = E, x.style.setProperty("height", E + "px", "important"), u(E, {
        rowHeight: T
      }));
    }
  }, m = function(x) {
    f || g(), s(x);
  };
  return k.useLayoutEffect(g), C_(g), $_(g), /* @__PURE__ */ k.createElement("textarea", yc({}, c, {
    onChange: m,
    ref: d
  }));
}, I_ = /* @__PURE__ */ k.forwardRef(O_);
const R_ = ({
  inputRef: e,
  composerPlaceholder: t,
  composerDisabled: n,
  textInput: r,
  historyIndex: i,
  setTextInput: o,
  setHistoryIndex: a,
  sendComposerMessage: s
}) => {
  const l = rx((c) => c.messageHistory), { input: u } = Te.composer;
  return /* @__PURE__ */ $.jsx(
    I_,
    {
      ...u,
      "aria-label": "Message Input",
      ref: e,
      placeholder: t ?? "Type your message...",
      disabled: n,
      value: r,
      "data-has-value": !!r,
      onChange: (c) => o(c.target.value),
      maxRows: 5,
      onKeyDown: (c) => {
        n || (c.key === "Enter" && c.shiftKey ? (c.preventDefault(), o(`${r}
`)) : c.key === "Enter" && (c.preventDefault(), s()), c.key === "ArrowUp" && (c.preventDefault(), i < l.length - 1 && o(l[i + 1] ?? ""), a(Math.min(i + 1, l.length - 1))), c.key === "ArrowDown" && (c.preventDefault(), o(i === 0 ? "" : l[i - 1] ?? ""), a(Math.max(i - 1, -1))));
      }
    }
  );
}, P_ = ({ disabled: e, setTextInput: t }) => {
  const [n, r] = ge(!1), i = Ve(null), { voiceButton: o } = Te.composer, a = window.SpeechRecognition || window.webkitSpeechRecognition, s = () => {
    i.current || (i.current = new a());
    const l = i.current;
    l && (l.continuous = !0, l.onresult = (u) => {
      var f, p, d;
      const c = ((d = (p = (f = u.results) == null ? void 0 : f[0]) == null ? void 0 : p[0]) == null ? void 0 : d.transcript) ?? "";
      t(c ?? ""), l.stop(), r(!1);
    }, n ? (l.stop(), r(!1)) : (l.start(), r(!0)));
  };
  if (a)
    return /* @__PURE__ */ $.jsx(
      eP,
      {
        ...o,
        tabIndex: 0,
        "aria-label": "Voice Input Button",
        role: "button",
        "data-show": !e,
        "data-listens": !!n,
        onClick: s
      }
    );
}, A_ = fs(
  Ot(
    ({
      className: e,
      inputRef: t,
      disableComposer: n,
      isReadOnly: r,
      allowFileUpload: i,
      connected: o,
      composerPlaceholder: a,
      footer: s,
      sendMessage: l,
      uploadFile: u,
      ...c
    }, f) => {
      const { composer: p } = Te, d = n || r || !o, [v, h] = ge(""), [g, m] = ge(-1), b = Fi((j) => j.files), x = Fi((j) => j.setFiles), C = Fi((j) => j.deleteFile), S = Fi((j) => j.uploadFile), E = rx((j) => j.addMessageToHistory), T = !!v || b.filter((j) => j.status === "uploaded").length > 0, N = () => {
        const j = b.filter((V) => V.status === "uploaded");
        if (!j.length && !v) return;
        const O = (j == null ? void 0 : j.map((V) => {
          const L = V.url, I = V.type;
          return {
            video: { type: "video", videoUrl: L },
            audio: { type: "audio", audioUrl: L },
            image: { type: "image", imageUrl: L }
          }[I] ?? { title: V.name, type: "file", fileUrl: L };
        })) ?? [];
        v && O.push({ type: "text", text: v });
        let _;
        O.length == 1 ? _ = O[0] : _ = {
          type: "bloc",
          items: O.map((L) => {
            const { type: I, ...A } = L;
            return {
              type: I,
              payload: A
            };
          })
        }, l == null || l(_), x([]), h(""), E(v), m(-1);
      };
      return r ? null : /* @__PURE__ */ $.jsxs($.Fragment, { children: [
        /* @__PURE__ */ $.jsxs(
          "div",
          {
            "data-disabled": d,
            ...c,
            className: no(p.container.className, e),
            ref: f,
            children: [
              b.length > 0 && /* @__PURE__ */ $.jsx("div", { ...p == null ? void 0 : p.fileContainer, children: b.map((j) => /* @__PURE__ */ $.jsx(p_, { ...j, removeFile: C }, j.name)) }),
              /* @__PURE__ */ $.jsxs("div", { ...p.inputContainer, children: [
                i && /* @__PURE__ */ $.jsx(
                  d_,
                  {
                    disabled: d || !u,
                    onFileSelected: (j) => {
                      u && S(j, u);
                    }
                  }
                ),
                /* @__PURE__ */ $.jsx(
                  R_,
                  {
                    inputRef: t,
                    composerPlaceholder: a,
                    composerDisabled: d,
                    textInput: v,
                    historyIndex: g,
                    setTextInput: h,
                    setHistoryIndex: m,
                    sendComposerMessage: N
                  }
                ),
                !d && /* @__PURE__ */ $.jsxs($.Fragment, { children: [
                  /* @__PURE__ */ $.jsx(
                    FR,
                    {
                      ...p.sendbutton,
                      role: "button",
                      tabIndex: 0,
                      "aria-label": "Send Message Button",
                      "data-show": T,
                      onClick: () => N()
                    }
                  ),
                  /* @__PURE__ */ $.jsx(P_, { disabled: T, setTextInput: h })
                ] })
              ] })
            ]
          }
        ),
        /* @__PURE__ */ $.jsx(Cb, { allowedElements: ["a", "strong", "code", "em", "p", "span"], ...p.footer, children: s })
      ] });
    }
  )
);
var bc = { exports: {} }, ea = { exports: {} }, _e = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uv;
function D_() {
  if (uv) return _e;
  uv = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, d = e ? Symbol.for("react.memo") : 60115, v = e ? Symbol.for("react.lazy") : 60116, h = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, m = e ? Symbol.for("react.responder") : 60118, b = e ? Symbol.for("react.scope") : 60119;
  function x(S) {
    if (typeof S == "object" && S !== null) {
      var E = S.$$typeof;
      switch (E) {
        case t:
          switch (S = S.type, S) {
            case l:
            case u:
            case r:
            case o:
            case i:
            case f:
              return S;
            default:
              switch (S = S && S.$$typeof, S) {
                case s:
                case c:
                case v:
                case d:
                case a:
                  return S;
                default:
                  return E;
              }
          }
        case n:
          return E;
      }
    }
  }
  function C(S) {
    return x(S) === u;
  }
  return _e.AsyncMode = l, _e.ConcurrentMode = u, _e.ContextConsumer = s, _e.ContextProvider = a, _e.Element = t, _e.ForwardRef = c, _e.Fragment = r, _e.Lazy = v, _e.Memo = d, _e.Portal = n, _e.Profiler = o, _e.StrictMode = i, _e.Suspense = f, _e.isAsyncMode = function(S) {
    return C(S) || x(S) === l;
  }, _e.isConcurrentMode = C, _e.isContextConsumer = function(S) {
    return x(S) === s;
  }, _e.isContextProvider = function(S) {
    return x(S) === a;
  }, _e.isElement = function(S) {
    return typeof S == "object" && S !== null && S.$$typeof === t;
  }, _e.isForwardRef = function(S) {
    return x(S) === c;
  }, _e.isFragment = function(S) {
    return x(S) === r;
  }, _e.isLazy = function(S) {
    return x(S) === v;
  }, _e.isMemo = function(S) {
    return x(S) === d;
  }, _e.isPortal = function(S) {
    return x(S) === n;
  }, _e.isProfiler = function(S) {
    return x(S) === o;
  }, _e.isStrictMode = function(S) {
    return x(S) === i;
  }, _e.isSuspense = function(S) {
    return x(S) === f;
  }, _e.isValidElementType = function(S) {
    return typeof S == "string" || typeof S == "function" || S === r || S === u || S === o || S === i || S === f || S === p || typeof S == "object" && S !== null && (S.$$typeof === v || S.$$typeof === d || S.$$typeof === a || S.$$typeof === s || S.$$typeof === c || S.$$typeof === g || S.$$typeof === m || S.$$typeof === b || S.$$typeof === h);
  }, _e.typeOf = x, _e;
}
var Me = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cv;
function __() {
  return cv || (cv = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, d = e ? Symbol.for("react.memo") : 60115, v = e ? Symbol.for("react.lazy") : 60116, h = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, m = e ? Symbol.for("react.responder") : 60118, b = e ? Symbol.for("react.scope") : 60119;
    function x(H) {
      return typeof H == "string" || typeof H == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      H === r || H === u || H === o || H === i || H === f || H === p || typeof H == "object" && H !== null && (H.$$typeof === v || H.$$typeof === d || H.$$typeof === a || H.$$typeof === s || H.$$typeof === c || H.$$typeof === g || H.$$typeof === m || H.$$typeof === b || H.$$typeof === h);
    }
    function C(H) {
      if (typeof H == "object" && H !== null) {
        var re = H.$$typeof;
        switch (re) {
          case t:
            var se = H.type;
            switch (se) {
              case l:
              case u:
              case r:
              case o:
              case i:
              case f:
                return se;
              default:
                var fe = se && se.$$typeof;
                switch (fe) {
                  case s:
                  case c:
                  case v:
                  case d:
                  case a:
                    return fe;
                  default:
                    return re;
                }
            }
          case n:
            return re;
        }
      }
    }
    var S = l, E = u, T = s, N = a, j = t, O = c, _ = r, V = v, L = d, I = n, A = o, M = i, q = f, W = !1;
    function P(H) {
      return W || (W = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), y(H) || C(H) === l;
    }
    function y(H) {
      return C(H) === u;
    }
    function D(H) {
      return C(H) === s;
    }
    function B(H) {
      return C(H) === a;
    }
    function w(H) {
      return typeof H == "object" && H !== null && H.$$typeof === t;
    }
    function U(H) {
      return C(H) === c;
    }
    function Y(H) {
      return C(H) === r;
    }
    function K(H) {
      return C(H) === v;
    }
    function G(H) {
      return C(H) === d;
    }
    function Z(H) {
      return C(H) === n;
    }
    function Q(H) {
      return C(H) === o;
    }
    function X(H) {
      return C(H) === i;
    }
    function J(H) {
      return C(H) === f;
    }
    Me.AsyncMode = S, Me.ConcurrentMode = E, Me.ContextConsumer = T, Me.ContextProvider = N, Me.Element = j, Me.ForwardRef = O, Me.Fragment = _, Me.Lazy = V, Me.Memo = L, Me.Portal = I, Me.Profiler = A, Me.StrictMode = M, Me.Suspense = q, Me.isAsyncMode = P, Me.isConcurrentMode = y, Me.isContextConsumer = D, Me.isContextProvider = B, Me.isElement = w, Me.isForwardRef = U, Me.isFragment = Y, Me.isLazy = K, Me.isMemo = G, Me.isPortal = Z, Me.isProfiler = Q, Me.isStrictMode = X, Me.isSuspense = J, Me.isValidElementType = x, Me.typeOf = C;
  }()), Me;
}
var fv;
function Ts() {
  return fv || (fv = 1, process.env.NODE_ENV === "production" ? ea.exports = D_() : ea.exports = __()), ea.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var jl, dv;
function aw() {
  if (dv) return jl;
  dv = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(o) {
    if (o == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(o);
  }
  function i() {
    try {
      if (!Object.assign)
        return !1;
      var o = new String("abc");
      if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return jl = i() ? Object.assign : function(o, a) {
    for (var s, l = r(o), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var f in s)
        t.call(s, f) && (l[f] = s[f]);
      if (e) {
        u = e(s);
        for (var p = 0; p < u.length; p++)
          n.call(s, u[p]) && (l[u[p]] = s[u[p]]);
      }
    }
    return l;
  }, jl;
}
var Nl, pv;
function Jf() {
  if (pv) return Nl;
  pv = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Nl = e, Nl;
}
var Ll, hv;
function sw() {
  return hv || (hv = 1, Ll = Function.call.bind(Object.prototype.hasOwnProperty)), Ll;
}
var Fl, vv;
function M_() {
  if (vv) return Fl;
  vv = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Jf(), n = {}, r = sw();
    e = function(o) {
      var a = "Warning: " + o;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function i(o, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in o)
        if (r(o, c)) {
          var f;
          try {
            if (typeof o[c] != "function") {
              var p = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            f = o[c](a, c, l, s, null, t);
          } catch (v) {
            f = v;
          }
          if (f && !(f instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof f + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), f instanceof Error && !(f.message in n)) {
            n[f.message] = !0;
            var d = u ? u() : "";
            e(
              "Failed " + s + " type: " + f.message + (d ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Fl = i, Fl;
}
var Bl, mv;
function j_() {
  if (mv) return Bl;
  mv = 1;
  var e = Ts(), t = aw(), n = Jf(), r = sw(), i = M_(), o = function() {
  };
  process.env.NODE_ENV !== "production" && (o = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Bl = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function f(y) {
      var D = y && (u && y[u] || y[c]);
      if (typeof D == "function")
        return D;
    }
    var p = "<<anonymous>>", d = {
      array: m("array"),
      bigint: m("bigint"),
      bool: m("boolean"),
      func: m("function"),
      number: m("number"),
      object: m("object"),
      string: m("string"),
      symbol: m("symbol"),
      any: b(),
      arrayOf: x,
      element: C(),
      elementType: S(),
      instanceOf: E,
      node: O(),
      objectOf: N,
      oneOf: T,
      oneOfType: j,
      shape: V,
      exact: L
    };
    function v(y, D) {
      return y === D ? y !== 0 || 1 / y === 1 / D : y !== y && D !== D;
    }
    function h(y, D) {
      this.message = y, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    h.prototype = Error.prototype;
    function g(y) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, B = 0;
      function w(Y, K, G, Z, Q, X, J) {
        if (Z = Z || p, X = X || G, J !== n) {
          if (l) {
            var H = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw H.name = "Invariant Violation", H;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var re = Z + ":" + G;
            !D[re] && // Avoid spamming the console because they are often not actionable except for lib authors
            B < 3 && (o(
              "You are manually calling a React.PropTypes validation function for the `" + X + "` prop on `" + Z + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[re] = !0, B++);
          }
        }
        return K[G] == null ? Y ? K[G] === null ? new h("The " + Q + " `" + X + "` is marked as required " + ("in `" + Z + "`, but its value is `null`.")) : new h("The " + Q + " `" + X + "` is marked as required in " + ("`" + Z + "`, but its value is `undefined`.")) : null : y(K, G, Z, Q, X);
      }
      var U = w.bind(null, !1);
      return U.isRequired = w.bind(null, !0), U;
    }
    function m(y) {
      function D(B, w, U, Y, K, G) {
        var Z = B[w], Q = M(Z);
        if (Q !== y) {
          var X = q(Z);
          return new h(
            "Invalid " + Y + " `" + K + "` of type " + ("`" + X + "` supplied to `" + U + "`, expected ") + ("`" + y + "`."),
            { expectedType: y }
          );
        }
        return null;
      }
      return g(D);
    }
    function b() {
      return g(a);
    }
    function x(y) {
      function D(B, w, U, Y, K) {
        if (typeof y != "function")
          return new h("Property `" + K + "` of component `" + U + "` has invalid PropType notation inside arrayOf.");
        var G = B[w];
        if (!Array.isArray(G)) {
          var Z = M(G);
          return new h("Invalid " + Y + " `" + K + "` of type " + ("`" + Z + "` supplied to `" + U + "`, expected an array."));
        }
        for (var Q = 0; Q < G.length; Q++) {
          var X = y(G, Q, U, Y, K + "[" + Q + "]", n);
          if (X instanceof Error)
            return X;
        }
        return null;
      }
      return g(D);
    }
    function C() {
      function y(D, B, w, U, Y) {
        var K = D[B];
        if (!s(K)) {
          var G = M(K);
          return new h("Invalid " + U + " `" + Y + "` of type " + ("`" + G + "` supplied to `" + w + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(y);
    }
    function S() {
      function y(D, B, w, U, Y) {
        var K = D[B];
        if (!e.isValidElementType(K)) {
          var G = M(K);
          return new h("Invalid " + U + " `" + Y + "` of type " + ("`" + G + "` supplied to `" + w + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(y);
    }
    function E(y) {
      function D(B, w, U, Y, K) {
        if (!(B[w] instanceof y)) {
          var G = y.name || p, Z = P(B[w]);
          return new h("Invalid " + Y + " `" + K + "` of type " + ("`" + Z + "` supplied to `" + U + "`, expected ") + ("instance of `" + G + "`."));
        }
        return null;
      }
      return g(D);
    }
    function T(y) {
      if (!Array.isArray(y))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? o(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : o("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(B, w, U, Y, K) {
        for (var G = B[w], Z = 0; Z < y.length; Z++)
          if (v(G, y[Z]))
            return null;
        var Q = JSON.stringify(y, function(J, H) {
          var re = q(H);
          return re === "symbol" ? String(H) : H;
        });
        return new h("Invalid " + Y + " `" + K + "` of value `" + String(G) + "` " + ("supplied to `" + U + "`, expected one of " + Q + "."));
      }
      return g(D);
    }
    function N(y) {
      function D(B, w, U, Y, K) {
        if (typeof y != "function")
          return new h("Property `" + K + "` of component `" + U + "` has invalid PropType notation inside objectOf.");
        var G = B[w], Z = M(G);
        if (Z !== "object")
          return new h("Invalid " + Y + " `" + K + "` of type " + ("`" + Z + "` supplied to `" + U + "`, expected an object."));
        for (var Q in G)
          if (r(G, Q)) {
            var X = y(G, Q, U, Y, K + "." + Q, n);
            if (X instanceof Error)
              return X;
          }
        return null;
      }
      return g(D);
    }
    function j(y) {
      if (!Array.isArray(y))
        return process.env.NODE_ENV !== "production" && o("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < y.length; D++) {
        var B = y[D];
        if (typeof B != "function")
          return o(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + W(B) + " at index " + D + "."
          ), a;
      }
      function w(U, Y, K, G, Z) {
        for (var Q = [], X = 0; X < y.length; X++) {
          var J = y[X], H = J(U, Y, K, G, Z, n);
          if (H == null)
            return null;
          H.data && r(H.data, "expectedType") && Q.push(H.data.expectedType);
        }
        var re = Q.length > 0 ? ", expected one of type [" + Q.join(", ") + "]" : "";
        return new h("Invalid " + G + " `" + Z + "` supplied to " + ("`" + K + "`" + re + "."));
      }
      return g(w);
    }
    function O() {
      function y(D, B, w, U, Y) {
        return I(D[B]) ? null : new h("Invalid " + U + " `" + Y + "` supplied to " + ("`" + w + "`, expected a ReactNode."));
      }
      return g(y);
    }
    function _(y, D, B, w, U) {
      return new h(
        (y || "React class") + ": " + D + " type `" + B + "." + w + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + U + "`."
      );
    }
    function V(y) {
      function D(B, w, U, Y, K) {
        var G = B[w], Z = M(G);
        if (Z !== "object")
          return new h("Invalid " + Y + " `" + K + "` of type `" + Z + "` " + ("supplied to `" + U + "`, expected `object`."));
        for (var Q in y) {
          var X = y[Q];
          if (typeof X != "function")
            return _(U, Y, K, Q, q(X));
          var J = X(G, Q, U, Y, K + "." + Q, n);
          if (J)
            return J;
        }
        return null;
      }
      return g(D);
    }
    function L(y) {
      function D(B, w, U, Y, K) {
        var G = B[w], Z = M(G);
        if (Z !== "object")
          return new h("Invalid " + Y + " `" + K + "` of type `" + Z + "` " + ("supplied to `" + U + "`, expected `object`."));
        var Q = t({}, B[w], y);
        for (var X in Q) {
          var J = y[X];
          if (r(y, X) && typeof J != "function")
            return _(U, Y, K, X, q(J));
          if (!J)
            return new h(
              "Invalid " + Y + " `" + K + "` key `" + X + "` supplied to `" + U + "`.\nBad object: " + JSON.stringify(B[w], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(y), null, "  ")
            );
          var H = J(G, X, U, Y, K + "." + X, n);
          if (H)
            return H;
        }
        return null;
      }
      return g(D);
    }
    function I(y) {
      switch (typeof y) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !y;
        case "object":
          if (Array.isArray(y))
            return y.every(I);
          if (y === null || s(y))
            return !0;
          var D = f(y);
          if (D) {
            var B = D.call(y), w;
            if (D !== y.entries) {
              for (; !(w = B.next()).done; )
                if (!I(w.value))
                  return !1;
            } else
              for (; !(w = B.next()).done; ) {
                var U = w.value;
                if (U && !I(U[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function A(y, D) {
      return y === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function M(y) {
      var D = typeof y;
      return Array.isArray(y) ? "array" : y instanceof RegExp ? "object" : A(D, y) ? "symbol" : D;
    }
    function q(y) {
      if (typeof y > "u" || y === null)
        return "" + y;
      var D = M(y);
      if (D === "object") {
        if (y instanceof Date)
          return "date";
        if (y instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function W(y) {
      var D = q(y);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function P(y) {
      return !y.constructor || !y.constructor.name ? p : y.constructor.name;
    }
    return d.checkPropTypes = i, d.resetWarningCache = i.resetWarningCache, d.PropTypes = d, d;
  }, Bl;
}
var zl, gv;
function N_() {
  if (gv) return zl;
  gv = 1;
  var e = Jf();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, zl = function() {
    function r(a, s, l, u, c, f) {
      if (f !== e) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var o = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return o.PropTypes = o, o;
  }, zl;
}
if (process.env.NODE_ENV !== "production") {
  var L_ = Ts(), F_ = !0;
  bc.exports = j_()(L_.isElement, F_);
} else
  bc.exports = N_()();
var B_ = bc.exports;
const Be = /* @__PURE__ */ Ce(B_);
var z_ = /* @__PURE__ */ new Map([
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
  ["aac", "audio/aac"],
  ["abw", "application/x-abiword"],
  ["arc", "application/x-freearc"],
  ["avif", "image/avif"],
  ["avi", "video/x-msvideo"],
  ["azw", "application/vnd.amazon.ebook"],
  ["bin", "application/octet-stream"],
  ["bmp", "image/bmp"],
  ["bz", "application/x-bzip"],
  ["bz2", "application/x-bzip2"],
  ["cda", "application/x-cdf"],
  ["csh", "application/x-csh"],
  ["css", "text/css"],
  ["csv", "text/csv"],
  ["doc", "application/msword"],
  ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
  ["eot", "application/vnd.ms-fontobject"],
  ["epub", "application/epub+zip"],
  ["gz", "application/gzip"],
  ["gif", "image/gif"],
  ["heic", "image/heic"],
  ["heif", "image/heif"],
  ["htm", "text/html"],
  ["html", "text/html"],
  ["ico", "image/vnd.microsoft.icon"],
  ["ics", "text/calendar"],
  ["jar", "application/java-archive"],
  ["jpeg", "image/jpeg"],
  ["jpg", "image/jpeg"],
  ["js", "text/javascript"],
  ["json", "application/json"],
  ["jsonld", "application/ld+json"],
  ["mid", "audio/midi"],
  ["midi", "audio/midi"],
  ["mjs", "text/javascript"],
  ["mp3", "audio/mpeg"],
  ["mp4", "video/mp4"],
  ["mpeg", "video/mpeg"],
  ["mpkg", "application/vnd.apple.installer+xml"],
  ["odp", "application/vnd.oasis.opendocument.presentation"],
  ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
  ["odt", "application/vnd.oasis.opendocument.text"],
  ["oga", "audio/ogg"],
  ["ogv", "video/ogg"],
  ["ogx", "application/ogg"],
  ["opus", "audio/opus"],
  ["otf", "font/otf"],
  ["png", "image/png"],
  ["pdf", "application/pdf"],
  ["php", "application/x-httpd-php"],
  ["ppt", "application/vnd.ms-powerpoint"],
  ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
  ["rar", "application/vnd.rar"],
  ["rtf", "application/rtf"],
  ["sh", "application/x-sh"],
  ["svg", "image/svg+xml"],
  ["swf", "application/x-shockwave-flash"],
  ["tar", "application/x-tar"],
  ["tif", "image/tiff"],
  ["tiff", "image/tiff"],
  ["ts", "video/mp2t"],
  ["ttf", "font/ttf"],
  ["txt", "text/plain"],
  ["vsd", "application/vnd.visio"],
  ["wav", "audio/wav"],
  ["weba", "audio/webm"],
  ["webm", "video/webm"],
  ["webp", "image/webp"],
  ["woff", "font/woff"],
  ["woff2", "font/woff2"],
  ["xhtml", "application/xhtml+xml"],
  ["xls", "application/vnd.ms-excel"],
  ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
  ["xml", "application/xml"],
  ["xul", "application/vnd.mozilla.xul+xml"],
  ["zip", "application/zip"],
  ["7z", "application/x-7z-compressed"],
  // Others
  ["mkv", "video/x-matroska"],
  ["mov", "video/quicktime"],
  ["msg", "application/vnd.ms-outlook"]
]);
function wo(e, t) {
  var n = W_(e);
  if (typeof n.path != "string") {
    var r = e.webkitRelativePath;
    Object.defineProperty(n, "path", {
      value: typeof t == "string" ? t : typeof r == "string" && r.length > 0 ? r : e.name,
      writable: !1,
      configurable: !1,
      enumerable: !0
    });
  }
  return n;
}
function W_(e) {
  var t = e.name, n = t && t.lastIndexOf(".") !== -1;
  if (n && !e.type) {
    var r = t.split(".").pop().toLowerCase(), i = z_.get(r);
    i && Object.defineProperty(e, "type", {
      value: i,
      writable: !1,
      configurable: !1,
      enumerable: !0
    });
  }
  return e;
}
var U_ = [
  // Thumbnail cache files for macOS and Windows
  ".DS_Store",
  "Thumbs.db"
  // Windows
];
function H_(e) {
  return pi(this, void 0, void 0, function() {
    return hi(this, function(t) {
      return Ya(e) && V_(e.dataTransfer) ? [2, Y_(e.dataTransfer, e.type)] : K_(e) ? [2, q_(e)] : Array.isArray(e) && e.every(function(n) {
        return "getFile" in n && typeof n.getFile == "function";
      }) ? [2, G_(e)] : [2, []];
    });
  });
}
function V_(e) {
  return Ya(e);
}
function K_(e) {
  return Ya(e) && Ya(e.target);
}
function Ya(e) {
  return typeof e == "object" && e !== null;
}
function q_(e) {
  return xc(e.target.files).map(function(t) {
    return wo(t);
  });
}
function G_(e) {
  return pi(this, void 0, void 0, function() {
    var t;
    return hi(this, function(n) {
      switch (n.label) {
        case 0:
          return [4, Promise.all(e.map(function(r) {
            return r.getFile();
          }))];
        case 1:
          return t = n.sent(), [2, t.map(function(r) {
            return wo(r);
          })];
      }
    });
  });
}
function Y_(e, t) {
  return pi(this, void 0, void 0, function() {
    var n, r;
    return hi(this, function(i) {
      switch (i.label) {
        case 0:
          return e.items ? (n = xc(e.items).filter(function(o) {
            return o.kind === "file";
          }), t !== "drop" ? [2, n] : [4, Promise.all(n.map(X_))]) : [3, 2];
        case 1:
          return r = i.sent(), [2, yv(lw(r))];
        case 2:
          return [2, yv(xc(e.files).map(function(o) {
            return wo(o);
          }))];
      }
    });
  });
}
function yv(e) {
  return e.filter(function(t) {
    return U_.indexOf(t.name) === -1;
  });
}
function xc(e) {
  if (e === null)
    return [];
  for (var t = [], n = 0; n < e.length; n++) {
    var r = e[n];
    t.push(r);
  }
  return t;
}
function X_(e) {
  if (typeof e.webkitGetAsEntry != "function")
    return bv(e);
  var t = e.webkitGetAsEntry();
  return t && t.isDirectory ? uw(t) : bv(e);
}
function lw(e) {
  return e.reduce(function(t, n) {
    return pc(pc([], Ah(t), !1), Ah(Array.isArray(n) ? lw(n) : [n]), !1);
  }, []);
}
function bv(e) {
  var t = e.getAsFile();
  if (!t)
    return Promise.reject("".concat(e, " is not a File"));
  var n = wo(t);
  return Promise.resolve(n);
}
function J_(e) {
  return pi(this, void 0, void 0, function() {
    return hi(this, function(t) {
      return [2, e.isDirectory ? uw(e) : Z_(e)];
    });
  });
}
function uw(e) {
  var t = e.createReader();
  return new Promise(function(n, r) {
    var i = [];
    function o() {
      var a = this;
      t.readEntries(function(s) {
        return pi(a, void 0, void 0, function() {
          var l, u, c;
          return hi(this, function(f) {
            switch (f.label) {
              case 0:
                if (s.length) return [3, 5];
                f.label = 1;
              case 1:
                return f.trys.push([1, 3, , 4]), [4, Promise.all(i)];
              case 2:
                return l = f.sent(), n(l), [3, 4];
              case 3:
                return u = f.sent(), r(u), [3, 4];
              case 4:
                return [3, 6];
              case 5:
                c = Promise.all(s.map(J_)), i.push(c), o(), f.label = 6;
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, function(s) {
        r(s);
      });
    }
    o();
  });
}
function Z_(e) {
  return pi(this, void 0, void 0, function() {
    return hi(this, function(t) {
      return [2, new Promise(function(n, r) {
        e.file(function(i) {
          var o = wo(i, e.fullPath);
          n(o);
        }, function(i) {
          r(i);
        });
      })];
    });
  });
}
var Q_ = function(e, t) {
  if (e && t) {
    var n = Array.isArray(t) ? t : t.split(",");
    if (n.length === 0)
      return !0;
    var r = e.name || "", i = (e.type || "").toLowerCase(), o = i.replace(/\/.*$/, "");
    return n.some(function(a) {
      var s = a.trim().toLowerCase();
      return s.charAt(0) === "." ? r.toLowerCase().endsWith(s) : s.endsWith("/*") ? o === s.replace(/\/.*$/, "") : i === s;
    });
  }
  return !0;
};
function xv(e) {
  return nM(e) || tM(e) || fw(e) || eM();
}
function eM() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function tM(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function nM(e) {
  if (Array.isArray(e)) return wc(e);
}
function wv(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wv(Object(n), !0).forEach(function(r) {
      cw(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wv(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function cw(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function ro(e, t) {
  return oM(e) || iM(e, t) || fw(e, t) || rM();
}
function rM() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function fw(e, t) {
  if (e) {
    if (typeof e == "string") return wc(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return wc(e, t);
  }
}
function wc(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function iM(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r = [], i = !0, o = !1, a, s;
    try {
      for (n = n.call(e); !(i = (a = n.next()).done) && (r.push(a.value), !(t && r.length === t)); i = !0)
        ;
    } catch (l) {
      o = !0, s = l;
    } finally {
      try {
        !i && n.return != null && n.return();
      } finally {
        if (o) throw s;
      }
    }
    return r;
  }
}
function oM(e) {
  if (Array.isArray(e)) return e;
}
var aM = "file-invalid-type", sM = "file-too-large", lM = "file-too-small", uM = "too-many-files", cM = function(t) {
  t = Array.isArray(t) && t.length === 1 ? t[0] : t;
  var n = Array.isArray(t) ? "one of ".concat(t.join(", ")) : t;
  return {
    code: aM,
    message: "File type must be ".concat(n)
  };
}, Ev = function(t) {
  return {
    code: sM,
    message: "File is larger than ".concat(t, " ").concat(t === 1 ? "byte" : "bytes")
  };
}, kv = function(t) {
  return {
    code: lM,
    message: "File is smaller than ".concat(t, " ").concat(t === 1 ? "byte" : "bytes")
  };
}, fM = {
  code: uM,
  message: "Too many files"
};
function dw(e, t) {
  var n = e.type === "application/x-moz-file" || Q_(e, t);
  return [n, n ? null : cM(t)];
}
function pw(e, t, n) {
  if (dr(e.size))
    if (dr(t) && dr(n)) {
      if (e.size > n) return [!1, Ev(n)];
      if (e.size < t) return [!1, kv(t)];
    } else {
      if (dr(t) && e.size < t) return [!1, kv(t)];
      if (dr(n) && e.size > n) return [!1, Ev(n)];
    }
  return [!0, null];
}
function dr(e) {
  return e != null;
}
function dM(e) {
  var t = e.files, n = e.accept, r = e.minSize, i = e.maxSize, o = e.multiple, a = e.maxFiles, s = e.validator;
  return !o && t.length > 1 || o && a >= 1 && t.length > a ? !1 : t.every(function(l) {
    var u = dw(l, n), c = ro(u, 1), f = c[0], p = pw(l, r, i), d = ro(p, 1), v = d[0], h = s ? s(l) : null;
    return f && v && !h;
  });
}
function Xa(e) {
  return typeof e.isPropagationStopped == "function" ? e.isPropagationStopped() : typeof e.cancelBubble < "u" ? e.cancelBubble : !1;
}
function ta(e) {
  return e.dataTransfer ? Array.prototype.some.call(e.dataTransfer.types, function(t) {
    return t === "Files" || t === "application/x-moz-file";
  }) : !!e.target && !!e.target.files;
}
function Cv(e) {
  e.preventDefault();
}
function pM(e) {
  return e.indexOf("MSIE") !== -1 || e.indexOf("Trident/") !== -1;
}
function hM(e) {
  return e.indexOf("Edge/") !== -1;
}
function vM() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.navigator.userAgent;
  return pM(e) || hM(e);
}
function vn() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return function(r) {
    for (var i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)
      o[a - 1] = arguments[a];
    return t.some(function(s) {
      return !Xa(r) && s && s.apply(void 0, [r].concat(o)), Xa(r);
    });
  };
}
function mM() {
  return "showOpenFilePicker" in window;
}
function gM(e) {
  if (dr(e)) {
    var t = Object.entries(e).filter(function(n) {
      var r = ro(n, 2), i = r[0], o = r[1], a = !0;
      return hw(i) || (console.warn('Skipped "'.concat(i, '" because it is not a valid MIME type. Check https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types for a list of valid MIME types.')), a = !1), (!Array.isArray(o) || !o.every(vw)) && (console.warn('Skipped "'.concat(i, '" because an invalid file extension was provided.')), a = !1), a;
    }).reduce(function(n, r) {
      var i = ro(r, 2), o = i[0], a = i[1];
      return Sv(Sv({}, n), {}, cw({}, o, a));
    }, {});
    return [{
      // description is required due to https://crbug.com/1264708
      description: "Files",
      accept: t
    }];
  }
  return e;
}
function yM(e) {
  if (dr(e))
    return Object.entries(e).reduce(function(t, n) {
      var r = ro(n, 2), i = r[0], o = r[1];
      return [].concat(xv(t), [i], xv(o));
    }, []).filter(function(t) {
      return hw(t) || vw(t);
    }).join(",");
}
function bM(e) {
  return e instanceof DOMException && (e.name === "AbortError" || e.code === e.ABORT_ERR);
}
function xM(e) {
  return e instanceof DOMException && (e.name === "SecurityError" || e.code === e.SECURITY_ERR);
}
function hw(e) {
  return e === "audio/*" || e === "video/*" || e === "image/*" || e === "text/*" || /\w+\/[-+.\w]+/g.test(e);
}
function vw(e) {
  return /^.*\.[\w]+$/.test(e);
}
var wM = ["children"], SM = ["open"], EM = ["refKey", "role", "onKeyDown", "onFocus", "onBlur", "onClick", "onDragEnter", "onDragOver", "onDragLeave", "onDrop"], kM = ["refKey", "onChange", "onClick"];
function CM(e) {
  return OM(e) || TM(e) || mw(e) || $M();
}
function $M() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function TM(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function OM(e) {
  if (Array.isArray(e)) return Sc(e);
}
function Wl(e, t) {
  return PM(e) || RM(e, t) || mw(e, t) || IM();
}
function IM() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function mw(e, t) {
  if (e) {
    if (typeof e == "string") return Sc(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Sc(e, t);
  }
}
function Sc(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function RM(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r = [], i = !0, o = !1, a, s;
    try {
      for (n = n.call(e); !(i = (a = n.next()).done) && (r.push(a.value), !(t && r.length === t)); i = !0)
        ;
    } catch (l) {
      o = !0, s = l;
    } finally {
      try {
        !i && n.return != null && n.return();
      } finally {
        if (o) throw s;
      }
    }
    return r;
  }
}
function PM(e) {
  if (Array.isArray(e)) return e;
}
function $v(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Je(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $v(Object(n), !0).forEach(function(r) {
      Ec(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $v(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Ec(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function Ja(e, t) {
  if (e == null) return {};
  var n = AM(e, t), r, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function AM(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var Os = /* @__PURE__ */ Ot(function(e, t) {
  var n = e.children, r = Ja(e, wM), i = DM(r), o = i.open, a = Ja(i, SM);
  return rE(t, function() {
    return {
      open: o
    };
  }, [o]), /* @__PURE__ */ Ne.createElement(iE, null, n(Je(Je({}, a), {}, {
    open: o
  })));
});
Os.displayName = "Dropzone";
var gw = {
  disabled: !1,
  getFilesFromEvent: H_,
  maxSize: 1 / 0,
  minSize: 0,
  multiple: !0,
  maxFiles: 0,
  preventDropOnDocument: !0,
  noClick: !1,
  noKeyboard: !1,
  noDrag: !1,
  noDragEventsBubbling: !1,
  validator: null,
  useFsAccessApi: !0,
  autoFocus: !1
};
Os.defaultProps = gw;
Os.propTypes = {
  /**
   * Render function that exposes the dropzone state and prop getter fns
   *
   * @param {object} params
   * @param {Function} params.getRootProps Returns the props you should apply to the root drop container you render
   * @param {Function} params.getInputProps Returns the props you should apply to hidden file input you render
   * @param {Function} params.open Open the native file selection dialog
   * @param {boolean} params.isFocused Dropzone area is in focus
   * @param {boolean} params.isFileDialogActive File dialog is opened
   * @param {boolean} params.isDragActive Active drag is in progress
   * @param {boolean} params.isDragAccept Dragged files are accepted
   * @param {boolean} params.isDragReject Some dragged files are rejected
   * @param {File[]} params.acceptedFiles Accepted files
   * @param {FileRejection[]} params.fileRejections Rejected files and why they were rejected
   */
  children: Be.func,
  /**
   * Set accepted file types.
   * Checkout https://developer.mozilla.org/en-US/docs/Web/API/window/showOpenFilePicker types option for more information.
   * Keep in mind that mime type determination is not reliable across platforms. CSV files,
   * for example, are reported as text/plain under macOS but as application/vnd.ms-excel under
   * Windows. In some cases there might not be a mime type set at all (https://github.com/react-dropzone/react-dropzone/issues/276).
   */
  accept: Be.objectOf(Be.arrayOf(Be.string)),
  /**
   * Allow drag 'n' drop (or selection from the file dialog) of multiple files
   */
  multiple: Be.bool,
  /**
   * If false, allow dropped items to take over the current browser window
   */
  preventDropOnDocument: Be.bool,
  /**
   * If true, disables click to open the native file selection dialog
   */
  noClick: Be.bool,
  /**
   * If true, disables SPACE/ENTER to open the native file selection dialog.
   * Note that it also stops tracking the focus state.
   */
  noKeyboard: Be.bool,
  /**
   * If true, disables drag 'n' drop
   */
  noDrag: Be.bool,
  /**
   * If true, stops drag event propagation to parents
   */
  noDragEventsBubbling: Be.bool,
  /**
   * Minimum file size (in bytes)
   */
  minSize: Be.number,
  /**
   * Maximum file size (in bytes)
   */
  maxSize: Be.number,
  /**
   * Maximum accepted number of files
   * The default value is 0 which means there is no limitation to how many files are accepted.
   */
  maxFiles: Be.number,
  /**
   * Enable/disable the dropzone
   */
  disabled: Be.bool,
  /**
   * Use this to provide a custom file aggregator
   *
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  getFilesFromEvent: Be.func,
  /**
   * Cb for when closing the file dialog with no selection
   */
  onFileDialogCancel: Be.func,
  /**
   * Cb for when opening the file dialog
   */
  onFileDialogOpen: Be.func,
  /**
   * Set to true to use the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API
   * to open the file picker instead of using an `<input type="file">` click event.
   */
  useFsAccessApi: Be.bool,
  /**
   * Set to true to focus the root element on render
   */
  autoFocus: Be.bool,
  /**
   * Cb for when the `dragenter` event occurs.
   *
   * @param {DragEvent} event
   */
  onDragEnter: Be.func,
  /**
   * Cb for when the `dragleave` event occurs
   *
   * @param {DragEvent} event
   */
  onDragLeave: Be.func,
  /**
   * Cb for when the `dragover` event occurs
   *
   * @param {DragEvent} event
   */
  onDragOver: Be.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that this callback is invoked after the `getFilesFromEvent` callback is done.
   *
   * Files are accepted or rejected based on the `accept`, `multiple`, `minSize` and `maxSize` props.
   * `accept` must be a valid [MIME type](http://www.iana.org/assignments/media-types/media-types.xhtml) according to [input element specification](https://www.w3.org/wiki/HTML/Elements/input/file) or a valid file extension.
   * If `multiple` is set to false and additional files are dropped,
   * all files besides the first will be rejected.
   * Any file which does not have a size in the [`minSize`, `maxSize`] range, will be rejected as well.
   *
   * Note that the `onDrop` callback will always be invoked regardless if the dropped files were accepted or rejected.
   * If you'd like to react to a specific scenario, use the `onDropAccepted`/`onDropRejected` props.
   *
   * `onDrop` will provide you with an array of [File](https://developer.mozilla.org/en-US/docs/Web/API/File) objects which you can then process and send to a server.
   * For example, with [SuperAgent](https://github.com/visionmedia/superagent) as a http/ajax library:
   *
   * ```js
   * function onDrop(acceptedFiles) {
   *   const req = request.post('/upload')
   *   acceptedFiles.forEach(file => {
   *     req.attach(file.name, file)
   *   })
   *   req.end(callback)
   * }
   * ```
   *
   * @param {File[]} acceptedFiles
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  onDrop: Be.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are accepted, this callback is not invoked.
   *
   * @param {File[]} files
   * @param {(DragEvent|Event)} event
   */
  onDropAccepted: Be.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are rejected, this callback is not invoked.
   *
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event
   */
  onDropRejected: Be.func,
  /**
   * Cb for when there's some error from any of the promises.
   *
   * @param {Error} error
   */
  onError: Be.func,
  /**
   * Custom validation function. It must return null if there's no errors.
   * @param {File} file
   * @returns {FileError|FileError[]|null}
   */
  validator: Be.func
};
var kc = {
  isFocused: !1,
  isFileDialogActive: !1,
  isDragActive: !1,
  isDragAccept: !1,
  isDragReject: !1,
  acceptedFiles: [],
  fileRejections: []
};
function DM() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = Je(Je({}, gw), e), n = t.accept, r = t.disabled, i = t.getFilesFromEvent, o = t.maxSize, a = t.minSize, s = t.multiple, l = t.maxFiles, u = t.onDragEnter, c = t.onDragLeave, f = t.onDragOver, p = t.onDrop, d = t.onDropAccepted, v = t.onDropRejected, h = t.onFileDialogCancel, g = t.onFileDialogOpen, m = t.useFsAccessApi, b = t.autoFocus, x = t.preventDropOnDocument, C = t.noClick, S = t.noKeyboard, E = t.noDrag, T = t.noDragEventsBubbling, N = t.onError, j = t.validator, O = ut(function() {
    return yM(n);
  }, [n]), _ = ut(function() {
    return gM(n);
  }, [n]), V = ut(function() {
    return typeof g == "function" ? g : Tv;
  }, [g]), L = ut(function() {
    return typeof h == "function" ? h : Tv;
  }, [h]), I = Ve(null), A = Ve(null), M = oE(_M, kc), q = Wl(M, 2), W = q[0], P = q[1], y = W.isFocused, D = W.isFileDialogActive, B = Ve(typeof window < "u" && window.isSecureContext && m && mM()), w = function() {
    !B.current && D && setTimeout(function() {
      if (A.current) {
        var ue = A.current.files;
        ue.length || (P({
          type: "closeDialog"
        }), L());
      }
    }, 300);
  };
  ft(function() {
    return window.addEventListener("focus", w, !1), function() {
      window.removeEventListener("focus", w, !1);
    };
  }, [A, D, L, B]);
  var U = Ve([]), Y = function(ue) {
    I.current && I.current.contains(ue.target) || (ue.preventDefault(), U.current = []);
  };
  ft(function() {
    return x && (document.addEventListener("dragover", Cv, !1), document.addEventListener("drop", Y, !1)), function() {
      x && (document.removeEventListener("dragover", Cv), document.removeEventListener("drop", Y));
    };
  }, [I, x]), ft(function() {
    return !r && b && I.current && I.current.focus(), function() {
    };
  }, [I, b, r]);
  var K = Oe(function(ie) {
    N ? N(ie) : console.error(ie);
  }, [N]), G = Oe(function(ie) {
    ie.preventDefault(), ie.persist(), nt(ie), U.current = [].concat(CM(U.current), [ie.target]), ta(ie) && Promise.resolve(i(ie)).then(function(ue) {
      if (!(Xa(ie) && !T)) {
        var z = ue.length, F = z > 0 && dM({
          files: ue,
          accept: O,
          minSize: a,
          maxSize: o,
          multiple: s,
          maxFiles: l,
          validator: j
        }), te = z > 0 && !F;
        P({
          isDragAccept: F,
          isDragReject: te,
          isDragActive: !0,
          type: "setDraggedFiles"
        }), u && u(ie);
      }
    }).catch(function(ue) {
      return K(ue);
    });
  }, [i, u, K, T, O, a, o, s, l, j]), Z = Oe(function(ie) {
    ie.preventDefault(), ie.persist(), nt(ie);
    var ue = ta(ie);
    if (ue && ie.dataTransfer)
      try {
        ie.dataTransfer.dropEffect = "copy";
      } catch {
      }
    return ue && f && f(ie), !1;
  }, [f, T]), Q = Oe(function(ie) {
    ie.preventDefault(), ie.persist(), nt(ie);
    var ue = U.current.filter(function(F) {
      return I.current && I.current.contains(F);
    }), z = ue.indexOf(ie.target);
    z !== -1 && ue.splice(z, 1), U.current = ue, !(ue.length > 0) && (P({
      type: "setDraggedFiles",
      isDragActive: !1,
      isDragAccept: !1,
      isDragReject: !1
    }), ta(ie) && c && c(ie));
  }, [I, c, T]), X = Oe(function(ie, ue) {
    var z = [], F = [];
    ie.forEach(function(te) {
      var ae = dw(te, O), ce = Wl(ae, 2), he = ce[0], qe = ce[1], Ge = pw(te, a, o), gt = Wl(Ge, 2), rt = gt[0], Re = gt[1], it = j ? j(te) : null;
      if (he && rt && !it)
        z.push(te);
      else {
        var Qe = [qe, Re];
        it && (Qe = Qe.concat(it)), F.push({
          file: te,
          errors: Qe.filter(function(qt) {
            return qt;
          })
        });
      }
    }), (!s && z.length > 1 || s && l >= 1 && z.length > l) && (z.forEach(function(te) {
      F.push({
        file: te,
        errors: [fM]
      });
    }), z.splice(0)), P({
      acceptedFiles: z,
      fileRejections: F,
      type: "setFiles"
    }), p && p(z, F, ue), F.length > 0 && v && v(F, ue), z.length > 0 && d && d(z, ue);
  }, [P, s, O, a, o, l, p, d, v, j]), J = Oe(function(ie) {
    ie.preventDefault(), ie.persist(), nt(ie), U.current = [], ta(ie) && Promise.resolve(i(ie)).then(function(ue) {
      Xa(ie) && !T || X(ue, ie);
    }).catch(function(ue) {
      return K(ue);
    }), P({
      type: "reset"
    });
  }, [i, X, K, T]), H = Oe(function() {
    if (B.current) {
      P({
        type: "openDialog"
      }), V();
      var ie = {
        multiple: s,
        types: _
      };
      window.showOpenFilePicker(ie).then(function(ue) {
        return i(ue);
      }).then(function(ue) {
        X(ue, null), P({
          type: "closeDialog"
        });
      }).catch(function(ue) {
        bM(ue) ? (L(ue), P({
          type: "closeDialog"
        })) : xM(ue) ? (B.current = !1, A.current ? (A.current.value = null, A.current.click()) : K(new Error("Cannot open the file picker because the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API is not supported and no <input> was provided."))) : K(ue);
      });
      return;
    }
    A.current && (P({
      type: "openDialog"
    }), V(), A.current.value = null, A.current.click());
  }, [P, V, L, m, X, K, _, s]), re = Oe(function(ie) {
    !I.current || !I.current.isEqualNode(ie.target) || (ie.key === " " || ie.key === "Enter" || ie.keyCode === 32 || ie.keyCode === 13) && (ie.preventDefault(), H());
  }, [I, H]), se = Oe(function() {
    P({
      type: "focus"
    });
  }, []), fe = Oe(function() {
    P({
      type: "blur"
    });
  }, []), oe = Oe(function() {
    C || (vM() ? setTimeout(H, 0) : H());
  }, [C, H]), me = function(ue) {
    return r ? null : ue;
  }, we = function(ue) {
    return S ? null : me(ue);
  }, Ie = function(ue) {
    return E ? null : me(ue);
  }, nt = function(ue) {
    T && ue.stopPropagation();
  }, St = ut(function() {
    return function() {
      var ie = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, ue = ie.refKey, z = ue === void 0 ? "ref" : ue, F = ie.role, te = ie.onKeyDown, ae = ie.onFocus, ce = ie.onBlur, he = ie.onClick, qe = ie.onDragEnter, Ge = ie.onDragOver, gt = ie.onDragLeave, rt = ie.onDrop, Re = Ja(ie, EM);
      return Je(Je(Ec({
        onKeyDown: we(vn(te, re)),
        onFocus: we(vn(ae, se)),
        onBlur: we(vn(ce, fe)),
        onClick: me(vn(he, oe)),
        onDragEnter: Ie(vn(qe, G)),
        onDragOver: Ie(vn(Ge, Z)),
        onDragLeave: Ie(vn(gt, Q)),
        onDrop: Ie(vn(rt, J)),
        role: typeof F == "string" && F !== "" ? F : "presentation"
      }, z, I), !r && !S ? {
        tabIndex: 0
      } : {}), Re);
    };
  }, [I, re, se, fe, oe, G, Z, Q, J, S, E, r]), Et = Oe(function(ie) {
    ie.stopPropagation();
  }, []), kt = ut(function() {
    return function() {
      var ie = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, ue = ie.refKey, z = ue === void 0 ? "ref" : ue, F = ie.onChange, te = ie.onClick, ae = Ja(ie, kM), ce = Ec({
        accept: O,
        multiple: s,
        type: "file",
        style: {
          display: "none"
        },
        onChange: me(vn(F, J)),
        onClick: me(vn(te, Et)),
        tabIndex: -1
      }, z, A);
      return Je(Je({}, ce), ae);
    };
  }, [A, n, s, J, r]);
  return Je(Je({}, W), {}, {
    isFocused: y && !r,
    getRootProps: St,
    getInputProps: kt,
    rootRef: I,
    inputRef: A,
    open: me(H)
  });
}
function _M(e, t) {
  switch (t.type) {
    case "focus":
      return Je(Je({}, e), {}, {
        isFocused: !0
      });
    case "blur":
      return Je(Je({}, e), {}, {
        isFocused: !1
      });
    case "openDialog":
      return Je(Je({}, kc), {}, {
        isFileDialogActive: !0
      });
    case "closeDialog":
      return Je(Je({}, e), {}, {
        isFileDialogActive: !1
      });
    case "setDraggedFiles":
      return Je(Je({}, e), {}, {
        isDragActive: t.isDragActive,
        isDragAccept: t.isDragAccept,
        isDragReject: t.isDragReject
      });
    case "setFiles":
      return Je(Je({}, e), {}, {
        acceptedFiles: t.acceptedFiles,
        fileRejections: t.fileRejections
      });
    case "reset":
      return Je({}, kc);
    default:
      return e;
  }
}
function Tv() {
}
const Ov = ({ children: e }) => {
  const [t, n] = ge(!1), [r, i] = ge(""), [o, a] = ge(""), [s, l] = ge(""), [u, c] = ge(() => {
  }), [f, p] = ge(""), [d, v] = ge(null), h = ({
    title: m,
    description: b,
    confirmButton: x,
    onConfirm: C,
    cancelButton: S,
    content: E
  }) => {
    i(m), a(b), l(x), c(() => C), p(S), v(E), n(!0);
  }, g = () => {
    n(!1);
  };
  return /* @__PURE__ */ $.jsxs(
    px.Provider,
    {
      value: {
        open: t,
        showModal: h,
        hideModal: g
      },
      children: [
        /* @__PURE__ */ $.jsx(co, { open: t, onOpenChange: n, children: /* @__PURE__ */ $.jsx(
          co.Content,
          {
            title: r,
            description: o,
            confirmButton: s,
            onConfirm: u,
            cancelButton: f,
            hideModal: g,
            children: d
          }
        ) }),
        e
      ]
    }
  );
}, MM = ({ color: e, fontFamily: t, radius: n, themeMode: r, variant: i, headerVariant: o }) => {
  const a = ut(
    () => tk({ color: e, fontFamily: t, radius: n, themeMode: r, variant: i, headerVariant: o }),
    [e, t, n, r, i, o]
  );
  return /* @__PURE__ */ $.jsx("style", { children: a });
}, yw = ({ children: e, className: t, connected: n, uploadFile: r, allowFileUpload: i, ...o }) => {
  const { container: a } = Te, s = _f((c) => c.setMessageContainerRef), l = Fi((c) => c.uploadFile), u = Ve(null);
  return ft(() => {
    s(u);
  }, [u]), i && r ? /* @__PURE__ */ $.jsx(Os, { noClick: !0, onDrop: (c) => c.forEach((f) => l(f, r)), children: ({ getRootProps: c, isDragActive: f }) => /* @__PURE__ */ $.jsxs("div", { ...o, className: no(a.className, t), ref: u, children: [
    /* @__PURE__ */ $.jsxs("div", { "data-hover": f, ...a.dropzone.overlay, children: [
      "Drop files to upload",
      /* @__PURE__ */ $.jsx(VR, { style: { width: "50px" } })
    ] }),
    /* @__PURE__ */ $.jsxs(Ov, { children: [
      /* @__PURE__ */ $.jsx(Iv, { connected: n }),
      /* @__PURE__ */ $.jsx("div", { ...a.dropzone.container, ...c(), children: e })
    ] })
  ] }) }) : /* @__PURE__ */ $.jsx("div", { ...o, className: no(a.className, t), ref: u, children: /* @__PURE__ */ $.jsxs(Ov, { children: [
    /* @__PURE__ */ $.jsx(Iv, { connected: n }),
    e
  ] }) });
}, Iv = ({ connected: e }) => {
  const { open: t, showModal: n } = Mf();
  return e === !1 && !t && n && n({
    title: "Connection Error",
    description: "There was an error connecting to the server. Please check your internet connection and try again.",
    confirmButton: "Restart",
    onConfirm: () => window.parent.location.reload(),
    cancelButton: "Cancel"
  }), /* @__PURE__ */ $.jsx($.Fragment, {});
};
yw.displayName = "Container";
const jM = Ot(
  ({ children: e, onClick: t, imgUrl: n, ...r }, i) => {
    const { fab: o } = Te, { container: a, icon: s, image: l } = o ?? {};
    return n ? /* @__PURE__ */ $.jsx(
      "img",
      {
        src: n,
        role: "button",
        tabIndex: 0,
        alt: "Chatbot Button Image",
        ...l,
        draggable: "false",
        onClick: t
      }
    ) : /* @__PURE__ */ $.jsx("div", { ...r, ...a, ref: i, onClick: t, children: /* @__PURE__ */ $.jsx("div", { ...s }) });
  }
);
jM.displayName = "Fab";
function _n(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e == null || e(i), n === !1 || !i.defaultPrevented)
      return t == null ? void 0 : t(i);
  };
}
function NM(e, t) {
  const n = k.createContext(t), r = (o) => {
    const { children: a, ...s } = o, l = k.useMemo(() => s, Object.values(s));
    return /* @__PURE__ */ $.jsx(n.Provider, { value: l, children: a });
  };
  r.displayName = e + "Provider";
  function i(o) {
    const a = k.useContext(n);
    if (a) return a;
    if (t !== void 0) return t;
    throw new Error(`\`${o}\` must be used within \`${e}\``);
  }
  return [r, i];
}
function bw(e, t = []) {
  let n = [];
  function r(o, a) {
    const s = k.createContext(a), l = n.length;
    n = [...n, a];
    const u = (f) => {
      var m;
      const { scope: p, children: d, ...v } = f, h = ((m = p == null ? void 0 : p[e]) == null ? void 0 : m[l]) || s, g = k.useMemo(() => v, Object.values(v));
      return /* @__PURE__ */ $.jsx(h.Provider, { value: g, children: d });
    };
    u.displayName = o + "Provider";
    function c(f, p) {
      var h;
      const d = ((h = p == null ? void 0 : p[e]) == null ? void 0 : h[l]) || s, v = k.useContext(d);
      if (v) return v;
      if (a !== void 0) return a;
      throw new Error(`\`${f}\` must be used within \`${o}\``);
    }
    return [u, c];
  }
  const i = () => {
    const o = n.map((a) => k.createContext(a));
    return function(s) {
      const l = (s == null ? void 0 : s[e]) || o;
      return k.useMemo(
        () => ({ [`__scope${e}`]: { ...s, [e]: l } }),
        [s, l]
      );
    };
  };
  return i.scopeName = e, [r, LM(i, ...t)];
}
function LM(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(o) {
      const a = r.reduce((s, { useScope: l, scopeName: u }) => {
        const f = l(o)[`__scope${u}`];
        return { ...s, ...f };
      }, {});
      return k.useMemo(() => ({ [`__scope${t.scopeName}`]: a }), [a]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function xw({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  }
}) {
  const [r, i] = FM({ defaultProp: t, onChange: n }), o = e !== void 0, a = o ? e : r, s = Zn(n), l = k.useCallback(
    (u) => {
      if (o) {
        const f = typeof u == "function" ? u(e) : u;
        f !== e && s(f);
      } else
        i(u);
    },
    [o, e, i, s]
  );
  return [a, l];
}
function FM({
  defaultProp: e,
  onChange: t
}) {
  const n = k.useState(e), [r] = n, i = k.useRef(r), o = Zn(t);
  return k.useEffect(() => {
    i.current !== r && (o(r), i.current = r);
  }, [r, i, o]), n;
}
function Rv(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function ww(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((i) => {
      const o = Rv(i, t);
      return !n && typeof o == "function" && (n = !0), o;
    });
    if (n)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const o = r[i];
          typeof o == "function" ? o() : Rv(e[i], null);
        }
      };
  };
}
function nr(...e) {
  return k.useCallback(ww(...e), e);
}
var Zf = k.forwardRef((e, t) => {
  const { children: n, ...r } = e, i = k.Children.toArray(n), o = i.find(zM);
  if (o) {
    const a = o.props.children, s = i.map((l) => l === o ? k.Children.count(a) > 1 ? k.Children.only(null) : k.isValidElement(a) ? a.props.children : null : l);
    return /* @__PURE__ */ $.jsx(Cc, { ...r, ref: t, children: k.isValidElement(a) ? k.cloneElement(a, void 0, s) : null });
  }
  return /* @__PURE__ */ $.jsx(Cc, { ...r, ref: t, children: n });
});
Zf.displayName = "Slot";
var Cc = k.forwardRef((e, t) => {
  const { children: n, ...r } = e;
  if (k.isValidElement(n)) {
    const i = UM(n);
    return k.cloneElement(n, {
      ...WM(r, n.props),
      // @ts-ignore
      ref: t ? ww(t, i) : i
    });
  }
  return k.Children.count(n) > 1 ? k.Children.only(null) : null;
});
Cc.displayName = "SlotClone";
var BM = ({ children: e }) => /* @__PURE__ */ $.jsx($.Fragment, { children: e });
function zM(e) {
  return k.isValidElement(e) && e.type === BM;
}
function WM(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], o = t[r];
    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...s) => {
      o(...s), i(...s);
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...o } : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function UM(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var HM = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], fn = HM.reduce((e, t) => {
  const n = k.forwardRef((r, i) => {
    const { asChild: o, ...a } = r, s = o ? Zf : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ $.jsx(s, { ...a, ref: i });
  });
  return n.displayName = `Primitive.${t}`, { ...e, [t]: n };
}, {});
function VM(e, t) {
  e && Ry.flushSync(() => e.dispatchEvent(t));
}
function KM(e, t) {
  return k.useReducer((n, r) => t[n][r] ?? n, e);
}
var Is = (e) => {
  const { present: t, children: n } = e, r = qM(t), i = typeof n == "function" ? n({ present: r.isPresent }) : k.Children.only(n), o = nr(r.ref, GM(i));
  return typeof n == "function" || r.isPresent ? k.cloneElement(i, { ref: o }) : null;
};
Is.displayName = "Presence";
function qM(e) {
  const [t, n] = k.useState(), r = k.useRef({}), i = k.useRef(e), o = k.useRef("none"), a = e ? "mounted" : "unmounted", [s, l] = KM(a, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return k.useEffect(() => {
    const u = na(r.current);
    o.current = s === "mounted" ? u : "none";
  }, [s]), Jr(() => {
    const u = r.current, c = i.current;
    if (c !== e) {
      const p = o.current, d = na(u);
      e ? l("MOUNT") : d === "none" || (u == null ? void 0 : u.display) === "none" ? l("UNMOUNT") : l(c && p !== d ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, l]), Jr(() => {
    if (t) {
      let u;
      const c = t.ownerDocument.defaultView ?? window, f = (d) => {
        const h = na(r.current).includes(d.animationName);
        if (d.target === t && h && (l("ANIMATION_END"), !i.current)) {
          const g = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", u = c.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = g);
          });
        }
      }, p = (d) => {
        d.target === t && (o.current = na(r.current));
      };
      return t.addEventListener("animationstart", p), t.addEventListener("animationcancel", f), t.addEventListener("animationend", f), () => {
        c.clearTimeout(u), t.removeEventListener("animationstart", p), t.removeEventListener("animationcancel", f), t.removeEventListener("animationend", f);
      };
    } else
      l("ANIMATION_END");
  }, [t, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(s),
    ref: k.useCallback((u) => {
      u && (r.current = getComputedStyle(u)), n(u);
    }, [])
  };
}
function na(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function GM(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var YM = k.useId || (() => {
}), XM = 0;
function ka(e) {
  const [t, n] = k.useState(YM());
  return Jr(() => {
    e || n((r) => r ?? String(XM++));
  }, [e]), e || (t ? `radix-${t}` : "");
}
var Qf = "Collapsible", [JM, fX] = bw(Qf), [ZM, ed] = JM(Qf), Sw = k.forwardRef(
  (e, t) => {
    const {
      __scopeCollapsible: n,
      open: r,
      defaultOpen: i,
      disabled: o,
      onOpenChange: a,
      ...s
    } = e, [l = !1, u] = xw({
      prop: r,
      defaultProp: i,
      onChange: a
    });
    return /* @__PURE__ */ $.jsx(
      ZM,
      {
        scope: n,
        disabled: o,
        contentId: ka(),
        open: l,
        onOpenToggle: k.useCallback(() => u((c) => !c), [u]),
        children: /* @__PURE__ */ $.jsx(
          fn.div,
          {
            "data-state": nd(l),
            "data-disabled": o ? "" : void 0,
            ...s,
            ref: t
          }
        )
      }
    );
  }
);
Sw.displayName = Qf;
var Ew = "CollapsibleTrigger", kw = k.forwardRef(
  (e, t) => {
    const { __scopeCollapsible: n, ...r } = e, i = ed(Ew, n);
    return /* @__PURE__ */ $.jsx(
      fn.button,
      {
        type: "button",
        "aria-controls": i.contentId,
        "aria-expanded": i.open || !1,
        "data-state": nd(i.open),
        "data-disabled": i.disabled ? "" : void 0,
        disabled: i.disabled,
        ...r,
        ref: t,
        onClick: _n(e.onClick, i.onOpenToggle)
      }
    );
  }
);
kw.displayName = Ew;
var td = "CollapsibleContent", Cw = k.forwardRef(
  (e, t) => {
    const { forceMount: n, ...r } = e, i = ed(td, e.__scopeCollapsible);
    return /* @__PURE__ */ $.jsx(Is, { present: n || i.open, children: ({ present: o }) => /* @__PURE__ */ $.jsx(QM, { ...r, ref: t, present: o }) });
  }
);
Cw.displayName = td;
var QM = k.forwardRef((e, t) => {
  const { __scopeCollapsible: n, present: r, children: i, ...o } = e, a = ed(td, n), [s, l] = k.useState(r), u = k.useRef(null), c = nr(t, u), f = k.useRef(0), p = f.current, d = k.useRef(0), v = d.current, h = a.open || s, g = k.useRef(h), m = k.useRef(void 0);
  return k.useEffect(() => {
    const b = requestAnimationFrame(() => g.current = !1);
    return () => cancelAnimationFrame(b);
  }, []), Jr(() => {
    const b = u.current;
    if (b) {
      m.current = m.current || {
        transitionDuration: b.style.transitionDuration,
        animationName: b.style.animationName
      }, b.style.transitionDuration = "0s", b.style.animationName = "none";
      const x = b.getBoundingClientRect();
      f.current = x.height, d.current = x.width, g.current || (b.style.transitionDuration = m.current.transitionDuration, b.style.animationName = m.current.animationName), l(r);
    }
  }, [a.open, r]), /* @__PURE__ */ $.jsx(
    fn.div,
    {
      "data-state": nd(a.open),
      "data-disabled": a.disabled ? "" : void 0,
      id: a.contentId,
      hidden: !h,
      ...o,
      ref: c,
      style: {
        "--radix-collapsible-content-height": p ? `${p}px` : void 0,
        "--radix-collapsible-content-width": v ? `${v}px` : void 0,
        ...e.style
      },
      children: h && i
    }
  );
});
function nd(e) {
  return e ? "open" : "closed";
}
var ej = Sw, tj = Cw;
const nj = ({ restartConversation: e, ...t }) => {
  var a, s;
  const { header: n } = Te, { showModal: r, hideModal: i } = Mf(), o = (l) => {
    l.stopPropagation(), r && i ? r({
      title: "Create New Conversation",
      description: "This will clear the current conversation and start a new one.",
      confirmButton: "New conversation",
      onConfirm: () => {
        e(), i();
      },
      cancelButton: "Cancel"
    }) : e();
  };
  return /* @__PURE__ */ $.jsx(
    rP,
    {
      ...t,
      ...(s = (a = n == null ? void 0 : n.content) == null ? void 0 : a.actions) == null ? void 0 : s.icons,
      "aria-label": "Restart Conversation Button",
      tabIndex: 0,
      role: "button",
      onClick: o
    }
  );
}, rj = ({ onClick: e, ...t }) => {
  const { header: n } = Te, r = (i) => {
    i.stopPropagation(), e == null || e();
  };
  return /* @__PURE__ */ $.jsx(
    lP,
    {
      ...t,
      ...n.content.actions.icons,
      role: "button",
      tabIndex: 0,
      "aria-label": "Close Chatbot Button",
      onClick: r,
      onKeyDown: (i) => {
        i.key === "Enter" && r(i);
      }
    }
  );
}, Pi = ({ icon: e, title: t, link: n, ...r }) => {
  var a, s, l, u, c, f, p, d, v, h, g, m;
  const { header: i } = Te, o = e ?? KR;
  return t ? n ? /* @__PURE__ */ $.jsxs(
    "a",
    {
      ...r,
      ...(s = (a = i.expandedContent) == null ? void 0 : a.descriptionItems) == null ? void 0 : s.container,
      href: n,
      target: "_blank",
      rel: "noreferrer noopener",
      children: [
        /* @__PURE__ */ $.jsx(o, { ...(u = (l = i.expandedContent) == null ? void 0 : l.descriptionItems) == null ? void 0 : u.icon }),
        /* @__PURE__ */ $.jsx("p", { ...(f = (c = i.expandedContent) == null ? void 0 : c.descriptionItems) == null ? void 0 : f.link, children: t })
      ]
    }
  ) : /* @__PURE__ */ $.jsxs("div", { ...r, ...(d = (p = i.expandedContent) == null ? void 0 : p.descriptionItems) == null ? void 0 : d.container, children: [
    /* @__PURE__ */ $.jsx(o, { ...(h = (v = i.expandedContent) == null ? void 0 : v.descriptionItems) == null ? void 0 : h.icon }),
    /* @__PURE__ */ $.jsx("p", { ...(m = (g = i.expandedContent) == null ? void 0 : g.descriptionItems) == null ? void 0 : m.text, children: t })
  ] }) : null;
}, ij = ({ defaultOpen: e, closeWindow: t, configuration: n, restartConversation: r, ...i }) => {
  var c, f, p, d, v, h, g, m, b, x, C, S, E, T, N, j, O, _, V, L, I, A;
  const { header: o } = Te, [a, s] = ge(!!e), l = !!((c = n.email) != null && c.title) || !!((f = n.phone) != null && f.title) || !!((p = n.website) != null && p.title) || !!((d = n.termsOfService) != null && d.link) || !!((v = n.privacyPolicy) != null && v.link), u = l || !!n.botDescription;
  return /* @__PURE__ */ $.jsxs(
    ej,
    {
      open: u ? a : !1,
      onOpenChange: s,
      "data-disabled": u ? void 0 : "",
      ...o.container,
      ...i,
      children: [
        /* @__PURE__ */ $.jsxs(kw, { "aria-label": "Expand Header Button", ...o.content.container, children: [
          /* @__PURE__ */ $.jsx(vf, { ...i, src: n.botAvatar, ...o.content.avatar, children: n.botName || "Bot" }),
          /* @__PURE__ */ $.jsx("h2", { ...o.content.title, children: n.botName || "Bot" }),
          n.botDescription && /* @__PURE__ */ $.jsx("p", { ...o.content.description, children: n.botDescription }),
          /* @__PURE__ */ $.jsxs("div", { ...o.content.actions.container, children: [
            r && /* @__PURE__ */ $.jsx(nj, { restartConversation: r }),
            t && /* @__PURE__ */ $.jsx(rj, { onClick: t })
          ] })
        ] }),
        l && /* @__PURE__ */ $.jsxs(tj, { ...o.expandedContent.container, children: [
          /* @__PURE__ */ $.jsxs("div", { "data-links": "", ...o.expandedContent.group, children: [
            /* @__PURE__ */ $.jsx(
              Pi,
              {
                "data-email": "",
                icon: ZR,
                title: (h = n.email) == null ? void 0 : h.title,
                link: (m = (g = n.email) == null ? void 0 : g.link) != null && m.startsWith("mailto:") ? (b = n.email) == null ? void 0 : b.link : `mailto:${(x = n.email) == null ? void 0 : x.link}`
              }
            ),
            /* @__PURE__ */ $.jsx(
              Pi,
              {
                "data-phone": "",
                icon: tP,
                title: (C = n.phone) == null ? void 0 : C.title,
                link: (E = (S = n.phone) == null ? void 0 : S.link) != null && E.startsWith("tel:") ? (T = n.phone) == null ? void 0 : T.link : `tel:${(N = n.phone) == null ? void 0 : N.link}`
              }
            ),
            /* @__PURE__ */ $.jsx(
              Pi,
              {
                "data-website": "",
                link: (j = n.website) == null ? void 0 : j.link,
                icon: YR,
                title: (O = n.website) == null ? void 0 : O.title
              }
            )
          ] }),
          /* @__PURE__ */ $.jsxs("div", { "data-legal": "", ...(_ = o.expandedContent) == null ? void 0 : _.group, children: [
            /* @__PURE__ */ $.jsx(
              Pi,
              {
                "data-terms": "",
                link: (V = n.termsOfService) == null ? void 0 : V.link,
                icon: Zb,
                title: (L = n.termsOfService) == null ? void 0 : L.title
              }
            ),
            /* @__PURE__ */ $.jsx(
              Pi,
              {
                "data-privacy": "",
                link: (I = n.privacyPolicy) == null ? void 0 : I.link,
                icon: JR,
                title: (A = n.privacyPolicy) == null ? void 0 : A.title
              }
            )
          ] })
        ] })
      ]
    }
  );
}, $w = fs(({ ...e }) => {
  const { typingIndicator: t } = Te;
  return /* @__PURE__ */ $.jsx("div", { ...e, ...t == null ? void 0 : t.container, children: /* @__PURE__ */ $.jsx("div", { ...t == null ? void 0 : t.loader }) });
});
$w.displayName = "TypingIndicator";
const Pv = fs(
  Ot(
    ({
      direction: e,
      block: t,
      disableInput: n,
      children: r,
      sender: i,
      id: o,
      authorId: a,
      renderers: s,
      isReadOnly: l,
      feedback: u,
      timestamp: c,
      metadata: f,
      sendMessage: p,
      addMessageFeedback: d
    }, v) => {
      var S, E, T;
      const [h, g] = ge([]), { message: m } = Te, b = jy(a ?? "", 15), [x, C] = ge("idle");
      return /* @__PURE__ */ $.jsx(dx.Provider, { value: { isLoading: h, setIsLoading: g }, children: /* @__PURE__ */ $.jsxs(
        "div",
        {
          ...m == null ? void 0 : m.container,
          "data-loaded": h.length === 0,
          "data-disable-input": !!n,
          "data-direction": e,
          ref: v,
          children: [
            /* @__PURE__ */ $.jsxs(df, { "data-color": b, "data-loading-status": x, ...(S = m == null ? void 0 : m.avatar) == null ? void 0 : S.container, children: [
              /* @__PURE__ */ $.jsx(pf, { ...(E = m == null ? void 0 : m.avatar) == null ? void 0 : E.image, onLoadingStatusChange: C, src: i == null ? void 0 : i.avatar }),
              /* @__PURE__ */ $.jsxs(hf, { ...(T = m == null ? void 0 : m.avatar) == null ? void 0 : T.fallback, children: [
                i == null ? void 0 : i.name[0],
                " "
              ] })
            ] }),
            t && /* @__PURE__ */ $.jsx(
              ri,
              {
                block: {
                  ...t,
                  isReadOnly: l,
                  direction: e,
                  timestamp: c,
                  sender: i,
                  feedback: u,
                  messageId: o,
                  metadata: f,
                  sendMessage: p,
                  addMessageFeedback: d
                },
                renderers: s
              }
            ),
            r
          ]
        }
      ) });
    }
  )
);
function oj({ botAvatar: e, botDescription: t, botName: n }) {
  const {
    messageList: { marquee: r }
  } = Te;
  return /* @__PURE__ */ $.jsxs("li", { ...r.container, children: [
    /* @__PURE__ */ $.jsx(vf, { src: e, ...r.avatar, children: (n || "Bot").slice(0, 1) }),
    /* @__PURE__ */ $.jsxs("div", { ...r.content, children: [
      /* @__PURE__ */ $.jsx("h1", { ...r.title, children: n || "Bot" }),
      /* @__PURE__ */ $.jsx("p", { ...r.description, children: t })
    ] })
  ] });
}
function aj(e, t) {
  try {
    var n = global, r = n.document;
    if (typeof r < "u" && r.createElement && r.head && r.head.appendChild) {
      var i = r.querySelector('html meta[name="'.concat(encodeURI(e), '"]')) || r.createElement("meta");
      i.setAttribute("name", e), i.setAttribute("content", t), r.head.appendChild(i);
    }
  } catch {
  }
}
function sj() {
  aj("react-scroll-to-bottom:version", "4.2.0");
}
var Ai = function(e) {
  return e && e.Math === Math && e;
}, dt = (
  // eslint-disable-next-line es/no-global-this -- safe
  Ai(typeof globalThis == "object" && globalThis) || Ai(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  Ai(typeof self == "object" && self) || Ai(typeof an == "object" && an) || Ai(typeof an == "object" && an) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")()
), pt = function(e) {
  try {
    return !!e();
  } catch {
    return !0;
  }
}, lj = pt, Rs = !lj(function() {
  var e = (function() {
  }).bind();
  return typeof e != "function" || e.hasOwnProperty("prototype");
}), uj = Rs, Tw = Function.prototype, Av = Tw.apply, Dv = Tw.call, rd = typeof Reflect == "object" && Reflect.apply || (uj ? Dv.bind(Av) : function() {
  return Dv.apply(Av, arguments);
}), Ow = Rs, Iw = Function.prototype, $c = Iw.call, cj = Ow && Iw.bind.bind($c, $c), ht = Ow ? cj : function(e) {
  return function() {
    return $c.apply(e, arguments);
  };
}, Rw = ht, fj = Rw({}.toString), dj = Rw("".slice), xr = function(e) {
  return dj(fj(e), 8, -1);
}, pj = xr, hj = ht, id = function(e) {
  if (pj(e) === "Function") return hj(e);
}, Ul = typeof document == "object" && document.all, Rt = typeof Ul > "u" && Ul !== void 0 ? function(e) {
  return typeof e == "function" || e === Ul;
} : function(e) {
  return typeof e == "function";
}, So = {}, vj = pt, Bt = !vj(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] !== 7;
}), mj = Rs, ra = Function.prototype.call, $n = mj ? ra.bind(ra) : function() {
  return ra.apply(ra, arguments);
}, od = {}, Pw = {}.propertyIsEnumerable, Aw = Object.getOwnPropertyDescriptor, gj = Aw && !Pw.call({ 1: 2 }, 1);
od.f = gj ? function(t) {
  var n = Aw(this, t);
  return !!n && n.enumerable;
} : Pw;
var Eo = function(e, t) {
  return {
    enumerable: !(e & 1),
    configurable: !(e & 2),
    writable: !(e & 4),
    value: t
  };
}, yj = ht, bj = pt, xj = xr, Hl = Object, wj = yj("".split), Dw = bj(function() {
  return !Hl("z").propertyIsEnumerable(0);
}) ? function(e) {
  return xj(e) === "String" ? wj(e, "") : Hl(e);
} : Hl, ad = function(e) {
  return e == null;
}, Sj = ad, Ej = TypeError, sd = function(e) {
  if (Sj(e)) throw new Ej("Can't call method on " + e);
  return e;
}, kj = Dw, Cj = sd, Tn = function(e) {
  return kj(Cj(e));
}, $j = Rt, Ln = function(e) {
  return typeof e == "object" ? e !== null : $j(e);
}, wt = {}, Vl = wt, Kl = dt, Tj = Rt, _v = function(e) {
  return Tj(e) ? e : void 0;
}, On = function(e, t) {
  return arguments.length < 2 ? _v(Vl[e]) || _v(Kl[e]) : Vl[e] && Vl[e][t] || Kl[e] && Kl[e][t];
}, Oj = ht, Fn = Oj({}.isPrototypeOf), Ij = dt, Mv = Ij.navigator, jv = Mv && Mv.userAgent, ld = jv ? String(jv) : "", _w = dt, ql = ld, Nv = _w.process, Lv = _w.Deno, Fv = Nv && Nv.versions || Lv && Lv.version, Bv = Fv && Fv.v8, rn, Za;
Bv && (rn = Bv.split("."), Za = rn[0] > 0 && rn[0] < 4 ? 1 : +(rn[0] + rn[1]));
!Za && ql && (rn = ql.match(/Edge\/(\d+)/), (!rn || rn[1] >= 74) && (rn = ql.match(/Chrome\/(\d+)/), rn && (Za = +rn[1])));
var ud = Za, zv = ud, Rj = pt, Pj = dt, Aj = Pj.String, mi = !!Object.getOwnPropertySymbols && !Rj(function() {
  var e = Symbol("symbol detection");
  return !Aj(e) || !(Object(e) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && zv && zv < 41;
}), Dj = mi, Mw = Dj && !Symbol.sham && typeof Symbol.iterator == "symbol", _j = On, Mj = Rt, jj = Fn, Nj = Mw, Lj = Object, ko = Nj ? function(e) {
  return typeof e == "symbol";
} : function(e) {
  var t = _j("Symbol");
  return Mj(t) && jj(t.prototype, Lj(e));
}, Fj = String, Ps = function(e) {
  try {
    return Fj(e);
  } catch {
    return "Object";
  }
}, Bj = Rt, zj = Ps, Wj = TypeError, cd = function(e) {
  if (Bj(e)) return e;
  throw new Wj(zj(e) + " is not a function");
}, Uj = cd, Hj = ad, fd = function(e, t) {
  var n = e[t];
  return Hj(n) ? void 0 : Uj(n);
}, Gl = $n, Yl = Rt, Xl = Ln, Vj = TypeError, Kj = function(e, t) {
  var n, r;
  if (t === "string" && Yl(n = e.toString) && !Xl(r = Gl(n, e)) || Yl(n = e.valueOf) && !Xl(r = Gl(n, e)) || t !== "string" && Yl(n = e.toString) && !Xl(r = Gl(n, e))) return r;
  throw new Vj("Can't convert object to primitive value");
}, jw = { exports: {} }, Wv = dt, qj = Object.defineProperty, Gj = function(e, t) {
  try {
    qj(Wv, e, { value: t, configurable: !0, writable: !0 });
  } catch {
    Wv[e] = t;
  }
  return t;
}, Yj = dt, Xj = Gj, Uv = "__core-js_shared__", Hv = jw.exports = Yj[Uv] || Xj(Uv, {});
(Hv.versions || (Hv.versions = [])).push({
  version: "3.38.1",
  mode: "pure",
  copyright: "© 2014-2024 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.38.1/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var dd = jw.exports, Vv = dd, gi = function(e, t) {
  return Vv[e] || (Vv[e] = t || {});
}, Jj = sd, Zj = Object, Bn = function(e) {
  return Zj(Jj(e));
}, Qj = ht, eN = Bn, tN = Qj({}.hasOwnProperty), Vt = Object.hasOwn || function(t, n) {
  return tN(eN(t), n);
}, nN = ht, rN = 0, iN = Math.random(), oN = nN(1 .toString), pd = function(e) {
  return "Symbol(" + (e === void 0 ? "" : e) + ")_" + oN(++rN + iN, 36);
}, aN = dt, sN = gi, Kv = Vt, lN = pd, uN = mi, cN = Mw, zr = aN.Symbol, Jl = sN("wks"), fN = cN ? zr.for || zr : zr && zr.withoutSetter || lN, mt = function(e) {
  return Kv(Jl, e) || (Jl[e] = uN && Kv(zr, e) ? zr[e] : fN("Symbol." + e)), Jl[e];
}, dN = $n, qv = Ln, Gv = ko, pN = fd, hN = Kj, vN = mt, mN = TypeError, gN = vN("toPrimitive"), yN = function(e, t) {
  if (!qv(e) || Gv(e)) return e;
  var n = pN(e, gN), r;
  if (n) {
    if (t === void 0 && (t = "default"), r = dN(n, e, t), !qv(r) || Gv(r)) return r;
    throw new mN("Can't convert object to primitive value");
  }
  return t === void 0 && (t = "number"), hN(e, t);
}, bN = yN, xN = ko, hd = function(e) {
  var t = bN(e, "string");
  return xN(t) ? t : t + "";
}, wN = dt, Yv = Ln, Tc = wN.document, SN = Yv(Tc) && Yv(Tc.createElement), Nw = function(e) {
  return SN ? Tc.createElement(e) : {};
}, EN = Bt, kN = pt, CN = Nw, Lw = !EN && !kN(function() {
  return Object.defineProperty(CN("div"), "a", {
    get: function() {
      return 7;
    }
  }).a !== 7;
}), $N = Bt, TN = $n, ON = od, IN = Eo, RN = Tn, PN = hd, AN = Vt, DN = Lw, Xv = Object.getOwnPropertyDescriptor;
So.f = $N ? Xv : function(t, n) {
  if (t = RN(t), n = PN(n), DN) try {
    return Xv(t, n);
  } catch {
  }
  if (AN(t, n)) return IN(!TN(ON.f, t, n), t[n]);
};
var _N = pt, MN = Rt, jN = /#|\.prototype\./, Co = function(e, t) {
  var n = LN[NN(e)];
  return n === BN ? !0 : n === FN ? !1 : MN(t) ? _N(t) : !!t;
}, NN = Co.normalize = function(e) {
  return String(e).replace(jN, ".").toLowerCase();
}, LN = Co.data = {}, FN = Co.NATIVE = "N", BN = Co.POLYFILL = "P", zN = Co, Jv = id, WN = cd, UN = Rs, HN = Jv(Jv.bind), vd = function(e, t) {
  return WN(e), t === void 0 ? e : UN ? HN(e, t) : function() {
    return e.apply(t, arguments);
  };
}, dn = {}, VN = Bt, KN = pt, Fw = VN && KN(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: !1
  }).prototype !== 42;
}), qN = Ln, GN = String, YN = TypeError, rr = function(e) {
  if (qN(e)) return e;
  throw new YN(GN(e) + " is not an object");
}, XN = Bt, JN = Lw, ZN = Fw, ia = rr, Zv = hd, QN = TypeError, Zl = Object.defineProperty, e2 = Object.getOwnPropertyDescriptor, Ql = "enumerable", eu = "configurable", tu = "writable";
dn.f = XN ? ZN ? function(t, n, r) {
  if (ia(t), n = Zv(n), ia(r), typeof t == "function" && n === "prototype" && "value" in r && tu in r && !r[tu]) {
    var i = e2(t, n);
    i && i[tu] && (t[n] = r.value, r = {
      configurable: eu in r ? r[eu] : i[eu],
      enumerable: Ql in r ? r[Ql] : i[Ql],
      writable: !1
    });
  }
  return Zl(t, n, r);
} : Zl : function(t, n, r) {
  if (ia(t), n = Zv(n), ia(r), JN) try {
    return Zl(t, n, r);
  } catch {
  }
  if ("get" in r || "set" in r) throw new QN("Accessors not supported");
  return "value" in r && (t[n] = r.value), t;
};
var t2 = Bt, n2 = dn, r2 = Eo, As = t2 ? function(e, t, n) {
  return n2.f(e, t, r2(1, n));
} : function(e, t, n) {
  return e[t] = n, e;
}, Di = dt, i2 = rd, o2 = id, a2 = Rt, s2 = So.f, l2 = zN, Ir = wt, u2 = vd, Rr = As, Qv = Vt, c2 = function(e) {
  var t = function(n, r, i) {
    if (this instanceof t) {
      switch (arguments.length) {
        case 0:
          return new e();
        case 1:
          return new e(n);
        case 2:
          return new e(n, r);
      }
      return new e(n, r, i);
    }
    return i2(e, this, arguments);
  };
  return t.prototype = e.prototype, t;
}, Le = function(e, t) {
  var n = e.target, r = e.global, i = e.stat, o = e.proto, a = r ? Di : i ? Di[n] : Di[n] && Di[n].prototype, s = r ? Ir : Ir[n] || Rr(Ir, n, {})[n], l = s.prototype, u, c, f, p, d, v, h, g, m;
  for (p in t)
    u = l2(r ? p : n + (i ? "." : "#") + p, e.forced), c = !u && a && Qv(a, p), v = s[p], c && (e.dontCallGetSet ? (m = s2(a, p), h = m && m.value) : h = a[p]), d = c && h ? h : t[p], !(!u && !o && typeof v == typeof d) && (e.bind && c ? g = u2(d, Di) : e.wrap && c ? g = c2(d) : o && a2(d) ? g = o2(d) : g = d, (e.sham || d && d.sham || v && v.sham) && Rr(g, "sham", !0), Rr(s, p, g), o && (f = n + "Prototype", Qv(Ir, f) || Rr(Ir, f, {}), Rr(Ir[f], p, d), e.real && l && (u || !l[p]) && Rr(l, p, d)));
}, f2 = xr, yi = Array.isArray || function(t) {
  return f2(t) === "Array";
}, d2 = Le, p2 = yi;
d2({ target: "Array", stat: !0 }, {
  isArray: p2
});
var h2 = wt, v2 = h2.Array.isArray, m2 = v2, Bw = m2, g2 = Bw, y2 = g2, b2 = y2, x2 = b2, w2 = x2;
const zw = /* @__PURE__ */ Ce(w2);
function S2(e) {
  if (zw(e)) return e;
}
var E2 = Math.ceil, k2 = Math.floor, C2 = Math.trunc || function(t) {
  var n = +t;
  return (n > 0 ? k2 : E2)(n);
}, $2 = C2, Ds = function(e) {
  var t = +e;
  return t !== t || t === 0 ? 0 : $2(t);
}, T2 = Ds, O2 = Math.min, I2 = function(e) {
  var t = T2(e);
  return t > 0 ? O2(t, 9007199254740991) : 0;
}, R2 = I2, wr = function(e) {
  return R2(e.length);
}, P2 = TypeError, A2 = 9007199254740991, md = function(e) {
  if (e > A2) throw P2("Maximum allowed index exceeded");
  return e;
}, D2 = Bt, _2 = dn, M2 = Eo, $o = function(e, t, n) {
  D2 ? _2.f(e, t, M2(0, n)) : e[t] = n;
}, j2 = mt, N2 = j2("toStringTag"), Ww = {};
Ww[N2] = "z";
var gd = String(Ww) === "[object z]", L2 = gd, F2 = Rt, Ca = xr, B2 = mt, z2 = B2("toStringTag"), W2 = Object, U2 = Ca(/* @__PURE__ */ function() {
  return arguments;
}()) === "Arguments", H2 = function(e, t) {
  try {
    return e[t];
  } catch {
  }
}, To = L2 ? Ca : function(e) {
  var t, n, r;
  return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (n = H2(t = W2(e), z2)) == "string" ? n : U2 ? Ca(t) : (r = Ca(t)) === "Object" && F2(t.callee) ? "Arguments" : r;
}, V2 = ht, K2 = Rt, Oc = dd, q2 = V2(Function.toString);
K2(Oc.inspectSource) || (Oc.inspectSource = function(e) {
  return q2(e);
});
var G2 = Oc.inspectSource, Y2 = ht, X2 = pt, Uw = Rt, J2 = To, Z2 = On, Q2 = G2, Hw = function() {
}, Vw = Z2("Reflect", "construct"), yd = /^\s*(?:class|function)\b/, eL = Y2(yd.exec), tL = !yd.test(Hw), _i = function(t) {
  if (!Uw(t)) return !1;
  try {
    return Vw(Hw, [], t), !0;
  } catch {
    return !1;
  }
}, Kw = function(t) {
  if (!Uw(t)) return !1;
  switch (J2(t)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return !1;
  }
  try {
    return tL || !!eL(yd, Q2(t));
  } catch {
    return !0;
  }
};
Kw.sham = !0;
var bd = !Vw || X2(function() {
  var e;
  return _i(_i.call) || !_i(Object) || !_i(function() {
    e = !0;
  }) || e;
}) ? Kw : _i, em = yi, nL = bd, rL = Ln, iL = mt, oL = iL("species"), tm = Array, aL = function(e) {
  var t;
  return em(e) && (t = e.constructor, nL(t) && (t === tm || em(t.prototype)) ? t = void 0 : rL(t) && (t = t[oL], t === null && (t = void 0))), t === void 0 ? tm : t;
}, sL = aL, xd = function(e, t) {
  return new (sL(e))(t === 0 ? 0 : t);
}, lL = pt, uL = mt, cL = ud, fL = uL("species"), _s = function(e) {
  return cL >= 51 || !lL(function() {
    var t = [], n = t.constructor = {};
    return n[fL] = function() {
      return { foo: 1 };
    }, t[e](Boolean).foo !== 1;
  });
}, dL = Le, pL = pt, hL = yi, vL = Ln, mL = Bn, gL = wr, nm = md, rm = $o, yL = xd, bL = _s, xL = mt, wL = ud, qw = xL("isConcatSpreadable"), SL = wL >= 51 || !pL(function() {
  var e = [];
  return e[qw] = !1, e.concat()[0] !== e;
}), EL = function(e) {
  if (!vL(e)) return !1;
  var t = e[qw];
  return t !== void 0 ? !!t : hL(e);
}, kL = !SL || !bL("concat");
dL({ target: "Array", proto: !0, arity: 1, forced: kL }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function(t) {
    var n = mL(this), r = yL(n, 0), i = 0, o, a, s, l, u;
    for (o = -1, s = arguments.length; o < s; o++)
      if (u = o === -1 ? n : arguments[o], EL(u))
        for (l = gL(u), nm(i + l), a = 0; a < l; a++, i++) a in u && rm(r, i, u[a]);
      else
        nm(i + 1), rm(r, i++, u);
    return r.length = i, r;
  }
});
var CL = To, $L = String, Oo = function(e) {
  if (CL(e) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
  return $L(e);
}, Ms = {}, TL = Ds, OL = Math.max, IL = Math.min, wd = function(e, t) {
  var n = TL(e);
  return n < 0 ? OL(n + t, 0) : IL(n, t);
}, RL = Tn, PL = wd, AL = wr, im = function(e) {
  return function(t, n, r) {
    var i = RL(t), o = AL(i);
    if (o === 0) return !e && -1;
    var a = PL(r, o), s;
    if (e && n !== n) {
      for (; o > a; )
        if (s = i[a++], s !== s) return !0;
    } else for (; o > a; a++)
      if ((e || a in i) && i[a] === n) return e || a || 0;
    return !e && -1;
  };
}, Gw = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: im(!0),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: im(!1)
}, js = {}, DL = ht, nu = Vt, _L = Tn, ML = Gw.indexOf, jL = js, om = DL([].push), Yw = function(e, t) {
  var n = _L(e), r = 0, i = [], o;
  for (o in n) !nu(jL, o) && nu(n, o) && om(i, o);
  for (; t.length > r; ) nu(n, o = t[r++]) && (~ML(i, o) || om(i, o));
  return i;
}, Sd = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
], NL = Yw, LL = Sd, Ed = Object.keys || function(t) {
  return NL(t, LL);
}, FL = Bt, BL = Fw, zL = dn, WL = rr, UL = Tn, HL = Ed;
Ms.f = FL && !BL ? Object.defineProperties : function(t, n) {
  WL(t);
  for (var r = UL(n), i = HL(n), o = i.length, a = 0, s; o > a; ) zL.f(t, s = i[a++], r[s]);
  return t;
};
var VL = On, KL = VL("document", "documentElement"), qL = gi, GL = pd, am = qL("keys"), Ns = function(e) {
  return am[e] || (am[e] = GL(e));
}, YL = rr, XL = Ms, sm = Sd, JL = js, ZL = KL, QL = Nw, eF = Ns, lm = ">", um = "<", Ic = "prototype", Rc = "script", Xw = eF("IE_PROTO"), ru = function() {
}, Jw = function(e) {
  return um + Rc + lm + e + um + "/" + Rc + lm;
}, cm = function(e) {
  e.write(Jw("")), e.close();
  var t = e.parentWindow.Object;
  return e = null, t;
}, tF = function() {
  var e = QL("iframe"), t = "java" + Rc + ":", n;
  return e.style.display = "none", ZL.appendChild(e), e.src = String(t), n = e.contentWindow.document, n.open(), n.write(Jw("document.F=Object")), n.close(), n.F;
}, oa, $a = function() {
  try {
    oa = new ActiveXObject("htmlfile");
  } catch {
  }
  $a = typeof document < "u" ? document.domain && oa ? cm(oa) : tF() : cm(oa);
  for (var e = sm.length; e--; ) delete $a[Ic][sm[e]];
  return $a();
};
JL[Xw] = !0;
var kd = Object.create || function(t, n) {
  var r;
  return t !== null ? (ru[Ic] = YL(t), r = new ru(), ru[Ic] = null, r[Xw] = t) : r = $a(), n === void 0 ? r : XL.f(r, n);
}, Ls = {}, nF = Yw, rF = Sd, iF = rF.concat("length", "prototype");
Ls.f = Object.getOwnPropertyNames || function(t) {
  return nF(t, iF);
};
var Zw = {}, oF = ht, Fs = oF([].slice), aF = xr, sF = Tn, Qw = Ls.f, lF = Fs, e1 = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], uF = function(e) {
  try {
    return Qw(e);
  } catch {
    return lF(e1);
  }
};
Zw.f = function(t) {
  return e1 && aF(t) === "Window" ? uF(t) : Qw(sF(t));
};
var Bs = {};
Bs.f = Object.getOwnPropertySymbols;
var cF = As, zs = function(e, t, n, r) {
  return r && r.enumerable ? e[t] = n : cF(e, t, n), e;
}, fF = dn, dF = function(e, t, n) {
  return fF.f(e, t, n);
}, Io = {}, pF = mt;
Io.f = pF;
var fm = wt, hF = Vt, vF = Io, mF = dn.f, Ze = function(e) {
  var t = fm.Symbol || (fm.Symbol = {});
  hF(t, e) || mF(t, e, {
    value: vF.f(e)
  });
}, gF = $n, yF = On, bF = mt, xF = zs, t1 = function() {
  var e = yF("Symbol"), t = e && e.prototype, n = t && t.valueOf, r = bF("toPrimitive");
  t && !t[r] && xF(t, r, function(i) {
    return gF(n, this);
  }, { arity: 1 });
}, wF = gd, SF = To, EF = wF ? {}.toString : function() {
  return "[object " + SF(this) + "]";
}, kF = gd, CF = dn.f, $F = As, TF = Vt, OF = EF, IF = mt, dm = IF("toStringTag"), bi = function(e, t, n, r) {
  var i = n ? e : e && e.prototype;
  i && (TF(i, dm) || CF(i, dm, { configurable: !0, value: t }), r && !kF && $F(i, "toString", OF));
}, RF = dt, PF = Rt, pm = RF.WeakMap, AF = PF(pm) && /native code/.test(String(pm)), DF = AF, n1 = dt, _F = Ln, MF = As, iu = Vt, ou = dd, jF = Ns, NF = js, hm = "Object already initialized", Pc = n1.TypeError, LF = n1.WeakMap, Qa, io, es, FF = function(e) {
  return es(e) ? io(e) : Qa(e, {});
}, BF = function(e) {
  return function(t) {
    var n;
    if (!_F(t) || (n = io(t)).type !== e)
      throw new Pc("Incompatible receiver, " + e + " required");
    return n;
  };
};
if (DF || ou.state) {
  var mn = ou.state || (ou.state = new LF());
  mn.get = mn.get, mn.has = mn.has, mn.set = mn.set, Qa = function(e, t) {
    if (mn.has(e)) throw new Pc(hm);
    return t.facade = e, mn.set(e, t), t;
  }, io = function(e) {
    return mn.get(e) || {};
  }, es = function(e) {
    return mn.has(e);
  };
} else {
  var Pr = jF("state");
  NF[Pr] = !0, Qa = function(e, t) {
    if (iu(e, Pr)) throw new Pc(hm);
    return t.facade = e, MF(e, Pr, t), t;
  }, io = function(e) {
    return iu(e, Pr) ? e[Pr] : {};
  }, es = function(e) {
    return iu(e, Pr);
  };
}
var Cd = {
  set: Qa,
  get: io,
  has: es,
  enforce: FF,
  getterFor: BF
}, zF = vd, WF = ht, UF = Dw, HF = Bn, VF = wr, KF = xd, vm = WF([].push), Wn = function(e) {
  var t = e === 1, n = e === 2, r = e === 3, i = e === 4, o = e === 6, a = e === 7, s = e === 5 || o;
  return function(l, u, c, f) {
    for (var p = HF(l), d = UF(p), v = VF(d), h = zF(u, c), g = 0, m = f || KF, b = t ? m(l, v) : n || a ? m(l, 0) : void 0, x, C; v > g; g++) if ((s || g in d) && (x = d[g], C = h(x, g, p), e))
      if (t) b[g] = C;
      else if (C) switch (e) {
        case 3:
          return !0;
        case 5:
          return x;
        case 6:
          return g;
        case 2:
          vm(b, x);
      }
      else switch (e) {
        case 4:
          return !1;
        case 7:
          vm(b, x);
      }
    return o ? -1 : r || i ? i : b;
  };
}, $d = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: Wn(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: Wn(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: Wn(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: Wn(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: Wn(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: Wn(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: Wn(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: Wn(7)
}, Ws = Le, Ro = dt, Td = $n, qF = ht, ii = Bt, oi = mi, GF = pt, vt = Vt, YF = Fn, Ac = rr, Us = Tn, Od = hd, XF = Oo, Dc = Eo, ai = kd, r1 = Ed, JF = Ls, i1 = Zw, ZF = Bs, o1 = So, a1 = dn, QF = Ms, s1 = od, mm = zs, eB = dF, Id = gi, tB = Ns, l1 = js, gm = pd, nB = mt, rB = Io, iB = Ze, oB = t1, aB = bi, u1 = Cd, Hs = $d.forEach, Lt = tB("hidden"), Vs = "Symbol", oo = "prototype", sB = u1.set, ym = u1.getterFor(Vs), sn = Object[oo], hr = Ro.Symbol, Bi = hr && hr[oo], lB = Ro.RangeError, uB = Ro.TypeError, au = Ro.QObject, c1 = o1.f, vr = a1.f, f1 = i1.f, cB = s1.f, d1 = qF([].push), jn = Id("symbols"), Po = Id("op-symbols"), fB = Id("wks"), _c = !au || !au[oo] || !au[oo].findChild, p1 = function(e, t, n) {
  var r = c1(sn, t);
  r && delete sn[t], vr(e, t, n), r && e !== sn && vr(sn, t, r);
}, Mc = ii && GF(function() {
  return ai(vr({}, "a", {
    get: function() {
      return vr(this, "a", { value: 7 }).a;
    }
  })).a !== 7;
}) ? p1 : vr, su = function(e, t) {
  var n = jn[e] = ai(Bi);
  return sB(n, {
    type: Vs,
    tag: e,
    description: t
  }), ii || (n.description = t), n;
}, Ks = function(t, n, r) {
  t === sn && Ks(Po, n, r), Ac(t);
  var i = Od(n);
  return Ac(r), vt(jn, i) ? (r.enumerable ? (vt(t, Lt) && t[Lt][i] && (t[Lt][i] = !1), r = ai(r, { enumerable: Dc(0, !1) })) : (vt(t, Lt) || vr(t, Lt, Dc(1, ai(null))), t[Lt][i] = !0), Mc(t, i, r)) : vr(t, i, r);
}, Rd = function(t, n) {
  Ac(t);
  var r = Us(n), i = r1(r).concat(g1(r));
  return Hs(i, function(o) {
    (!ii || Td(h1, r, o)) && Ks(t, o, r[o]);
  }), t;
}, dB = function(t, n) {
  return n === void 0 ? ai(t) : Rd(ai(t), n);
}, h1 = function(t) {
  var n = Od(t), r = Td(cB, this, n);
  return this === sn && vt(jn, n) && !vt(Po, n) ? !1 : r || !vt(this, n) || !vt(jn, n) || vt(this, Lt) && this[Lt][n] ? r : !0;
}, v1 = function(t, n) {
  var r = Us(t), i = Od(n);
  if (!(r === sn && vt(jn, i) && !vt(Po, i))) {
    var o = c1(r, i);
    return o && vt(jn, i) && !(vt(r, Lt) && r[Lt][i]) && (o.enumerable = !0), o;
  }
}, m1 = function(t) {
  var n = f1(Us(t)), r = [];
  return Hs(n, function(i) {
    !vt(jn, i) && !vt(l1, i) && d1(r, i);
  }), r;
}, g1 = function(e) {
  var t = e === sn, n = f1(t ? Po : Us(e)), r = [];
  return Hs(n, function(i) {
    vt(jn, i) && (!t || vt(sn, i)) && d1(r, jn[i]);
  }), r;
};
oi || (hr = function() {
  if (YF(Bi, this)) throw new uB("Symbol is not a constructor");
  var t = !arguments.length || arguments[0] === void 0 ? void 0 : XF(arguments[0]), n = gm(t), r = function(i) {
    var o = this === void 0 ? Ro : this;
    o === sn && Td(r, Po, i), vt(o, Lt) && vt(o[Lt], n) && (o[Lt][n] = !1);
    var a = Dc(1, i);
    try {
      Mc(o, n, a);
    } catch (s) {
      if (!(s instanceof lB)) throw s;
      p1(o, n, a);
    }
  };
  return ii && _c && Mc(sn, n, { configurable: !0, set: r }), su(n, t);
}, Bi = hr[oo], mm(Bi, "toString", function() {
  return ym(this).tag;
}), mm(hr, "withoutSetter", function(e) {
  return su(gm(e), e);
}), s1.f = h1, a1.f = Ks, QF.f = Rd, o1.f = v1, JF.f = i1.f = m1, ZF.f = g1, rB.f = function(e) {
  return su(nB(e), e);
}, ii && eB(Bi, "description", {
  configurable: !0,
  get: function() {
    return ym(this).description;
  }
}));
Ws({ global: !0, constructor: !0, wrap: !0, forced: !oi, sham: !oi }, {
  Symbol: hr
});
Hs(r1(fB), function(e) {
  iB(e);
});
Ws({ target: Vs, stat: !0, forced: !oi }, {
  useSetter: function() {
    _c = !0;
  },
  useSimple: function() {
    _c = !1;
  }
});
Ws({ target: "Object", stat: !0, forced: !oi, sham: !ii }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: dB,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: Ks,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: Rd,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: v1
});
Ws({ target: "Object", stat: !0, forced: !oi }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: m1
});
oB();
aB(hr, Vs);
l1[Lt] = !0;
var pB = mi, y1 = pB && !!Symbol.for && !!Symbol.keyFor, hB = Le, vB = On, mB = Vt, gB = Oo, b1 = gi, yB = y1, lu = b1("string-to-symbol-registry"), bB = b1("symbol-to-string-registry");
hB({ target: "Symbol", stat: !0, forced: !yB }, {
  for: function(e) {
    var t = gB(e);
    if (mB(lu, t)) return lu[t];
    var n = vB("Symbol")(t);
    return lu[t] = n, bB[n] = t, n;
  }
});
var xB = Le, wB = Vt, SB = ko, EB = Ps, kB = gi, CB = y1, bm = kB("symbol-to-string-registry");
xB({ target: "Symbol", stat: !0, forced: !CB }, {
  keyFor: function(t) {
    if (!SB(t)) throw new TypeError(EB(t) + " is not a symbol");
    if (wB(bm, t)) return bm[t];
  }
});
var $B = ht, xm = yi, TB = Rt, wm = xr, OB = Oo, Sm = $B([].push), IB = function(e) {
  if (TB(e)) return e;
  if (xm(e)) {
    for (var t = e.length, n = [], r = 0; r < t; r++) {
      var i = e[r];
      typeof i == "string" ? Sm(n, i) : (typeof i == "number" || wm(i) === "Number" || wm(i) === "String") && Sm(n, OB(i));
    }
    var o = n.length, a = !0;
    return function(s, l) {
      if (a)
        return a = !1, l;
      if (xm(this)) return l;
      for (var u = 0; u < o; u++) if (n[u] === s) return l;
    };
  }
}, RB = Le, x1 = On, w1 = rd, PB = $n, Ao = ht, S1 = pt, Em = Rt, km = ko, E1 = Fs, AB = IB, DB = mi, _B = String, Xn = x1("JSON", "stringify"), aa = Ao(/./.exec), Cm = Ao("".charAt), MB = Ao("".charCodeAt), jB = Ao("".replace), NB = Ao(1 .toString), LB = /[\uD800-\uDFFF]/g, $m = /^[\uD800-\uDBFF]$/, Tm = /^[\uDC00-\uDFFF]$/, Om = !DB || S1(function() {
  var e = x1("Symbol")("stringify detection");
  return Xn([e]) !== "[null]" || Xn({ a: e }) !== "{}" || Xn(Object(e)) !== "{}";
}), Im = S1(function() {
  return Xn("\uDF06\uD834") !== '"\\udf06\\ud834"' || Xn("\uDEAD") !== '"\\udead"';
}), FB = function(e, t) {
  var n = E1(arguments), r = AB(t);
  if (!(!Em(r) && (e === void 0 || km(e))))
    return n[1] = function(i, o) {
      if (Em(r) && (o = PB(r, this, _B(i), o)), !km(o)) return o;
    }, w1(Xn, null, n);
}, BB = function(e, t, n) {
  var r = Cm(n, t - 1), i = Cm(n, t + 1);
  return aa($m, e) && !aa(Tm, i) || aa(Tm, e) && !aa($m, r) ? "\\u" + NB(MB(e, 0), 16) : e;
};
Xn && RB({ target: "JSON", stat: !0, arity: 3, forced: Om || Im }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  stringify: function(t, n, r) {
    var i = E1(arguments), o = w1(Om ? FB : Xn, null, i);
    return Im && typeof o == "string" ? jB(o, LB, BB) : o;
  }
});
var zB = Le, WB = mi, UB = pt, k1 = Bs, HB = Bn, VB = !WB || UB(function() {
  k1.f(1);
});
zB({ target: "Object", stat: !0, forced: VB }, {
  getOwnPropertySymbols: function(t) {
    var n = k1.f;
    return n ? n(HB(t)) : [];
  }
});
var KB = Ze;
KB("asyncIterator");
var qB = Ze;
qB("hasInstance");
var GB = Ze;
GB("isConcatSpreadable");
var YB = Ze;
YB("iterator");
var XB = Ze;
XB("match");
var JB = Ze;
JB("matchAll");
var ZB = Ze;
ZB("replace");
var QB = Ze;
QB("search");
var e3 = Ze;
e3("species");
var t3 = Ze;
t3("split");
var n3 = Ze, r3 = t1;
n3("toPrimitive");
r3();
var i3 = On, o3 = Ze, a3 = bi;
o3("toStringTag");
a3(i3("Symbol"), "Symbol");
var s3 = Ze;
s3("unscopables");
var l3 = dt, u3 = bi;
u3(l3.JSON, "JSON", !0);
var c3 = wt, f3 = c3.Symbol, xi = {}, jc = Bt, d3 = Vt, C1 = Function.prototype, p3 = jc && Object.getOwnPropertyDescriptor, Pd = d3(C1, "name"), h3 = Pd && (function() {
}).name === "something", v3 = Pd && (!jc || jc && p3(C1, "name").configurable), m3 = {
  EXISTS: Pd,
  PROPER: h3,
  CONFIGURABLE: v3
}, g3 = pt, y3 = !g3(function() {
  function e() {
  }
  return e.prototype.constructor = null, Object.getPrototypeOf(new e()) !== e.prototype;
}), b3 = Vt, x3 = Rt, w3 = Bn, S3 = Ns, E3 = y3, Rm = S3("IE_PROTO"), Nc = Object, k3 = Nc.prototype, $1 = E3 ? Nc.getPrototypeOf : function(e) {
  var t = w3(e);
  if (b3(t, Rm)) return t[Rm];
  var n = t.constructor;
  return x3(n) && t instanceof n ? n.prototype : t instanceof Nc ? k3 : null;
}, C3 = pt, $3 = Rt, T3 = Ln, O3 = kd, Pm = $1, I3 = zs, R3 = mt, Lc = R3("iterator"), T1 = !1, Mn, uu, cu;
[].keys && (cu = [].keys(), "next" in cu ? (uu = Pm(Pm(cu)), uu !== Object.prototype && (Mn = uu)) : T1 = !0);
var P3 = !T3(Mn) || C3(function() {
  var e = {};
  return Mn[Lc].call(e) !== e;
});
P3 ? Mn = {} : Mn = O3(Mn);
$3(Mn[Lc]) || I3(Mn, Lc, function() {
  return this;
});
var O1 = {
  IteratorPrototype: Mn,
  BUGGY_SAFARI_ITERATORS: T1
}, A3 = O1.IteratorPrototype, D3 = kd, _3 = Eo, M3 = bi, j3 = xi, N3 = function() {
  return this;
}, L3 = function(e, t, n, r) {
  var i = t + " Iterator";
  return e.prototype = D3(A3, { next: _3(+!r, n) }), M3(e, i, !1, !0), j3[i] = N3, e;
}, F3 = Le, B3 = $n, I1 = m3, z3 = L3, W3 = $1, U3 = bi, Am = zs, H3 = mt, Dm = xi, R1 = O1, V3 = I1.PROPER;
I1.CONFIGURABLE;
R1.IteratorPrototype;
var sa = R1.BUGGY_SAFARI_ITERATORS, fu = H3("iterator"), _m = "keys", la = "values", Mm = "entries", K3 = function() {
  return this;
}, P1 = function(e, t, n, r, i, o, a) {
  z3(n, t, r);
  var s = function(m) {
    if (m === i && p) return p;
    if (!sa && m && m in c) return c[m];
    switch (m) {
      case _m:
        return function() {
          return new n(this, m);
        };
      case la:
        return function() {
          return new n(this, m);
        };
      case Mm:
        return function() {
          return new n(this, m);
        };
    }
    return function() {
      return new n(this);
    };
  }, l = t + " Iterator", u = !1, c = e.prototype, f = c[fu] || c["@@iterator"] || i && c[i], p = !sa && f || s(i), d = t === "Array" && c.entries || f, v, h, g;
  if (d && (v = W3(d.call(new e())), v !== Object.prototype && v.next && (U3(v, l, !0, !0), Dm[l] = K3)), V3 && i === la && f && f.name !== la && (u = !0, p = function() {
    return B3(f, this);
  }), i)
    if (h = {
      values: s(la),
      keys: o ? p : s(_m),
      entries: s(Mm)
    }, a) for (g in h)
      (sa || u || !(g in c)) && Am(c, g, h[g]);
    else F3({ target: t, proto: !0, forced: sa || u }, h);
  return a && c[fu] !== p && Am(c, fu, p, { name: i }), Dm[t] = p, h;
}, A1 = function(e, t) {
  return { value: e, done: t };
}, q3 = Tn, jm = xi, D1 = Cd;
dn.f;
var G3 = P1, ua = A1, _1 = "Array Iterator", Y3 = D1.set, X3 = D1.getterFor(_1);
G3(Array, "Array", function(e, t) {
  Y3(this, {
    type: _1,
    target: q3(e),
    // target
    index: 0,
    // next index
    kind: t
    // kind
  });
}, function() {
  var e = X3(this), t = e.target, n = e.index++;
  if (!t || n >= t.length)
    return e.target = null, ua(void 0, !0);
  switch (e.kind) {
    case "keys":
      return ua(n, !1);
    case "values":
      return ua(t[n], !1);
  }
  return ua([n, t[n]], !1);
}, "values");
jm.Arguments = jm.Array;
var J3 = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}, Z3 = J3, Q3 = dt, e4 = bi, Nm = xi;
for (var du in Z3)
  e4(Q3[du], du), Nm[du] = Nm.Array;
var t4 = f3, n4 = t4, r4 = mt, i4 = dn.f, Lm = r4("metadata"), Fm = Function.prototype;
Fm[Lm] === void 0 && i4(Fm, Lm, {
  value: null
});
var o4 = Ze;
o4("asyncDispose");
var a4 = Ze;
a4("dispose");
var s4 = Ze;
s4("metadata");
var l4 = n4, u4 = l4, c4 = On, f4 = ht, Ad = c4("Symbol"), d4 = Ad.keyFor, p4 = f4(Ad.prototype.valueOf), M1 = Ad.isRegisteredSymbol || function(t) {
  try {
    return d4(p4(t)) !== void 0;
  } catch {
    return !1;
  }
}, h4 = Le, v4 = M1;
h4({ target: "Symbol", stat: !0 }, {
  isRegisteredSymbol: v4
});
var m4 = gi, j1 = On, g4 = ht, y4 = ko, b4 = mt, ts = j1("Symbol"), Bm = ts.isWellKnownSymbol, N1 = j1("Object", "getOwnPropertyNames"), x4 = g4(ts.prototype.valueOf), zm = m4("wks");
for (var pu = 0, Wm = N1(ts), w4 = Wm.length; pu < w4; pu++)
  try {
    var Um = Wm[pu];
    y4(ts[Um]) && b4(Um);
  } catch {
  }
var L1 = function(t) {
  if (Bm && Bm(t)) return !0;
  try {
    for (var n = x4(t), r = 0, i = N1(zm), o = i.length; r < o; r++)
      if (zm[i[r]] == n) return !0;
  } catch {
  }
  return !1;
}, S4 = Le, E4 = L1;
S4({ target: "Symbol", stat: !0, forced: !0 }, {
  isWellKnownSymbol: E4
});
var k4 = Ze;
k4("customMatcher");
var C4 = Ze;
C4("observable");
var $4 = Le, T4 = M1;
$4({ target: "Symbol", stat: !0, name: "isRegisteredSymbol" }, {
  isRegistered: T4
});
var O4 = Le, I4 = L1;
O4({ target: "Symbol", stat: !0, name: "isWellKnownSymbol", forced: !0 }, {
  isWellKnown: I4
});
var R4 = Ze;
R4("matcher");
var P4 = Ze;
P4("metadataKey");
var A4 = Ze;
A4("patternMatch");
var D4 = Ze;
D4("replaceAll");
var _4 = u4, M4 = _4, j4 = M4;
const Wr = /* @__PURE__ */ Ce(j4);
var Dd = ht, N4 = Ds, L4 = Oo, F4 = sd, B4 = Dd("".charAt), Hm = Dd("".charCodeAt), z4 = Dd("".slice), Vm = function(e) {
  return function(t, n) {
    var r = L4(F4(t)), i = N4(n), o = r.length, a, s;
    return i < 0 || i >= o ? e ? "" : void 0 : (a = Hm(r, i), a < 55296 || a > 56319 || i + 1 === o || (s = Hm(r, i + 1)) < 56320 || s > 57343 ? e ? B4(r, i) : a : e ? z4(r, i, i + 2) : (a - 55296 << 10) + (s - 56320) + 65536);
  };
}, W4 = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: Vm(!1),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: Vm(!0)
}, U4 = W4.charAt, H4 = Oo, F1 = Cd, V4 = P1, Km = A1, B1 = "String Iterator", K4 = F1.set, q4 = F1.getterFor(B1);
V4(String, "String", function(e) {
  K4(this, {
    type: B1,
    string: H4(e),
    index: 0
  });
}, function() {
  var t = q4(this), n = t.string, r = t.index, i;
  return r >= n.length ? Km(void 0, !0) : (i = U4(n, r), t.index += i.length, Km(i, !1));
});
var G4 = To, qm = fd, Y4 = ad, X4 = xi, J4 = mt, Z4 = J4("iterator"), _d = function(e) {
  if (!Y4(e)) return qm(e, Z4) || qm(e, "@@iterator") || X4[G4(e)];
}, Q4 = _d, ez = Q4, tz = ez, nz = tz, rz = nz, iz = rz, oz = iz, az = oz, sz = az;
const z1 = /* @__PURE__ */ Ce(sz);
var lz = Bt, uz = yi, cz = TypeError, fz = Object.getOwnPropertyDescriptor, dz = lz && !function() {
  if (this !== void 0) return !0;
  try {
    Object.defineProperty([], "length", { writable: !1 }).length = 1;
  } catch (e) {
    return e instanceof TypeError;
  }
}(), W1 = dz ? function(e, t) {
  if (uz(e) && !fz(e, "length").writable)
    throw new cz("Cannot set read only .length");
  return e.length = t;
} : function(e, t) {
  return e.length = t;
}, pz = Le, hz = Bn, vz = wr, mz = W1, gz = md, yz = pt, bz = yz(function() {
  return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
}), xz = function() {
  try {
    Object.defineProperty([], "length", { writable: !1 }).push();
  } catch (e) {
    return e instanceof TypeError;
  }
}, wz = bz || !xz();
pz({ target: "Array", proto: !0, arity: 1, forced: wz }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function(t) {
    var n = hz(this), r = vz(n), i = arguments.length;
    gz(r + i);
    for (var o = 0; o < i; o++)
      n[r] = arguments[o], r++;
    return mz(n, r), r;
  }
});
var Sz = dt, Ez = wt, Sr = function(e, t) {
  var n = Ez[e + "Prototype"], r = n && n[t];
  if (r) return r;
  var i = Sz[e], o = i && i.prototype;
  return o && o[t];
}, kz = Sr, Cz = kz("Array", "push"), $z = Fn, Tz = Cz, hu = Array.prototype, Oz = function(e) {
  var t = e.push;
  return e === hu || $z(hu, e) && t === hu.push ? Tz : t;
}, Iz = Oz, Rz = Iz, Pz = Rz, Az = Pz, Dz = Az, _z = Dz, Mz = _z;
const jz = /* @__PURE__ */ Ce(Mz);
function Nz(e, t) {
  var n = e == null ? null : typeof Wr < "u" && z1(e) || e["@@iterator"];
  if (n != null) {
    var r, i, o, a, s = [], l = !0, u = !1;
    try {
      if (o = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n) return;
        l = !1;
      } else for (; !(l = (r = o.call(n)).done) && (jz(s).call(s, r.value), s.length !== t); l = !0) ;
    } catch (c) {
      u = !0, i = c;
    } finally {
      try {
        if (!l && n.return != null && (a = n.return(), Object(a) !== a)) return;
      } finally {
        if (u) throw i;
      }
    }
    return s;
  }
}
var Lz = Le, Gm = yi, Fz = bd, Bz = Ln, Ym = wd, zz = wr, Wz = Tn, Uz = $o, Hz = mt, Vz = _s, Kz = Fs, qz = Vz("slice"), Gz = Hz("species"), vu = Array, Yz = Math.max;
Lz({ target: "Array", proto: !0, forced: !qz }, {
  slice: function(t, n) {
    var r = Wz(this), i = zz(r), o = Ym(t, i), a = Ym(n === void 0 ? i : n, i), s, l, u;
    if (Gm(r) && (s = r.constructor, Fz(s) && (s === vu || Gm(s.prototype)) ? s = void 0 : Bz(s) && (s = s[Gz], s === null && (s = void 0)), s === vu || s === void 0))
      return Kz(r, o, a);
    for (l = new (s === void 0 ? vu : s)(Yz(a - o, 0)), u = 0; o < a; o++, u++) o in r && Uz(l, u, r[o]);
    return l.length = u, l;
  }
});
var Xz = Sr, Jz = Xz("Array", "slice"), Zz = Fn, Qz = Jz, mu = Array.prototype, e5 = function(e) {
  var t = e.slice;
  return e === mu || Zz(mu, e) && t === mu.slice ? Qz : t;
}, t5 = e5, n5 = t5, r5 = n5, i5 = r5, o5 = i5, a5 = o5, s5 = a5;
const l5 = /* @__PURE__ */ Ce(s5);
var u5 = $n, Xm = rr, c5 = fd, f5 = function(e, t, n) {
  var r, i;
  Xm(e);
  try {
    if (r = c5(e, "return"), !r) {
      if (t === "throw") throw n;
      return n;
    }
    r = u5(r, e);
  } catch (o) {
    i = !0, r = o;
  }
  if (t === "throw") throw n;
  if (i) throw r;
  return Xm(r), n;
}, d5 = rr, p5 = f5, h5 = function(e, t, n, r) {
  try {
    return r ? t(d5(n)[0], n[1]) : t(n);
  } catch (i) {
    p5(e, "throw", i);
  }
}, v5 = mt, m5 = xi, g5 = v5("iterator"), y5 = Array.prototype, b5 = function(e) {
  return e !== void 0 && (m5.Array === e || y5[g5] === e);
}, x5 = $n, w5 = cd, S5 = rr, E5 = Ps, k5 = _d, C5 = TypeError, $5 = function(e, t) {
  var n = arguments.length < 2 ? k5(e) : t;
  if (w5(n)) return S5(x5(n, e));
  throw new C5(E5(e) + " is not iterable");
}, T5 = vd, O5 = $n, I5 = Bn, R5 = h5, P5 = b5, A5 = bd, D5 = wr, Jm = $o, _5 = $5, M5 = _d, Zm = Array, j5 = function(t) {
  var n = I5(t), r = A5(this), i = arguments.length, o = i > 1 ? arguments[1] : void 0, a = o !== void 0;
  a && (o = T5(o, i > 2 ? arguments[2] : void 0));
  var s = M5(n), l = 0, u, c, f, p, d, v;
  if (s && !(this === Zm && P5(s)))
    for (c = r ? new this() : [], p = _5(n, s), d = p.next; !(f = O5(d, p)).done; l++)
      v = a ? R5(p, o, [f.value, l], !0) : f.value, Jm(c, l, v);
  else
    for (u = D5(n), c = r ? new this(u) : Zm(u); u > l; l++)
      v = a ? o(n[l], l) : n[l], Jm(c, l, v);
  return c.length = l, c;
}, N5 = mt, U1 = N5("iterator"), H1 = !1;
try {
  var L5 = 0, Qm = {
    next: function() {
      return { done: !!L5++ };
    },
    return: function() {
      H1 = !0;
    }
  };
  Qm[U1] = function() {
    return this;
  }, Array.from(Qm, function() {
    throw 2;
  });
} catch {
}
var F5 = function(e, t) {
  try {
    if (!t && !H1) return !1;
  } catch {
    return !1;
  }
  var n = !1;
  try {
    var r = {};
    r[U1] = function() {
      return {
        next: function() {
          return { done: n = !0 };
        }
      };
    }, e(r);
  } catch {
  }
  return n;
}, B5 = Le, z5 = j5, W5 = F5, U5 = !W5(function(e) {
  Array.from(e);
});
B5({ target: "Array", stat: !0, forced: U5 }, {
  from: z5
});
var H5 = wt, V5 = H5.Array.from, K5 = V5, q5 = K5, G5 = q5, Y5 = G5, X5 = Y5, J5 = X5, Z5 = J5;
const V1 = /* @__PURE__ */ Ce(Z5);
function Fc(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function K1(e, t) {
  if (e) {
    var n;
    if (typeof e == "string") return Fc(e, t);
    var r = l5(n = {}.toString.call(e)).call(n, 8, -1);
    return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? V1(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Fc(e, t) : void 0;
  }
}
function Q5() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function bn(e, t) {
  return S2(e) || Nz(e, t) || K1(e, t) || Q5();
}
var q1 = { exports: {} };
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function n() {
      for (var r = [], i = 0; i < arguments.length; i++) {
        var o = arguments[i];
        if (o) {
          var a = typeof o;
          if (a === "string" || a === "number")
            r.push(o);
          else if (Array.isArray(o)) {
            if (o.length) {
              var s = n.apply(null, o);
              s && r.push(s);
            }
          } else if (a === "object")
            if (o.toString === Object.prototype.toString)
              for (var l in o)
                t.call(o, l) && o[l] && r.push(l);
            else
              r.push(o.toString());
        }
      }
      return r.join(" ");
    }
    e.exports ? (n.default = n, e.exports = n) : window.classNames = n;
  })();
})(q1);
var eW = q1.exports;
const Md = /* @__PURE__ */ Ce(eW);
var Bc = { exports: {} }, gu, eg;
function jd() {
  if (eg) return gu;
  eg = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return gu = e, gu;
}
var yu, tg;
function tW() {
  if (tg) return yu;
  tg = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = jd(), n = {}, r = Function.call.bind(Object.prototype.hasOwnProperty);
    e = function(o) {
      var a = "Warning: " + o;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function i(o, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in o)
        if (r(o, c)) {
          var f;
          try {
            if (typeof o[c] != "function") {
              var p = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[c] + "`."
              );
              throw p.name = "Invariant Violation", p;
            }
            f = o[c](a, c, l, s, null, t);
          } catch (v) {
            f = v;
          }
          if (f && !(f instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof f + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), f instanceof Error && !(f.message in n)) {
            n[f.message] = !0;
            var d = u ? u() : "";
            e(
              "Failed " + s + " type: " + f.message + (d ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, yu = i, yu;
}
var bu, ng;
function nW() {
  if (ng) return bu;
  ng = 1;
  var e = Ts(), t = aw(), n = jd(), r = tW(), i = Function.call.bind(Object.prototype.hasOwnProperty), o = function() {
  };
  process.env.NODE_ENV !== "production" && (o = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return bu = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function f(P) {
      var y = P && (u && P[u] || P[c]);
      if (typeof y == "function")
        return y;
    }
    var p = "<<anonymous>>", d = {
      array: m("array"),
      bool: m("boolean"),
      func: m("function"),
      number: m("number"),
      object: m("object"),
      string: m("string"),
      symbol: m("symbol"),
      any: b(),
      arrayOf: x,
      element: C(),
      elementType: S(),
      instanceOf: E,
      node: O(),
      objectOf: N,
      oneOf: T,
      oneOfType: j,
      shape: _,
      exact: V
    };
    function v(P, y) {
      return P === y ? P !== 0 || 1 / P === 1 / y : P !== P && y !== y;
    }
    function h(P) {
      this.message = P, this.stack = "";
    }
    h.prototype = Error.prototype;
    function g(P) {
      if (process.env.NODE_ENV !== "production")
        var y = {}, D = 0;
      function B(U, Y, K, G, Z, Q, X) {
        if (G = G || p, Q = Q || K, X !== n) {
          if (l) {
            var J = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw J.name = "Invariant Violation", J;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var H = G + ":" + K;
            !y[H] && // Avoid spamming the console because they are often not actionable except for lib authors
            D < 3 && (o(
              "You are manually calling a React.PropTypes validation function for the `" + Q + "` prop on `" + G + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), y[H] = !0, D++);
          }
        }
        return Y[K] == null ? U ? Y[K] === null ? new h("The " + Z + " `" + Q + "` is marked as required " + ("in `" + G + "`, but its value is `null`.")) : new h("The " + Z + " `" + Q + "` is marked as required in " + ("`" + G + "`, but its value is `undefined`.")) : null : P(Y, K, G, Z, Q);
      }
      var w = B.bind(null, !1);
      return w.isRequired = B.bind(null, !0), w;
    }
    function m(P) {
      function y(D, B, w, U, Y, K) {
        var G = D[B], Z = A(G);
        if (Z !== P) {
          var Q = M(G);
          return new h("Invalid " + U + " `" + Y + "` of type " + ("`" + Q + "` supplied to `" + w + "`, expected ") + ("`" + P + "`."));
        }
        return null;
      }
      return g(y);
    }
    function b() {
      return g(a);
    }
    function x(P) {
      function y(D, B, w, U, Y) {
        if (typeof P != "function")
          return new h("Property `" + Y + "` of component `" + w + "` has invalid PropType notation inside arrayOf.");
        var K = D[B];
        if (!Array.isArray(K)) {
          var G = A(K);
          return new h("Invalid " + U + " `" + Y + "` of type " + ("`" + G + "` supplied to `" + w + "`, expected an array."));
        }
        for (var Z = 0; Z < K.length; Z++) {
          var Q = P(K, Z, w, U, Y + "[" + Z + "]", n);
          if (Q instanceof Error)
            return Q;
        }
        return null;
      }
      return g(y);
    }
    function C() {
      function P(y, D, B, w, U) {
        var Y = y[D];
        if (!s(Y)) {
          var K = A(Y);
          return new h("Invalid " + w + " `" + U + "` of type " + ("`" + K + "` supplied to `" + B + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(P);
    }
    function S() {
      function P(y, D, B, w, U) {
        var Y = y[D];
        if (!e.isValidElementType(Y)) {
          var K = A(Y);
          return new h("Invalid " + w + " `" + U + "` of type " + ("`" + K + "` supplied to `" + B + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(P);
    }
    function E(P) {
      function y(D, B, w, U, Y) {
        if (!(D[B] instanceof P)) {
          var K = P.name || p, G = W(D[B]);
          return new h("Invalid " + U + " `" + Y + "` of type " + ("`" + G + "` supplied to `" + w + "`, expected ") + ("instance of `" + K + "`."));
        }
        return null;
      }
      return g(y);
    }
    function T(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? o(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : o("Invalid argument supplied to oneOf, expected an array.")), a;
      function y(D, B, w, U, Y) {
        for (var K = D[B], G = 0; G < P.length; G++)
          if (v(K, P[G]))
            return null;
        var Z = JSON.stringify(P, function(X, J) {
          var H = M(J);
          return H === "symbol" ? String(J) : J;
        });
        return new h("Invalid " + U + " `" + Y + "` of value `" + String(K) + "` " + ("supplied to `" + w + "`, expected one of " + Z + "."));
      }
      return g(y);
    }
    function N(P) {
      function y(D, B, w, U, Y) {
        if (typeof P != "function")
          return new h("Property `" + Y + "` of component `" + w + "` has invalid PropType notation inside objectOf.");
        var K = D[B], G = A(K);
        if (G !== "object")
          return new h("Invalid " + U + " `" + Y + "` of type " + ("`" + G + "` supplied to `" + w + "`, expected an object."));
        for (var Z in K)
          if (i(K, Z)) {
            var Q = P(K, Z, w, U, Y + "." + Z, n);
            if (Q instanceof Error)
              return Q;
          }
        return null;
      }
      return g(y);
    }
    function j(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && o("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var y = 0; y < P.length; y++) {
        var D = P[y];
        if (typeof D != "function")
          return o(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + q(D) + " at index " + y + "."
          ), a;
      }
      function B(w, U, Y, K, G) {
        for (var Z = 0; Z < P.length; Z++) {
          var Q = P[Z];
          if (Q(w, U, Y, K, G, n) == null)
            return null;
        }
        return new h("Invalid " + K + " `" + G + "` supplied to " + ("`" + Y + "`."));
      }
      return g(B);
    }
    function O() {
      function P(y, D, B, w, U) {
        return L(y[D]) ? null : new h("Invalid " + w + " `" + U + "` supplied to " + ("`" + B + "`, expected a ReactNode."));
      }
      return g(P);
    }
    function _(P) {
      function y(D, B, w, U, Y) {
        var K = D[B], G = A(K);
        if (G !== "object")
          return new h("Invalid " + U + " `" + Y + "` of type `" + G + "` " + ("supplied to `" + w + "`, expected `object`."));
        for (var Z in P) {
          var Q = P[Z];
          if (Q) {
            var X = Q(K, Z, w, U, Y + "." + Z, n);
            if (X)
              return X;
          }
        }
        return null;
      }
      return g(y);
    }
    function V(P) {
      function y(D, B, w, U, Y) {
        var K = D[B], G = A(K);
        if (G !== "object")
          return new h("Invalid " + U + " `" + Y + "` of type `" + G + "` " + ("supplied to `" + w + "`, expected `object`."));
        var Z = t({}, D[B], P);
        for (var Q in Z) {
          var X = P[Q];
          if (!X)
            return new h(
              "Invalid " + U + " `" + Y + "` key `" + Q + "` supplied to `" + w + "`.\nBad object: " + JSON.stringify(D[B], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var J = X(K, Q, w, U, Y + "." + Q, n);
          if (J)
            return J;
        }
        return null;
      }
      return g(y);
    }
    function L(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(L);
          if (P === null || s(P))
            return !0;
          var y = f(P);
          if (y) {
            var D = y.call(P), B;
            if (y !== P.entries) {
              for (; !(B = D.next()).done; )
                if (!L(B.value))
                  return !1;
            } else
              for (; !(B = D.next()).done; ) {
                var w = B.value;
                if (w && !L(w[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function I(P, y) {
      return P === "symbol" ? !0 : y ? y["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && y instanceof Symbol : !1;
    }
    function A(P) {
      var y = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : I(y, P) ? "symbol" : y;
    }
    function M(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var y = A(P);
      if (y === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return y;
    }
    function q(P) {
      var y = M(P);
      switch (y) {
        case "array":
        case "object":
          return "an " + y;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + y;
        default:
          return y;
      }
    }
    function W(P) {
      return !P.constructor || !P.constructor.name ? p : P.constructor.name;
    }
    return d.checkPropTypes = r, d.resetWarningCache = r.resetWarningCache, d.PropTypes = d, d;
  }, bu;
}
var xu, rg;
function rW() {
  if (rg) return xu;
  rg = 1;
  var e = jd();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, xu = function() {
    function r(a, s, l, u, c, f) {
      if (f !== e) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var o = {
      array: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return o.PropTypes = o, o;
  }, xu;
}
if (process.env.NODE_ENV !== "production") {
  var iW = Ts(), oW = !0;
  Bc.exports = nW()(iW.isElement, oW);
} else
  Bc.exports = rW()();
var aW = Bc.exports;
const $e = /* @__PURE__ */ Ce(aW);
var Nd = /* @__PURE__ */ Ne.createContext({
  scrollTo: function() {
    return 0;
  },
  scrollToBottom: function() {
    return 0;
  },
  scrollToEnd: function() {
    return 0;
  },
  scrollToStart: function() {
    return 0;
  },
  scrollToTop: function() {
    return 0;
  }
});
Nd.displayName = "ScrollToBottomFunctionContext";
function sW() {
  return li(Nd);
}
function lW() {
  var e = sW(), t = e.scrollToEnd;
  return t;
}
var Ld = /* @__PURE__ */ Ne.createContext({
  atBottom: !0,
  atEnd: !0,
  atStart: !1,
  atTop: !0,
  mode: "bottom"
});
Ld.displayName = "ScrollToBottomState1Context";
var Fd = /* @__PURE__ */ Ne.createContext({
  animating: !1,
  animatingToEnd: !1,
  sticky: !0
});
Fd.displayName = "ScrollToBottomState2Context";
var Bd = /* @__PURE__ */ Ne.createContext({
  animating: !1,
  animatingToEnd: !1,
  atBottom: !0,
  atEnd: !0,
  atStart: !1,
  atTop: !0,
  mode: "bottom",
  sticky: !0
});
Bd.displayName = "ScrollToBottomStateContext";
var ig = [Bd, Ld, Fd];
function uW(e) {
  return li(ig[e] || ig[0]);
}
function cW() {
  var e = uW(2), t = e.sticky;
  return [t];
}
var qs = /* @__PURE__ */ Ne.createContext({
  offsetHeight: 0,
  scrollHeight: 0,
  setTarget: function() {
    return 0;
  },
  styleToClassName: function() {
    return "";
  }
});
qs.displayName = "ScrollToBottomInternalContext";
function fW() {
  return li(qs);
}
function zd() {
  var e = fW(), t = e.styleToClassName;
  return t;
}
var dW = {
  backgroundColor: "rgba(0, 0, 0, .2)",
  borderRadius: 10,
  borderWidth: 0,
  bottom: 5,
  cursor: "pointer",
  height: 20,
  outline: 0,
  position: "absolute",
  right: 20,
  width: 20,
  "&:hover": {
    backgroundColor: "rgba(0, 0, 0, .4)"
  },
  "&:active": {
    backgroundColor: "rgba(0, 0, 0, .6)"
  }
}, Wd = function(t) {
  var n = t.children, r = t.className, i = cW(), o = bn(i, 1), a = o[0], s = zd()(dW), l = lW();
  return !a && /* @__PURE__ */ Ne.createElement("button", {
    className: Md(s, (r || "") + ""),
    onClick: l,
    type: "button"
  }, n);
};
Wd.defaultProps = {
  children: void 0,
  className: ""
};
Wd.propTypes = {
  children: $e.any,
  className: $e.string
};
var G1 = { exports: {} }, pW = Le, hW = Bt, og = dn.f;
pW({ target: "Object", stat: !0, forced: Object.defineProperty !== og, sham: !hW }, {
  defineProperty: og
});
var vW = wt, Y1 = vW.Object, mW = G1.exports = function(t, n, r) {
  return Y1.defineProperty(t, n, r);
};
Y1.defineProperty.sham && (mW.sham = !0);
var gW = G1.exports, yW = gW, X1 = yW, bW = X1, xW = bW, wW = xW, SW = wW, EW = SW;
const kW = /* @__PURE__ */ Ce(EW);
var CW = Io, $W = CW.f("iterator"), TW = $W, OW = TW, IW = OW, RW = IW, PW = RW, AW = PW, DW = AW;
const _W = /* @__PURE__ */ Ce(DW);
function ao(e) {
  "@babel/helpers - typeof";
  return ao = typeof Wr == "function" && typeof _W == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Wr == "function" && t.constructor === Wr && t !== Wr.prototype ? "symbol" : typeof t;
  }, ao(e);
}
var MW = Io, jW = MW.f("toPrimitive"), NW = jW, LW = NW, FW = LW, BW = FW, zW = BW, WW = zW, UW = WW;
const HW = /* @__PURE__ */ Ce(UW);
function VW(e, t) {
  if (ao(e) != "object" || !e) return e;
  var n = e[HW];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (ao(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function KW(e) {
  var t = VW(e, "string");
  return ao(t) == "symbol" ? t : t + "";
}
function qW(e, t, n) {
  return (t = KW(t)) in e ? kW(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function GW(e) {
  if (zw(e)) return Fc(e);
}
function YW(e) {
  if (typeof Wr < "u" && z1(e) != null || e["@@iterator"] != null) return V1(e);
}
function XW() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Ee(e) {
  return GW(e) || YW(e) || K1(e) || XW();
}
var ca = function(e) {
  return e && e.Math == Math && e;
}, Kt = (
  // eslint-disable-next-line es/no-global-this -- safe
  ca(typeof globalThis == "object" && globalThis) || ca(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  ca(typeof self == "object" && self) || ca(typeof an == "object" && an) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")()
), Ud = {}, pn = function(e) {
  try {
    return !!e();
  } catch {
    return !0;
  }
}, JW = pn, Er = !JW(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
}), J1 = {}, Z1 = {}.propertyIsEnumerable, Q1 = Object.getOwnPropertyDescriptor, ZW = Q1 && !Z1.call({ 1: 2 }, 1);
J1.f = ZW ? function(t) {
  var n = Q1(this, t);
  return !!n && n.enumerable;
} : Z1;
var eS = function(e, t) {
  return {
    enumerable: !(e & 1),
    configurable: !(e & 2),
    writable: !(e & 4),
    value: t
  };
}, QW = {}.toString, Hd = function(e) {
  return QW.call(e).slice(8, -1);
}, e6 = pn, t6 = Hd, n6 = "".split, r6 = e6(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(e) {
  return t6(e) == "String" ? n6.call(e, "") : Object(e);
} : Object, Gs = function(e) {
  if (e == null) throw TypeError("Can't call method on " + e);
  return e;
}, i6 = r6, o6 = Gs, Vd = function(e) {
  return i6(o6(e));
}, en = function(e) {
  return typeof e == "function";
}, a6 = en, Do = function(e) {
  return typeof e == "object" ? e !== null : a6(e);
}, wu = Kt, s6 = en, l6 = function(e) {
  return s6(e) ? e : void 0;
}, Ys = function(e, t) {
  return arguments.length < 2 ? l6(wu[e]) : wu[e] && wu[e][t];
}, u6 = Ys, c6 = u6("navigator", "userAgent") || "", tS = Kt, Su = c6, ag = tS.process, sg = tS.Deno, lg = ag && ag.versions || sg && sg.version, ug = lg && lg.v8, gn, ns;
ug ? (gn = ug.split("."), ns = gn[0] < 4 ? 1 : gn[0] + gn[1]) : Su && (gn = Su.match(/Edge\/(\d+)/), (!gn || gn[1] >= 74) && (gn = Su.match(/Chrome\/(\d+)/), gn && (ns = gn[1])));
var f6 = ns && +ns, cg = f6, d6 = pn, nS = !!Object.getOwnPropertySymbols && !d6(function() {
  var e = Symbol();
  return !String(e) || !(Object(e) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && cg && cg < 41;
}), p6 = nS, rS = p6 && !Symbol.sham && typeof Symbol.iterator == "symbol", h6 = en, v6 = Ys, m6 = rS, iS = m6 ? function(e) {
  return typeof e == "symbol";
} : function(e) {
  var t = v6("Symbol");
  return h6(t) && Object(e) instanceof t;
}, g6 = function(e) {
  try {
    return String(e);
  } catch {
    return "Object";
  }
}, y6 = en, b6 = g6, x6 = function(e) {
  if (y6(e)) return e;
  throw TypeError(b6(e) + " is not a function");
}, w6 = x6, oS = function(e, t) {
  var n = e[t];
  return n == null ? void 0 : w6(n);
}, Eu = en, ku = Do, S6 = function(e, t) {
  var n, r;
  if (t === "string" && Eu(n = e.toString) && !ku(r = n.call(e)) || Eu(n = e.valueOf) && !ku(r = n.call(e)) || t !== "string" && Eu(n = e.toString) && !ku(r = n.call(e))) return r;
  throw TypeError("Can't convert object to primitive value");
}, aS = { exports: {} }, fg = Kt, Kd = function(e, t) {
  try {
    Object.defineProperty(fg, e, { value: t, configurable: !0, writable: !0 });
  } catch {
    fg[e] = t;
  }
  return t;
}, E6 = Kt, k6 = Kd, dg = "__core-js_shared__", C6 = E6[dg] || k6(dg, {}), qd = C6, pg = qd;
(aS.exports = function(e, t) {
  return pg[e] || (pg[e] = t !== void 0 ? t : {});
})("versions", []).push({
  version: "3.18.3",
  mode: "global",
  copyright: "© 2021 Denis Pushkarev (zloirock.ru)"
});
var Gd = aS.exports, $6 = Gs, sS = function(e) {
  return Object($6(e));
}, T6 = sS, O6 = {}.hasOwnProperty, kr = Object.hasOwn || function(t, n) {
  return O6.call(T6(t), n);
}, I6 = 0, R6 = Math.random(), lS = function(e) {
  return "Symbol(" + String(e === void 0 ? "" : e) + ")_" + (++I6 + R6).toString(36);
}, P6 = Kt, A6 = Gd, hg = kr, D6 = lS, vg = nS, _6 = rS, Mi = A6("wks"), qi = P6.Symbol, M6 = _6 ? qi : qi && qi.withoutSetter || D6, _o = function(e) {
  return (!hg(Mi, e) || !(vg || typeof Mi[e] == "string")) && (vg && hg(qi, e) ? Mi[e] = qi[e] : Mi[e] = M6("Symbol." + e)), Mi[e];
}, mg = Do, gg = iS, j6 = oS, N6 = S6, L6 = _o, F6 = L6("toPrimitive"), B6 = function(e, t) {
  if (!mg(e) || gg(e)) return e;
  var n = j6(e, F6), r;
  if (n) {
    if (t === void 0 && (t = "default"), r = n.call(e, t), !mg(r) || gg(r)) return r;
    throw TypeError("Can't convert object to primitive value");
  }
  return t === void 0 && (t = "number"), N6(e, t);
}, z6 = B6, W6 = iS, uS = function(e) {
  var t = z6(e, "string");
  return W6(t) ? t : String(t);
}, U6 = Kt, yg = Do, zc = U6.document, H6 = yg(zc) && yg(zc.createElement), cS = function(e) {
  return H6 ? zc.createElement(e) : {};
}, V6 = Er, K6 = pn, q6 = cS, fS = !V6 && !K6(function() {
  return Object.defineProperty(q6("div"), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
}), G6 = Er, Y6 = J1, X6 = eS, J6 = Vd, Z6 = uS, Q6 = kr, eU = fS, bg = Object.getOwnPropertyDescriptor;
Ud.f = G6 ? bg : function(t, n) {
  if (t = J6(t), n = Z6(n), eU) try {
    return bg(t, n);
  } catch {
  }
  if (Q6(t, n)) return X6(!Y6.f.call(t, n), t[n]);
};
var Mo = {}, tU = Do, ir = function(e) {
  if (tU(e)) return e;
  throw TypeError(String(e) + " is not an object");
}, nU = Er, rU = fS, xg = ir, iU = uS, wg = Object.defineProperty;
Mo.f = nU ? wg : function(t, n, r) {
  if (xg(t), n = iU(n), xg(r), rU) try {
    return wg(t, n, r);
  } catch {
  }
  if ("get" in r || "set" in r) throw TypeError("Accessors not supported");
  return "value" in r && (t[n] = r.value), t;
};
var oU = Er, aU = Mo, sU = eS, Xs = oU ? function(e, t, n) {
  return aU.f(e, t, sU(1, n));
} : function(e, t, n) {
  return e[t] = n, e;
}, dS = { exports: {} }, lU = en, Wc = qd, uU = Function.toString;
lU(Wc.inspectSource) || (Wc.inspectSource = function(e) {
  return uU.call(e);
});
var pS = Wc.inspectSource, cU = Kt, fU = en, dU = pS, Sg = cU.WeakMap, pU = fU(Sg) && /native code/.test(dU(Sg)), hU = Gd, vU = lS, Eg = hU("keys"), hS = function(e) {
  return Eg[e] || (Eg[e] = vU(e));
}, Yd = {}, mU = pU, gU = Kt, yU = Do, bU = Xs, Cu = kr, $u = qd, xU = hS, wU = Yd, kg = "Object already initialized", SU = gU.WeakMap, rs, so, is, EU = function(e) {
  return is(e) ? so(e) : rs(e, {});
}, kU = function(e) {
  return function(t) {
    var n;
    if (!yU(t) || (n = so(t)).type !== e)
      throw TypeError("Incompatible receiver, " + e + " required");
    return n;
  };
};
if (mU || $u.state) {
  var cr = $u.state || ($u.state = new SU()), CU = cr.get, Cg = cr.has, $U = cr.set;
  rs = function(e, t) {
    if (Cg.call(cr, e)) throw new TypeError(kg);
    return t.facade = e, $U.call(cr, e, t), t;
  }, so = function(e) {
    return CU.call(cr, e) || {};
  }, is = function(e) {
    return Cg.call(cr, e);
  };
} else {
  var Ar = xU("state");
  wU[Ar] = !0, rs = function(e, t) {
    if (Cu(e, Ar)) throw new TypeError(kg);
    return t.facade = e, bU(e, Ar, t), t;
  }, so = function(e) {
    return Cu(e, Ar) ? e[Ar] : {};
  }, is = function(e) {
    return Cu(e, Ar);
  };
}
var vS = {
  set: rs,
  get: so,
  has: is,
  enforce: EU,
  getterFor: kU
}, Uc = Er, TU = kr, mS = Function.prototype, OU = Uc && Object.getOwnPropertyDescriptor, Xd = TU(mS, "name"), IU = Xd && (function() {
}).name === "something", RU = Xd && (!Uc || Uc && OU(mS, "name").configurable), Jd = {
  EXISTS: Xd,
  PROPER: IU,
  CONFIGURABLE: RU
}, PU = Kt, $g = en, AU = kr, Tg = Xs, DU = Kd, _U = pS, gS = vS, MU = Jd.CONFIGURABLE, jU = gS.get, NU = gS.enforce, LU = String(String).split("String");
(dS.exports = function(e, t, n, r) {
  var i = r ? !!r.unsafe : !1, o = r ? !!r.enumerable : !1, a = r ? !!r.noTargetGet : !1, s = r && r.name !== void 0 ? r.name : t, l;
  if ($g(n) && (String(s).slice(0, 7) === "Symbol(" && (s = "[" + String(s).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!AU(n, "name") || MU && n.name !== s) && Tg(n, "name", s), l = NU(n), l.source || (l.source = LU.join(typeof s == "string" ? s : ""))), e === PU) {
    o ? e[t] = n : DU(t, n);
    return;
  } else i ? !a && e[t] && (o = !0) : delete e[t];
  o ? e[t] = n : Tg(e, t, n);
})(Function.prototype, "toString", function() {
  return $g(this) && jU(this).source || _U(this);
});
var jo = dS.exports, yS = {}, FU = Math.ceil, BU = Math.floor, Js = function(e) {
  var t = +e;
  return t !== t || t === 0 ? 0 : (t > 0 ? BU : FU)(t);
}, zU = Js, WU = Math.max, UU = Math.min, HU = function(e, t) {
  var n = zU(e);
  return n < 0 ? WU(n + t, 0) : UU(n, t);
}, VU = Js, KU = Math.min, bS = function(e) {
  return e > 0 ? KU(VU(e), 9007199254740991) : 0;
}, qU = bS, GU = function(e) {
  return qU(e.length);
}, YU = Vd, XU = HU, JU = GU, Og = function(e) {
  return function(t, n, r) {
    var i = YU(t), o = JU(i), a = XU(r, o), s;
    if (e && n != n) {
      for (; o > a; )
        if (s = i[a++], s != s) return !0;
    } else for (; o > a; a++)
      if ((e || a in i) && i[a] === n) return e || a || 0;
    return !e && -1;
  };
}, ZU = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: Og(!0),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: Og(!1)
}, Tu = kr, QU = Vd, eH = ZU.indexOf, tH = Yd, xS = function(e, t) {
  var n = QU(e), r = 0, i = [], o;
  for (o in n) !Tu(tH, o) && Tu(n, o) && i.push(o);
  for (; t.length > r; ) Tu(n, o = t[r++]) && (~eH(i, o) || i.push(o));
  return i;
}, Zd = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
], nH = xS, rH = Zd, iH = rH.concat("length", "prototype");
yS.f = Object.getOwnPropertyNames || function(t) {
  return nH(t, iH);
};
var wS = {};
wS.f = Object.getOwnPropertySymbols;
var oH = Ys, aH = yS, sH = wS, lH = ir, uH = oH("Reflect", "ownKeys") || function(t) {
  var n = aH.f(lH(t)), r = sH.f;
  return r ? n.concat(r(t)) : n;
}, cH = kr, fH = uH, dH = Ud, pH = Mo, hH = function(e, t) {
  for (var n = fH(t), r = pH.f, i = dH.f, o = 0; o < n.length; o++) {
    var a = n[o];
    cH(e, a) || r(e, a, i(t, a));
  }
}, vH = pn, mH = en, gH = /#|\.prototype\./, No = function(e, t) {
  var n = bH[yH(e)];
  return n == wH ? !0 : n == xH ? !1 : mH(t) ? vH(t) : !!t;
}, yH = No.normalize = function(e) {
  return String(e).replace(gH, ".").toLowerCase();
}, bH = No.data = {}, xH = No.NATIVE = "N", wH = No.POLYFILL = "P", SH = No, Ou = Kt, EH = Ud.f, kH = Xs, CH = jo, $H = Kd, TH = hH, OH = SH, IH = function(e, t) {
  var n = e.target, r = e.global, i = e.stat, o, a, s, l, u, c;
  if (r ? a = Ou : i ? a = Ou[n] || $H(n, {}) : a = (Ou[n] || {}).prototype, a) for (s in t) {
    if (u = t[s], e.noTargetGet ? (c = EH(a, s), l = c && c.value) : l = a[s], o = OH(r ? s : n + (i ? "." : "#") + s, e.forced), !o && l !== void 0) {
      if (typeof u == typeof l) continue;
      TH(u, l);
    }
    (e.sham || l && l.sham) && kH(u, "sham", !0), CH(a, s, u, e);
  }
}, RH = _o, PH = RH("toStringTag"), SS = {};
SS[PH] = "z";
var Qd = String(SS) === "[object z]", AH = Qd, DH = en, Ta = Hd, _H = _o, MH = _H("toStringTag"), jH = Ta(/* @__PURE__ */ function() {
  return arguments;
}()) == "Arguments", NH = function(e, t) {
  try {
    return e[t];
  } catch {
  }
}, ES = AH ? Ta : function(e) {
  var t, n, r;
  return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (n = NH(t = Object(e), MH)) == "string" ? n : jH ? Ta(t) : (r = Ta(t)) == "Object" && DH(t.callee) ? "Arguments" : r;
}, LH = ES, Zs = function(e) {
  if (LH(e) === "Symbol") throw TypeError("Cannot convert a Symbol value to a string");
  return String(e);
}, FH = ir, kS = function() {
  var e = FH(this), t = "";
  return e.global && (t += "g"), e.ignoreCase && (t += "i"), e.multiline && (t += "m"), e.dotAll && (t += "s"), e.unicode && (t += "u"), e.sticky && (t += "y"), t;
}, ep = {}, CS = pn, BH = Kt, $S = BH.RegExp;
ep.UNSUPPORTED_Y = CS(function() {
  var e = $S("a", "y");
  return e.lastIndex = 2, e.exec("abcd") != null;
});
ep.BROKEN_CARET = CS(function() {
  var e = $S("^r", "gy");
  return e.lastIndex = 2, e.exec("str") != null;
});
var zH = xS, WH = Zd, UH = Object.keys || function(t) {
  return zH(t, WH);
}, HH = Er, VH = Mo, KH = ir, qH = UH, GH = HH ? Object.defineProperties : function(t, n) {
  KH(t);
  for (var r = qH(n), i = r.length, o = 0, a; i > o; ) VH.f(t, a = r[o++], n[a]);
  return t;
}, YH = Ys, XH = YH("document", "documentElement"), JH = ir, ZH = GH, Ig = Zd, QH = Yd, e9 = XH, t9 = cS, n9 = hS, Rg = ">", Pg = "<", Hc = "prototype", Vc = "script", TS = n9("IE_PROTO"), Iu = function() {
}, OS = function(e) {
  return Pg + Vc + Rg + e + Pg + "/" + Vc + Rg;
}, Ag = function(e) {
  e.write(OS("")), e.close();
  var t = e.parentWindow.Object;
  return e = null, t;
}, r9 = function() {
  var e = t9("iframe"), t = "java" + Vc + ":", n;
  return e.style.display = "none", e9.appendChild(e), e.src = String(t), n = e.contentWindow.document, n.open(), n.write(OS("document.F=Object")), n.close(), n.F;
}, fa, Oa = function() {
  try {
    fa = new ActiveXObject("htmlfile");
  } catch {
  }
  Oa = typeof document < "u" ? document.domain && fa ? Ag(fa) : r9() : Ag(fa);
  for (var e = Ig.length; e--; ) delete Oa[Hc][Ig[e]];
  return Oa();
};
QH[TS] = !0;
var i9 = Object.create || function(t, n) {
  var r;
  return t !== null ? (Iu[Hc] = JH(t), r = new Iu(), Iu[Hc] = null, r[TS] = t) : r = Oa(), n === void 0 ? r : ZH(r, n);
}, o9 = pn, a9 = Kt, s9 = a9.RegExp, l9 = o9(function() {
  var e = s9(".", "s");
  return !(e.dotAll && e.exec(`
`) && e.flags === "s");
}), u9 = pn, c9 = Kt, f9 = c9.RegExp, d9 = u9(function() {
  var e = f9("(?<a>b)", "g");
  return e.exec("b").groups.a !== "b" || "b".replace(e, "$<a>c") !== "bc";
}), p9 = Zs, h9 = kS, Dg = ep, v9 = Gd, m9 = i9, g9 = vS.get, y9 = l9, b9 = d9, os = RegExp.prototype.exec, x9 = v9("native-string-replace", String.prototype.replace), Kc = os, qc = function() {
  var e = /a/, t = /b*/g;
  return os.call(e, "a"), os.call(t, "a"), e.lastIndex !== 0 || t.lastIndex !== 0;
}(), IS = Dg.UNSUPPORTED_Y || Dg.BROKEN_CARET, Gc = /()??/.exec("")[1] !== void 0, w9 = qc || Gc || IS || y9 || b9;
w9 && (Kc = function(t) {
  var n = this, r = g9(n), i = p9(t), o = r.raw, a, s, l, u, c, f, p;
  if (o)
    return o.lastIndex = n.lastIndex, a = Kc.call(o, i), n.lastIndex = o.lastIndex, a;
  var d = r.groups, v = IS && n.sticky, h = h9.call(n), g = n.source, m = 0, b = i;
  if (v && (h = h.replace("y", ""), h.indexOf("g") === -1 && (h += "g"), b = i.slice(n.lastIndex), n.lastIndex > 0 && (!n.multiline || n.multiline && i.charAt(n.lastIndex - 1) !== `
`) && (g = "(?: " + g + ")", b = " " + b, m++), s = new RegExp("^(?:" + g + ")", h)), Gc && (s = new RegExp("^" + g + "$(?!\\s)", h)), qc && (l = n.lastIndex), u = os.call(v ? s : n, b), v ? u ? (u.input = u.input.slice(m), u[0] = u[0].slice(m), u.index = n.lastIndex, n.lastIndex += u[0].length) : n.lastIndex = 0 : qc && u && (n.lastIndex = n.global ? u.index + u[0].length : l), Gc && u && u.length > 1 && x9.call(u[0], s, function() {
    for (c = 1; c < arguments.length - 2; c++)
      arguments[c] === void 0 && (u[c] = void 0);
  }), u && d)
    for (u.groups = f = m9(null), c = 0; c < d.length; c++)
      p = d[c], f[p[0]] = u[p[1]];
  return u;
});
var tp = Kc, S9 = IH, _g = tp;
S9({ target: "RegExp", proto: !0, forced: /./.exec !== _g }, {
  exec: _g
});
var Mg = jo, E9 = tp, jg = pn, RS = _o, k9 = Xs, C9 = RS("species"), Ru = RegExp.prototype, $9 = function(e, t, n, r) {
  var i = RS(e), o = !jg(function() {
    var u = {};
    return u[i] = function() {
      return 7;
    }, ""[e](u) != 7;
  }), a = o && !jg(function() {
    var u = !1, c = /a/;
    return e === "split" && (c = {}, c.constructor = {}, c.constructor[C9] = function() {
      return c;
    }, c.flags = "", c[i] = /./[i]), c.exec = function() {
      return u = !0, null;
    }, c[i](""), !u;
  });
  if (!o || !a || n) {
    var s = /./[i], l = t(i, ""[e], function(u, c, f, p, d) {
      var v = c.exec;
      return v === E9 || v === Ru.exec ? o && !d ? { done: !0, value: s.call(c, f, p) } : { done: !0, value: u.call(f, c, p) } : { done: !1 };
    });
    Mg(String.prototype, e, l[0]), Mg(Ru, i, l[1]);
  }
  r && k9(Ru[i], "sham", !0);
}, T9 = Js, O9 = Zs, I9 = Gs, Ng = function(e) {
  return function(t, n) {
    var r = O9(I9(t)), i = T9(n), o = r.length, a, s;
    return i < 0 || i >= o ? e ? "" : void 0 : (a = r.charCodeAt(i), a < 55296 || a > 56319 || i + 1 === o || (s = r.charCodeAt(i + 1)) < 56320 || s > 57343 ? e ? r.charAt(i) : a : e ? r.slice(i, i + 2) : (a - 55296 << 10) + (s - 56320) + 65536);
  };
}, R9 = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: Ng(!1),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: Ng(!0)
}, P9 = R9.charAt, A9 = function(e, t, n) {
  return t + (n ? P9(e, t).length : 1);
}, D9 = sS, _9 = Math.floor, M9 = "".replace, j9 = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, N9 = /\$([$&'`]|\d{1,2})/g, L9 = function(e, t, n, r, i, o) {
  var a = n + e.length, s = r.length, l = N9;
  return i !== void 0 && (i = D9(i), l = j9), M9.call(o, l, function(u, c) {
    var f;
    switch (c.charAt(0)) {
      case "$":
        return "$";
      case "&":
        return e;
      case "`":
        return t.slice(0, n);
      case "'":
        return t.slice(a);
      case "<":
        f = i[c.slice(1, -1)];
        break;
      default:
        var p = +c;
        if (p === 0) return u;
        if (p > s) {
          var d = _9(p / 10);
          return d === 0 ? u : d <= s ? r[d - 1] === void 0 ? c.charAt(1) : r[d - 1] + c.charAt(1) : u;
        }
        f = r[p - 1];
    }
    return f === void 0 ? "" : f;
  });
}, F9 = ir, B9 = en, z9 = Hd, W9 = tp, U9 = function(e, t) {
  var n = e.exec;
  if (B9(n)) {
    var r = n.call(e, t);
    return r !== null && F9(r), r;
  }
  if (z9(e) === "RegExp") return W9.call(e, t);
  throw TypeError("RegExp#exec called on incompatible receiver");
}, H9 = $9, V9 = pn, K9 = ir, q9 = en, G9 = Js, Y9 = bS, Dr = Zs, X9 = Gs, J9 = A9, Z9 = oS, Q9 = L9, eV = U9, tV = _o, Yc = tV("replace"), nV = Math.max, rV = Math.min, iV = function(e) {
  return e === void 0 ? e : String(e);
}, oV = function() {
  return "a".replace(/./, "$0") === "$0";
}(), Lg = function() {
  return /./[Yc] ? /./[Yc]("a", "$0") === "" : !1;
}(), aV = !V9(function() {
  var e = /./;
  return e.exec = function() {
    var t = [];
    return t.groups = { a: "7" }, t;
  }, "".replace(e, "$<a>") !== "7";
});
H9("replace", function(e, t, n) {
  var r = Lg ? "$" : "$0";
  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function(o, a) {
      var s = X9(this), l = o == null ? void 0 : Z9(o, Yc);
      return l ? l.call(o, s, a) : t.call(Dr(s), o, a);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function(i, o) {
      var a = K9(this), s = Dr(i);
      if (typeof o == "string" && o.indexOf(r) === -1 && o.indexOf("$<") === -1) {
        var l = n(t, a, s, o);
        if (l.done) return l.value;
      }
      var u = q9(o);
      u || (o = Dr(o));
      var c = a.global;
      if (c) {
        var f = a.unicode;
        a.lastIndex = 0;
      }
      for (var p = []; ; ) {
        var d = eV(a, s);
        if (d === null || (p.push(d), !c)) break;
        var v = Dr(d[0]);
        v === "" && (a.lastIndex = J9(s, Y9(a.lastIndex), f));
      }
      for (var h = "", g = 0, m = 0; m < p.length; m++) {
        d = p[m];
        for (var b = Dr(d[0]), x = nV(rV(G9(d.index), s.length), 0), C = [], S = 1; S < d.length; S++) C.push(iV(d[S]));
        var E = d.groups;
        if (u) {
          var T = [b].concat(C, x, s);
          E !== void 0 && T.push(E);
          var N = Dr(o.apply(void 0, T));
        } else
          N = Q9(b, s, x, C, E, o);
        x >= g && (h += s.slice(g, x) + N, g = x + b.length);
      }
      return h + s.slice(g);
    }
  ];
}, !aV || !oV || Lg);
var ji = dt, sV = ld, lV = xr, da = function(e) {
  return sV.slice(0, e.length) === e;
}, uV = function() {
  return da("Bun/") ? "BUN" : da("Cloudflare-Workers") ? "CLOUDFLARE" : da("Deno/") ? "DENO" : da("Node.js/") ? "NODE" : ji.Bun && typeof Bun.version == "string" ? "BUN" : ji.Deno && typeof Deno.version == "object" ? "DENO" : lV(ji.process) === "process" ? "NODE" : ji.window && ji.document ? "BROWSER" : "REST";
}(), cV = TypeError, fV = function(e, t) {
  if (e < t) throw new cV("Not enough arguments");
  return e;
}, PS = dt, dV = rd, pV = Rt, hV = uV, vV = ld, mV = Fs, gV = fV, yV = PS.Function, bV = /MSIE .\./.test(vV) || hV === "BUN" && function() {
  var e = PS.Bun.version.split(".");
  return e.length < 3 || e[0] === "0" && (e[1] < 3 || e[1] === "3" && e[2] === "0");
}(), AS = function(e, t) {
  var n = t ? 2 : 1;
  return bV ? function(r, i) {
    var o = gV(arguments.length, 1) > n, a = pV(r) ? r : yV(r), s = o ? mV(arguments, n) : [], l = o ? function() {
      dV(a, this, s);
    } : a;
    return t ? e(l, i) : e(l);
  } : e;
}, xV = Le, DS = dt, wV = AS, Fg = wV(DS.setInterval, !0);
xV({ global: !0, bind: !0, forced: DS.setInterval !== Fg }, {
  setInterval: Fg
});
var SV = Le, _S = dt, EV = AS, Bg = EV(_S.setTimeout, !0);
SV({ global: !0, bind: !0, forced: _S.setTimeout !== Bg }, {
  setTimeout: Bg
});
var kV = wt, CV = kV.setInterval, $V = CV;
const TV = /* @__PURE__ */ Ce($V);
var OV = pt, MS = function(e, t) {
  var n = [][e];
  return !!n && OV(function() {
    n.call(null, t || function() {
      return 1;
    }, 1);
  });
}, IV = Le, RV = id, PV = Gw.indexOf, AV = MS, Xc = RV([].indexOf), jS = !!Xc && 1 / Xc([1], 1, -0) < 0, DV = jS || !AV("indexOf");
IV({ target: "Array", proto: !0, forced: DV }, {
  indexOf: function(t) {
    var n = arguments.length > 1 ? arguments[1] : void 0;
    return jS ? Xc(this, t, n) || 0 : PV(this, t, n);
  }
});
var _V = Sr, MV = _V("Array", "indexOf"), jV = Fn, NV = MV, Pu = Array.prototype, LV = function(e) {
  var t = e.indexOf;
  return e === Pu || jV(Pu, e) && t === Pu.indexOf ? NV : t;
}, FV = LV, BV = FV, zV = BV;
const WV = /* @__PURE__ */ Ce(zV);
var zg = Ps, UV = TypeError, HV = function(e, t) {
  if (!delete e[t]) throw new UV("Cannot delete property " + zg(t) + " of " + zg(e));
}, VV = Le, KV = Bn, qV = wd, GV = Ds, YV = wr, XV = W1, JV = md, ZV = xd, QV = $o, Au = HV, e7 = _s, t7 = e7("splice"), n7 = Math.max, r7 = Math.min;
VV({ target: "Array", proto: !0, forced: !t7 }, {
  splice: function(t, n) {
    var r = KV(this), i = YV(r), o = qV(t, i), a = arguments.length, s, l, u, c, f, p;
    for (a === 0 ? s = l = 0 : a === 1 ? (s = 0, l = i - o) : (s = a - 2, l = r7(n7(GV(n), 0), i - o)), JV(i + s - l), u = ZV(r, l), c = 0; c < l; c++)
      f = o + c, f in r && QV(u, c, r[f]);
    if (u.length = l, s < l) {
      for (c = o; c < i - l; c++)
        f = c + l, p = c + s, f in r ? r[p] = r[f] : Au(r, p);
      for (c = i; c > i - l + s; c--) Au(r, c - 1);
    } else if (s > l)
      for (c = i - l; c > o; c--)
        f = c + l - 1, p = c + s - 1, f in r ? r[p] = r[f] : Au(r, p);
    for (c = 0; c < s; c++)
      r[c + o] = arguments[c + 2];
    return XV(r, i - l + s), u;
  }
});
var i7 = Sr, o7 = i7("Array", "splice"), a7 = Fn, s7 = o7, Du = Array.prototype, l7 = function(e) {
  var t = e.splice;
  return e === Du || a7(Du, e) && t === Du.splice ? s7 : t;
}, u7 = l7, c7 = u7, f7 = c7;
const d7 = /* @__PURE__ */ Ce(f7);
var p7 = Sr, h7 = p7("Array", "concat"), v7 = Fn, m7 = h7, _u = Array.prototype, g7 = function(e) {
  var t = e.concat;
  return e === _u || v7(_u, e) && t === _u.concat ? m7 : t;
}, y7 = g7, b7 = y7, x7 = b7;
const Xe = /* @__PURE__ */ Ce(x7);
var w7 = Le, S7 = ht, NS = Date, E7 = S7(NS.prototype.getTime);
w7({ target: "Date", stat: !0 }, {
  now: function() {
    return E7(new NS());
  }
});
var k7 = wt, C7 = k7.Date.now, $7 = C7, T7 = $7, O7 = T7;
const Jn = /* @__PURE__ */ Ce(O7);
var I7 = $d.forEach, R7 = MS, P7 = R7("forEach"), A7 = P7 ? [].forEach : function(t) {
  return I7(this, t, arguments.length > 1 ? arguments[1] : void 0);
}, D7 = Le, Wg = A7;
D7({ target: "Array", proto: !0, forced: [].forEach !== Wg }, {
  forEach: Wg
});
var _7 = Sr, M7 = _7("Array", "forEach"), j7 = M7, N7 = j7, L7 = To, F7 = Vt, B7 = Fn, z7 = N7, Mu = Array.prototype, W7 = {
  DOMTokenList: !0,
  NodeList: !0
}, U7 = function(e) {
  var t = e.forEach;
  return e === Mu || B7(Mu, e) && t === Mu.forEach || F7(W7, L7(e)) ? z7 : t;
}, H7 = U7;
const as = /* @__PURE__ */ Ce(H7);
var V7 = Le, K7 = Bn, LS = Ed, q7 = pt, G7 = q7(function() {
  LS(1);
});
V7({ target: "Object", stat: !0, forced: G7 }, {
  keys: function(t) {
    return LS(K7(t));
  }
});
var Y7 = wt, X7 = Y7.Object.keys, J7 = X7, Z7 = J7, Q7 = Z7;
const eK = /* @__PURE__ */ Ce(Q7);
var tK = wt, nK = tK.Object.getOwnPropertySymbols, rK = nK, iK = rK, oK = iK;
const Ug = /* @__PURE__ */ Ce(oK);
var aK = Le, sK = $d.filter, lK = _s, uK = lK("filter");
aK({ target: "Array", proto: !0, forced: !uK }, {
  filter: function(t) {
    return sK(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var cK = Sr, fK = cK("Array", "filter"), dK = Fn, pK = fK, ju = Array.prototype, hK = function(e) {
  var t = e.filter;
  return e === ju || dK(ju, e) && t === ju.filter ? pK : t;
}, vK = hK, mK = vK, gK = mK;
const yK = /* @__PURE__ */ Ce(gK);
var FS = { exports: {} }, bK = Le, xK = pt, wK = Tn, BS = So.f, zS = Bt, SK = !zS || xK(function() {
  BS(1);
});
bK({ target: "Object", stat: !0, forced: SK, sham: !zS }, {
  getOwnPropertyDescriptor: function(t, n) {
    return BS(wK(t), n);
  }
});
var EK = wt, WS = EK.Object, kK = FS.exports = function(t, n) {
  return WS.getOwnPropertyDescriptor(t, n);
};
WS.getOwnPropertyDescriptor.sham && (kK.sham = !0);
var CK = FS.exports, $K = CK, TK = $K, OK = TK;
const US = /* @__PURE__ */ Ce(OK);
var IK = On, RK = ht, PK = Ls, AK = Bs, DK = rr, _K = RK([].concat), MK = IK("Reflect", "ownKeys") || function(t) {
  var n = PK.f(DK(t)), r = AK.f;
  return r ? _K(n, r(t)) : n;
}, jK = Le, NK = Bt, LK = MK, FK = Tn, BK = So, zK = $o;
jK({ target: "Object", stat: !0, sham: !NK }, {
  getOwnPropertyDescriptors: function(t) {
    for (var n = FK(t), r = BK.f, i = LK(n), o = {}, a = 0, s, l; i.length > a; )
      l = r(n, s = i[a++]), l !== void 0 && zK(o, s, l);
    return o;
  }
});
var WK = wt, UK = WK.Object.getOwnPropertyDescriptors, HK = UK, VK = HK, KK = VK;
const Hg = /* @__PURE__ */ Ce(KK);
var HS = { exports: {} }, qK = Le, GK = Bt, Vg = Ms.f;
qK({ target: "Object", stat: !0, forced: Object.defineProperties !== Vg, sham: !GK }, {
  defineProperties: Vg
});
var YK = wt, VS = YK.Object, XK = HS.exports = function(t, n) {
  return VS.defineProperties(t, n);
};
VS.defineProperties.sham && (XK.sham = !0);
var JK = HS.exports, ZK = JK, QK = ZK, eq = QK;
const tq = /* @__PURE__ */ Ce(eq);
var nq = X1;
const rq = /* @__PURE__ */ Ce(nq);
var iq = !1;
function oq(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function aq(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var sq = /* @__PURE__ */ function() {
  function e(n) {
    var r = this;
    this._insertTag = function(i) {
      var o;
      r.tags.length === 0 ? r.insertionPoint ? o = r.insertionPoint.nextSibling : r.prepend ? o = r.container.firstChild : o = r.before : o = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, o), r.tags.push(i);
    }, this.isSpeedy = n.speedy === void 0 ? !iq : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(r) {
    r.forEach(this._insertTag);
  }, t.insert = function(r) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(aq(this));
    var i = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var o = oq(i);
      try {
        o.insertRule(r, o.cssRules.length);
      } catch {
      }
    } else
      i.appendChild(document.createTextNode(r));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(r) {
      var i;
      return (i = r.parentNode) == null ? void 0 : i.removeChild(r);
    }), this.tags = [], this.ctr = 0;
  }, e;
}(), Ct = "-ms-", ss = "-moz-", Pe = "-webkit-", KS = "comm", np = "rule", rp = "decl", lq = "@import", qS = "@keyframes", uq = "@layer", cq = Math.abs, Qs = String.fromCharCode, fq = Object.assign;
function dq(e, t) {
  return xt(e, 0) ^ 45 ? (((t << 2 ^ xt(e, 0)) << 2 ^ xt(e, 1)) << 2 ^ xt(e, 2)) << 2 ^ xt(e, 3) : 0;
}
function GS(e) {
  return e.trim();
}
function pq(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function Ae(e, t, n) {
  return e.replace(t, n);
}
function Jc(e, t) {
  return e.indexOf(t);
}
function xt(e, t) {
  return e.charCodeAt(t) | 0;
}
function lo(e, t, n) {
  return e.slice(t, n);
}
function xn(e) {
  return e.length;
}
function ip(e) {
  return e.length;
}
function pa(e, t) {
  return t.push(e), e;
}
function hq(e, t) {
  return e.map(t).join("");
}
var el = 1, si = 1, YS = 0, Ft = 0, st = 0, wi = "";
function tl(e, t, n, r, i, o, a) {
  return { value: e, root: t, parent: n, type: r, props: i, children: o, line: el, column: si, length: a, return: "" };
}
function Ni(e, t) {
  return fq(tl("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function vq() {
  return st;
}
function mq() {
  return st = Ft > 0 ? xt(wi, --Ft) : 0, si--, st === 10 && (si = 1, el--), st;
}
function Ht() {
  return st = Ft < YS ? xt(wi, Ft++) : 0, si++, st === 10 && (si = 1, el++), st;
}
function Sn() {
  return xt(wi, Ft);
}
function Ia() {
  return Ft;
}
function Lo(e, t) {
  return lo(wi, e, t);
}
function uo(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function XS(e) {
  return el = si = 1, YS = xn(wi = e), Ft = 0, [];
}
function JS(e) {
  return wi = "", e;
}
function Ra(e) {
  return GS(Lo(Ft - 1, Zc(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function gq(e) {
  for (; (st = Sn()) && st < 33; )
    Ht();
  return uo(e) > 2 || uo(st) > 3 ? "" : " ";
}
function yq(e, t) {
  for (; --t && Ht() && !(st < 48 || st > 102 || st > 57 && st < 65 || st > 70 && st < 97); )
    ;
  return Lo(e, Ia() + (t < 6 && Sn() == 32 && Ht() == 32));
}
function Zc(e) {
  for (; Ht(); )
    switch (st) {
      case e:
        return Ft;
      case 34:
      case 39:
        e !== 34 && e !== 39 && Zc(st);
        break;
      case 40:
        e === 41 && Zc(e);
        break;
      case 92:
        Ht();
        break;
    }
  return Ft;
}
function bq(e, t) {
  for (; Ht() && e + st !== 57; )
    if (e + st === 84 && Sn() === 47)
      break;
  return "/*" + Lo(t, Ft - 1) + "*" + Qs(e === 47 ? e : Ht());
}
function xq(e) {
  for (; !uo(Sn()); )
    Ht();
  return Lo(e, Ft);
}
function wq(e) {
  return JS(Pa("", null, null, null, [""], e = XS(e), 0, [0], e));
}
function Pa(e, t, n, r, i, o, a, s, l) {
  for (var u = 0, c = 0, f = a, p = 0, d = 0, v = 0, h = 1, g = 1, m = 1, b = 0, x = "", C = i, S = o, E = r, T = x; g; )
    switch (v = b, b = Ht()) {
      case 40:
        if (v != 108 && xt(T, f - 1) == 58) {
          Jc(T += Ae(Ra(b), "&", "&\f"), "&\f") != -1 && (m = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        T += Ra(b);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        T += gq(v);
        break;
      case 92:
        T += yq(Ia() - 1, 7);
        continue;
      case 47:
        switch (Sn()) {
          case 42:
          case 47:
            pa(Sq(bq(Ht(), Ia()), t, n), l);
            break;
          default:
            T += "/";
        }
        break;
      case 123 * h:
        s[u++] = xn(T) * m;
      case 125 * h:
      case 59:
      case 0:
        switch (b) {
          case 0:
          case 125:
            g = 0;
          case 59 + c:
            m == -1 && (T = Ae(T, /\f/g, "")), d > 0 && xn(T) - f && pa(d > 32 ? qg(T + ";", r, n, f - 1) : qg(Ae(T, " ", "") + ";", r, n, f - 2), l);
            break;
          case 59:
            T += ";";
          default:
            if (pa(E = Kg(T, t, n, u, c, i, s, x, C = [], S = [], f), o), b === 123)
              if (c === 0)
                Pa(T, t, E, E, C, o, f, s, S);
              else
                switch (p === 99 && xt(T, 3) === 110 ? 100 : p) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Pa(e, E, E, r && pa(Kg(e, E, E, 0, 0, i, s, x, i, C = [], f), S), i, S, f, s, r ? C : S);
                    break;
                  default:
                    Pa(T, E, E, E, [""], S, 0, s, S);
                }
        }
        u = c = d = 0, h = m = 1, x = T = "", f = a;
        break;
      case 58:
        f = 1 + xn(T), d = v;
      default:
        if (h < 1) {
          if (b == 123)
            --h;
          else if (b == 125 && h++ == 0 && mq() == 125)
            continue;
        }
        switch (T += Qs(b), b * h) {
          case 38:
            m = c > 0 ? 1 : (T += "\f", -1);
            break;
          case 44:
            s[u++] = (xn(T) - 1) * m, m = 1;
            break;
          case 64:
            Sn() === 45 && (T += Ra(Ht())), p = Sn(), c = f = xn(x = T += xq(Ia())), b++;
            break;
          case 45:
            v === 45 && xn(T) == 2 && (h = 0);
        }
    }
  return o;
}
function Kg(e, t, n, r, i, o, a, s, l, u, c) {
  for (var f = i - 1, p = i === 0 ? o : [""], d = ip(p), v = 0, h = 0, g = 0; v < r; ++v)
    for (var m = 0, b = lo(e, f + 1, f = cq(h = a[v])), x = e; m < d; ++m)
      (x = GS(h > 0 ? p[m] + " " + b : Ae(b, /&\f/g, p[m]))) && (l[g++] = x);
  return tl(e, t, n, i === 0 ? np : s, l, u, c);
}
function Sq(e, t, n) {
  return tl(e, t, n, KS, Qs(vq()), lo(e, 2, -2), 0);
}
function qg(e, t, n, r) {
  return tl(e, t, n, rp, lo(e, 0, r), lo(e, r + 1, -1), r);
}
function Gr(e, t) {
  for (var n = "", r = ip(e), i = 0; i < r; i++)
    n += t(e[i], i, e, t) || "";
  return n;
}
function Eq(e, t, n, r) {
  switch (e.type) {
    case uq:
      if (e.children.length) break;
    case lq:
    case rp:
      return e.return = e.return || e.value;
    case KS:
      return "";
    case qS:
      return e.return = e.value + "{" + Gr(e.children, r) + "}";
    case np:
      e.value = e.props.join(",");
  }
  return xn(n = Gr(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function kq(e) {
  var t = ip(e);
  return function(n, r, i, o) {
    for (var a = "", s = 0; s < t; s++)
      a += e[s](n, r, i, o) || "";
    return a;
  };
}
function Cq(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function $q(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var Tq = function(t, n, r) {
  for (var i = 0, o = 0; i = o, o = Sn(), i === 38 && o === 12 && (n[r] = 1), !uo(o); )
    Ht();
  return Lo(t, Ft);
}, Oq = function(t, n) {
  var r = -1, i = 44;
  do
    switch (uo(i)) {
      case 0:
        i === 38 && Sn() === 12 && (n[r] = 1), t[r] += Tq(Ft - 1, n, r);
        break;
      case 2:
        t[r] += Ra(i);
        break;
      case 4:
        if (i === 44) {
          t[++r] = Sn() === 58 ? "&\f" : "", n[r] = t[r].length;
          break;
        }
      default:
        t[r] += Qs(i);
    }
  while (i = Ht());
  return t;
}, Iq = function(t, n) {
  return JS(Oq(XS(t), n));
}, Gg = /* @__PURE__ */ new WeakMap(), Rq = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, r = t.parent, i = t.column === r.column && t.line === r.line; r.type !== "rule"; )
      if (r = r.parent, !r) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !Gg.get(r)) && !i) {
      Gg.set(t, !0);
      for (var o = [], a = Iq(n, o), s = r.props, l = 0, u = 0; l < a.length; l++)
        for (var c = 0; c < s.length; c++, u++)
          t.props[u] = o[l] ? a[l].replace(/&\f/g, s[c]) : s[c] + " " + a[l];
    }
  }
}, Pq = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function ZS(e, t) {
  switch (dq(e, t)) {
    case 5103:
      return Pe + "print-" + e + e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Pe + e + e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Pe + e + ss + e + Ct + e + e;
    case 6828:
    case 4268:
      return Pe + e + Ct + e + e;
    case 6165:
      return Pe + e + Ct + "flex-" + e + e;
    case 5187:
      return Pe + e + Ae(e, /(\w+).+(:[^]+)/, Pe + "box-$1$2" + Ct + "flex-$1$2") + e;
    case 5443:
      return Pe + e + Ct + "flex-item-" + Ae(e, /flex-|-self/, "") + e;
    case 4675:
      return Pe + e + Ct + "flex-line-pack" + Ae(e, /align-content|flex-|-self/, "") + e;
    case 5548:
      return Pe + e + Ct + Ae(e, "shrink", "negative") + e;
    case 5292:
      return Pe + e + Ct + Ae(e, "basis", "preferred-size") + e;
    case 6060:
      return Pe + "box-" + Ae(e, "-grow", "") + Pe + e + Ct + Ae(e, "grow", "positive") + e;
    case 4554:
      return Pe + Ae(e, /([^-])(transform)/g, "$1" + Pe + "$2") + e;
    case 6187:
      return Ae(Ae(Ae(e, /(zoom-|grab)/, Pe + "$1"), /(image-set)/, Pe + "$1"), e, "") + e;
    case 5495:
    case 3959:
      return Ae(e, /(image-set\([^]*)/, Pe + "$1$`$1");
    case 4968:
      return Ae(Ae(e, /(.+:)(flex-)?(.*)/, Pe + "box-pack:$3" + Ct + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Pe + e + e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Ae(e, /(.+)-inline(.+)/, Pe + "$1$2") + e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (xn(e) - 1 - t > 6) switch (xt(e, t + 1)) {
        case 109:
          if (xt(e, t + 4) !== 45) break;
        case 102:
          return Ae(e, /(.+:)(.+)-([^]+)/, "$1" + Pe + "$2-$3$1" + ss + (xt(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        case 115:
          return ~Jc(e, "stretch") ? ZS(Ae(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    case 4949:
      if (xt(e, t + 1) !== 115) break;
    case 6444:
      switch (xt(e, xn(e) - 3 - (~Jc(e, "!important") && 10))) {
        case 107:
          return Ae(e, ":", ":" + Pe) + e;
        case 101:
          return Ae(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + Pe + (xt(e, 14) === 45 ? "inline-" : "") + "box$3$1" + Pe + "$2$3$1" + Ct + "$2box$3") + e;
      }
      break;
    case 5936:
      switch (xt(e, t + 11)) {
        case 114:
          return Pe + e + Ct + Ae(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        case 108:
          return Pe + e + Ct + Ae(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        case 45:
          return Pe + e + Ct + Ae(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return Pe + e + Ct + e + e;
  }
  return e;
}
var Aq = function(t, n, r, i) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case rp:
      t.return = ZS(t.value, t.length);
      break;
    case qS:
      return Gr([Ni(t, {
        value: Ae(t.value, "@", "@" + Pe)
      })], i);
    case np:
      if (t.length) return hq(t.props, function(o) {
        switch (pq(o, /(::plac\w+|:read-\w+)/)) {
          case ":read-only":
          case ":read-write":
            return Gr([Ni(t, {
              props: [Ae(o, /:(read-\w+)/, ":" + ss + "$1")]
            })], i);
          case "::placeholder":
            return Gr([Ni(t, {
              props: [Ae(o, /:(plac\w+)/, ":" + Pe + "input-$1")]
            }), Ni(t, {
              props: [Ae(o, /:(plac\w+)/, ":" + ss + "$1")]
            }), Ni(t, {
              props: [Ae(o, /:(plac\w+)/, Ct + "input-$1")]
            })], i);
        }
        return "";
      });
  }
}, Dq = [Aq], _q = function(t) {
  var n = t.key;
  if (n === "css") {
    var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(r, function(h) {
      var g = h.getAttribute("data-emotion");
      g.indexOf(" ") !== -1 && (document.head.appendChild(h), h.setAttribute("data-s", ""));
    });
  }
  var i = t.stylisPlugins || Dq, o = {}, a, s = [];
  a = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(h) {
      for (var g = h.getAttribute("data-emotion").split(" "), m = 1; m < g.length; m++)
        o[g[m]] = !0;
      s.push(h);
    }
  );
  var l, u = [Rq, Pq];
  {
    var c, f = [Eq, Cq(function(h) {
      c.insert(h);
    })], p = kq(u.concat(i, f)), d = function(g) {
      return Gr(wq(g), p);
    };
    l = function(g, m, b, x) {
      c = b, d(g ? g + "{" + m.styles + "}" : m.styles), x && (v.inserted[m.name] = !0);
    };
  }
  var v = {
    key: n,
    sheet: new sq({
      key: n,
      container: a,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: o,
    registered: {},
    insert: l
  };
  return v.sheet.hydrate(s), v;
};
function Mq(e) {
  for (var t = 0, n, r = 0, i = e.length; i >= 4; ++r, i -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var jq = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, Nq = !1, Lq = /[A-Z]|^ms/g, Fq = /_EMO_([^_]+?)_([^]*?)_EMO_/g, QS = function(t) {
  return t.charCodeAt(1) === 45;
}, Yg = function(t) {
  return t != null && typeof t != "boolean";
}, Nu = /* @__PURE__ */ $q(function(e) {
  return QS(e) ? e : e.replace(Lq, "-$&").toLowerCase();
}), Xg = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(Fq, function(r, i, o) {
          return Kn = {
            name: i,
            styles: o,
            next: Kn
          }, i;
        });
  }
  return jq[t] !== 1 && !QS(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
}, Bq = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function ls(e, t, n) {
  if (n == null)
    return "";
  var r = n;
  if (r.__emotion_styles !== void 0)
    return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var i = n;
      if (i.anim === 1)
        return Kn = {
          name: i.name,
          styles: i.styles,
          next: Kn
        }, i.name;
      var o = n;
      if (o.styles !== void 0) {
        var a = o.next;
        if (a !== void 0)
          for (; a !== void 0; )
            Kn = {
              name: a.name,
              styles: a.styles,
              next: Kn
            }, a = a.next;
        var s = o.styles + ";";
        return s;
      }
      return zq(e, t, n);
    }
  }
  var l = n;
  if (t == null)
    return l;
  var u = t[l];
  return u !== void 0 ? u : l;
}
function zq(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var i = 0; i < n.length; i++)
      r += ls(e, t, n[i]) + ";";
  else
    for (var o in n) {
      var a = n[o];
      if (typeof a != "object") {
        var s = a;
        t != null && t[s] !== void 0 ? r += o + "{" + t[s] + "}" : Yg(s) && (r += Nu(o) + ":" + Xg(o, s) + ";");
      } else {
        if (o === "NO_COMPONENT_SELECTOR" && Nq)
          throw new Error(Bq);
        if (Array.isArray(a) && typeof a[0] == "string" && (t == null || t[a[0]] === void 0))
          for (var l = 0; l < a.length; l++)
            Yg(a[l]) && (r += Nu(o) + ":" + Xg(o, a[l]) + ";");
        else {
          var u = ls(e, t, a);
          switch (o) {
            case "animation":
            case "animationName": {
              r += Nu(o) + ":" + u + ";";
              break;
            }
            default:
              r += o + "{" + u + "}";
          }
        }
      }
    }
  return r;
}
var Jg = /label:\s*([^\s;{]+)\s*(;|$)/g, Kn;
function Lu(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var r = !0, i = "";
  Kn = void 0;
  var o = e[0];
  if (o == null || o.raw === void 0)
    r = !1, i += ls(n, t, o);
  else {
    var a = o;
    i += a[0];
  }
  for (var s = 1; s < e.length; s++)
    if (i += ls(n, t, e[s]), r) {
      var l = o;
      i += l[s];
    }
  Jg.lastIndex = 0;
  for (var u = "", c; (c = Jg.exec(i)) !== null; )
    u += "-" + c[1];
  var f = Mq(i) + u;
  return {
    name: f,
    styles: i,
    next: Kn
  };
}
function e0(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(i) {
    e[i] !== void 0 ? t.push(e[i] + ";") : i && (r += i + " ");
  }), r;
}
var Wq = function(t, n, r) {
  var i = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  t.registered[i] === void 0 && (t.registered[i] = n.styles);
}, Uq = function(t, n, r) {
  Wq(t, n);
  var i = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var o = n;
    do
      t.insert(n === o ? "." + i : "", o, t.sheet, !0), o = o.next;
    while (o !== void 0);
  }
};
function Zg(e, t) {
  if (e.inserted[t.name] === void 0)
    return e.insert("", t, e.sheet, !0);
}
function Qg(e, t, n) {
  var r = [], i = e0(e, r, n);
  return r.length < 2 ? n : i + t(r);
}
var Hq = function(t) {
  var n = _q(t);
  n.sheet.speedy = function(s) {
    if (process.env.NODE_ENV !== "production" && this.ctr !== 0)
      throw new Error("speedy must be changed before any rules are inserted");
    this.isSpeedy = s;
  }, n.compat = !0;
  var r = function() {
    for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)
      u[c] = arguments[c];
    var f = Lu(u, n.registered, void 0);
    return Uq(n, f), n.key + "-" + f.name;
  }, i = function() {
    for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)
      u[c] = arguments[c];
    var f = Lu(u, n.registered), p = "animation-" + f.name;
    return Zg(n, {
      name: f.name,
      styles: "@keyframes " + p + "{" + f.styles + "}"
    }), p;
  }, o = function() {
    for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)
      u[c] = arguments[c];
    var f = Lu(u, n.registered);
    Zg(n, f);
  }, a = function() {
    for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)
      u[c] = arguments[c];
    return Qg(n.registered, r, Vq(u));
  };
  return {
    css: r,
    cx: a,
    injectGlobal: o,
    keyframes: i,
    hydrate: function(l) {
      l.forEach(function(u) {
        n.inserted[u] = !0;
      });
    },
    flush: function() {
      n.registered = {}, n.inserted = {}, n.sheet.flush();
    },
    // $FlowFixMe
    sheet: n.sheet,
    cache: n,
    getRegisteredStyles: e0.bind(null, n.registered),
    merge: Qg.bind(null, n.registered, r)
  };
}, Vq = function e(t) {
  for (var n = "", r = 0; r < t.length; r++) {
    var i = t[r];
    if (i != null) {
      var o = void 0;
      switch (typeof i) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(i))
            o = e(i);
          else {
            o = "";
            for (var a in i)
              i[a] && a && (o && (o += " "), o += a);
          }
          break;
        }
        default:
          o = i;
      }
      o && (n && (n += " "), n += o);
    }
  }
  return n;
}, Kq = jo, op = Date.prototype, ey = "Invalid Date", t0 = "toString", qq = op[t0], Gq = op.getTime;
String(/* @__PURE__ */ new Date(NaN)) != ey && Kq(op, t0, function() {
  var t = Gq.call(this);
  return t === t ? qq.call(this) : ey;
});
var Yq = Qd, Xq = ES, Jq = Yq ? {}.toString : function() {
  return "[object " + Xq(this) + "]";
}, Zq = Qd, Qq = jo, e8 = Jq;
Zq || Qq(Object.prototype, "toString", e8, { unsafe: !0 });
var t8 = Jd.PROPER, n8 = jo, r8 = ir, ty = Zs, i8 = pn, o8 = kS, ap = "toString", n0 = RegExp.prototype, r0 = n0[ap], a8 = i8(function() {
  return r0.call({ source: "a", flags: "b" }) != "/a/b";
}), s8 = t8 && r0.name != ap;
(a8 || s8) && n8(RegExp.prototype, ap, function() {
  var t = r8(this), n = ty(t.source), r = t.flags, i = ty(r === void 0 && t instanceof RegExp && !("flags" in n0) ? o8.call(t) : r);
  return "/" + n + "/" + i;
}, { unsafe: !0 });
var ny = typeof window < "u" ? window : self, l8 = ny.crypto || ny.msCrypto, u8 = function(e) {
  if (!e) return Math.random;
  var t = Math.pow(2, 32), n = new Uint32Array(1);
  return function() {
    return e.getRandomValues(n)[0] / t;
  };
}(l8);
const c8 = /* @__PURE__ */ Ce(u8);
function f8() {
  return c8().toString(26).substr(2, 5).replace(/[0-9]/g, function(e) {
    return String.fromCharCode(e.charCodeAt(0) + 65);
  });
}
var d8 = Bw;
const ry = /* @__PURE__ */ Ce(d8);
function je(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "white", n = "background-color: ".concat(e, "; border-radius: 4px; padding: 2px 4px;");
  return t && (n += " color: ".concat(t, ";")), [n, ""];
}
function iy(e, t) {
  for (var n, r, i = arguments.length, o = new Array(i > 2 ? i - 2 : 0), a = 2; a < i; a++)
    o[a - 2] = arguments[a];
  return Xe(n = [Xe(r = "%c".concat(e, "%c ")).call(r, t)]).call(n, Ee(je("green", "white")), o);
}
function p8(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.force, r = n === void 0 ? !1 : n;
  return r ? function() {
    for (var i = arguments.length, o = new Array(i), a = 0; a < i; a++)
      o[a] = arguments[a];
    if (o.length) {
      var s = o, l = bn(s, 1), u = l[0];
      typeof u == "function" && (o = u());
      var c = ry(o[0]) ? o : [o], f = c.length === 1;
      as(c).call(c, function(p, d) {
        if (f) {
          var v, h;
          (v = console).log.apply(v, Ee(iy.apply(void 0, Xe(h = [e]).call(h, Ee(p)))));
        } else if (d) {
          var g;
          (g = console).log.apply(g, Ee(ry(p) ? p : [p]));
        } else {
          var m, b;
          (m = console).groupCollapsed.apply(m, Ee(iy.apply(void 0, Xe(b = [e]).call(b, Ee(p)))));
        }
      }), f || console.groupEnd();
    }
  } : function() {
    return 0;
  };
}
var h8 = Er, v8 = Jd.EXISTS, m8 = Mo.f, i0 = Function.prototype, g8 = i0.toString, y8 = /^\s*function ([^ (]*)/, b8 = "name";
h8 && !v8 && m8(i0, b8, {
  configurable: !0,
  get: function() {
    try {
      return g8.call(this).match(y8)[1];
    } catch {
      return "";
    }
  }
});
var x8 = wt, w8 = x8.setTimeout, S8 = w8;
const E8 = /* @__PURE__ */ Ce(S8);
function k8(e, t) {
  if (!t)
    return e;
  var n = 0, r = null;
  return function() {
    for (var i = arguments.length, o = new Array(i), a = 0; a < i; a++)
      o[a] = arguments[a];
    var s = Jn();
    s - n > t ? (e.apply(void 0, o), n = s) : (clearTimeout(r), r = E8(function() {
      e.apply(void 0, o), n = Jn();
    }, Math.max(0, t - s + n)));
  };
}
var o0 = function(t) {
  var n = t.debounce, r = t.name, i = t.onEvent, o = t.target, a = Ve();
  a.current = i;
  var s = ut(function() {
    return k8(function(u) {
      var c = a.current;
      c && c(u);
    }, n);
  }, [n, a]), l = Oe(function(u) {
    u.timeStampLow = Jn(), s(u);
  }, [s]);
  return ui(function() {
    return o.addEventListener(r, l, {
      passive: !0
    }), l({
      target: o,
      type: r
    }), function() {
      return o.removeEventListener(r, l);
    };
  }, [r, l, o]), !1;
};
o0.defaultProps = {
  debounce: 200
};
var C8 = Math.sign || function(t) {
  var n = +t;
  return n === 0 || n !== n ? n : n < 0 ? -1 : 1;
}, $8 = Le, T8 = C8;
$8({ target: "Math", stat: !0 }, {
  sign: T8
});
var O8 = wt, I8 = O8.Math.sign, R8 = I8, P8 = R8, A8 = P8;
const D8 = /* @__PURE__ */ Ce(A8);
function _8(e, t) {
  var n = D8(t - e), r = Math.sqrt(Math.abs(t - e)), i = e + r * n;
  return n > 0 ? Math.min(t, i) : Math.max(t, i);
}
function M8(e, t, n, r) {
  for (var i = e, o = 0; o < r; o++)
    i = n(i, t);
  return i;
}
var a0 = function(t) {
  var n = t.name, r = t.onEnd, i = t.target, o = t.value, a = Ve(), s = Oe(function(u, c, f, p) {
    var d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Jn();
    (f === "100%" || typeof f == "number") && (cancelAnimationFrame(a.current), a.current = requestAnimationFrame(function() {
      if (i) {
        var v = f === "100%" ? i.scrollHeight - i.offsetHeight : f, h = M8(c, v, _8, (Jn() - d) / 5);
        Math.abs(v - h) < 1.5 && (h = v), i[u] = h, v === h ? r && r(!0) : s(u, c, f, p + 1, d);
      }
    }));
  }, [a, r, i]), l = Oe(function() {
    cancelAnimationFrame(a.current), r && r(!1);
  }, [r]);
  return ui(function() {
    return s(n, i[n], o, 1), i ? (i.addEventListener("pointerdown", l, {
      passive: !0
    }), i.addEventListener("wheel", l, {
      passive: !0
    }), function() {
      i.removeEventListener("pointerdown", l), i.removeEventListener("wheel", l), cancelAnimationFrame(a.current);
    }) : function() {
      return cancelAnimationFrame(a.current);
    };
  }, [s, a, l, n, i, o]), !1;
};
a0.propTypes = {
  name: $e.string.isRequired,
  onEnd: $e.func,
  target: $e.any.isRequired,
  value: $e.oneOfType([$e.number, $e.oneOf(["100%"])]).isRequired
};
function Fu(e) {
  var t = ge(e), n = bn(t, 2), r = n[0], i = n[1], o = Ve(), a = Oe(function(s) {
    typeof s == "function" ? a(function(l) {
      return s = s(l), o.current = s, s;
    }) : (o.current = s, a(s));
  }, [o]);
  return o.current = r, [r, i, o];
}
function oy(e, t) {
  var n = eK(e);
  if (Ug) {
    var r = Ug(e);
    t && (r = yK(r).call(r, function(i) {
      return US(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ay(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    if (t % 2) {
      var r;
      as(r = oy(Object(n), !0)).call(r, function(o) {
        qW(e, o, n[o]);
      });
    } else if (Hg)
      tq(e, Hg(n));
    else {
      var i;
      as(i = oy(Object(n))).call(i, function(o) {
        rq(e, o, US(n, o));
      });
    }
  }
  return e;
}
var j8 = function() {
  return 1 / 0;
}, sy = 17, N8 = "bottom", nn = "top", ly = 1, L8 = 34, uy = {};
function F8(e, t) {
  return e(), TV(e, t);
}
function cy(e) {
  var t = e.mode, n = e.target, r = n.offsetHeight, i = n.scrollHeight, o = n.scrollTop, a = i - o - r < ly, s = o < ly, l = t === nn ? s : a, u = t !== nn ? s : a;
  return {
    atBottom: a,
    atEnd: l,
    atStart: u,
    atTop: s
  };
}
function Li(e, t) {
  return e === (t === nn ? 0 : "100%");
}
var sp = function(t) {
  var n = t.checkInterval, r = t.children, i = t.debounce, o = t.debug, a = t.initialScrollBehavior, s = t.mode, l = t.nonce, u = t.scroller, c = ut(function() {
    return p8("<ScrollToBottom>", {
      force: o
    });
  }, [o]);
  s = s === nn ? nn : N8;
  var f = Ve(0), p = Ve(a), d = Fu(s === nn ? 0 : "100%"), v = bn(d, 3), h = v[0], g = v[1], m = v[2], b = Fu(null), x = bn(b, 3), C = x[0], S = x[1], E = x[2], T = Ve(0), N = Ve(0), j = Ve(0), O = ge(!0), _ = bn(O, 2), V = _[0], L = _[1], I = ge(!0), A = bn(I, 2), M = A[0], q = A[1], W = ge(!0), P = bn(W, 2), y = P[0], D = P[1], B = ge(!1), w = bn(B, 2), U = w[0], Y = w[1], K = Fu(!0), G = bn(K, 3), Z = G[0], Q = G[1], X = G[2], J = Ve([]), H = Oe(function(F) {
    var te = E.current;
    return J.current.push(F), te && F({
      scrollTop: te.scrollTop
    }), function() {
      var ae = J.current, ce = WV(ae).call(ae, F);
      ~ce && d7(ae).call(ae, ce, 1);
    };
  }, [J, E]), re = Oe(function() {
    var F = m.current;
    c(function() {
      var te;
      return Xe(te = ["%cSpineTo%c: %conEnd%c is fired."]).call(te, Ee(je("magenta")), Ee(je("orange")), [{
        animateTo: F
      }]);
    }), f.current = Jn(), Li(F, s) || Q(!1), g(null);
  }, [m, c, f, s, g, Q]), se = Oe(function(F) {
    var te = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ae = te.behavior, ce = E.current;
    if (typeof F != "number" && F !== "100%")
      return console.warn('react-scroll-to-bottom: Arguments passed to scrollTo() must be either number or "100%".');
    c(function() {
      var he;
      return [Xe(he = ["%cscrollTo%c: Will scroll to %c".concat(typeof F == "number" ? F + "px" : F.replace(/%/g, "%%"), "%c")]).call(he, Ee(je("lime", "")), Ee(je("purple"))), {
        behavior: ae,
        nextAnimateTo: F,
        target: ce
      }];
    }), ae === "auto" ? (re(), ce && (ce.scrollTop = F === "100%" ? ce.scrollHeight - ce.offsetHeight : F)) : (ae !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollTo". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'), g(F)), Li(F, s) && (c(function() {
      var he;
      return [Xe(he = ["%cscrollTo%c: Scrolling to end, will set sticky to %ctrue%c."]).call(he, Ee(je("lime", "")), Ee(je("purple"))), [{
        mode: s,
        nextAnimateTo: F
      }]];
    }), Q(!0));
  }, [c, re, s, g, Q, E]), fe = Oe(function() {
    var F = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, te = F.behavior;
    c(function() {
      var ae;
      return Xe(ae = ["%cscrollToBottom%c: Called"]).call(ae, Ee(je("yellow", "")));
    }), te !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToBottom". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'), se("100%", {
      behavior: te || "smooth"
    });
  }, [c, se]), oe = Oe(function() {
    var F = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, te = F.behavior;
    c(function() {
      var ae;
      return Xe(ae = ["%cscrollToTop%c: Called"]).call(ae, Ee(je("yellow", "")));
    }), te !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToTop". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'), se(0, {
      behavior: te || "smooth"
    });
  }, [c, se]), me = Oe(function() {
    var F = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, te = F.behavior;
    c(function() {
      var ce;
      return Xe(ce = ["%cscrollToEnd%c: Called"]).call(ce, Ee(je("yellow", "")));
    }), te !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToEnd". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    var ae = {
      behavior: te || "smooth"
    };
    s === nn ? oe(ae) : fe(ae);
  }, [c, s, fe, oe]), we = Oe(function() {
    var F = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, te = F.behavior;
    c(function() {
      var ce;
      return Xe(ce = ["%cscrollToStart%c: Called"]).call(ce, Ee(je("yellow", "")));
    }), te !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToStart". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    var ae = {
      behavior: te || "smooth"
    };
    s === nn ? fe(ae) : oe(ae);
  }, [c, s, fe, oe]), Ie = Oe(function() {
    var F = E.current;
    if (F) {
      if (p.current === "auto") {
        c(function() {
          var it;
          return Xe(it = ["%ctarget changed%c: Initial scroll"]).call(it, Ee(je("blue")));
        }), F.scrollTop = s === nn ? 0 : F.scrollHeight - F.offsetHeight, p.current = !1;
        return;
      }
      var te = T.current, ae = F.offsetHeight, ce = F.scrollHeight, he = F.scrollTop, qe = s === nn ? 0 : Math.max(0, ce - ae - he), Ge = Math.max(0, te - he), gt = u({
        maxValue: qe,
        minValue: Ge,
        offsetHeight: ae,
        scrollHeight: ce,
        scrollTop: he
      }), rt = Math.max(0, Math.min(qe, gt)), Re;
      s === nn || rt !== qe ? Re = he + rt : Re = "100%", c(function() {
        var it, Qe, qt;
        return [Xe(it = [Xe(Qe = Xe(qt = "%cscrollToSticky%c: Will animate from %c".concat(te, "px%c to %c")).call(qt, typeof Re == "number" ? Re + "px" : Re.replace(/%/g, "%%"), "%c (%c")).call(Qe, (Re === "100%" ? qe : Re) + te, "px%c)")]).call(it, Ee(je("orange")), Ee(je("purple")), Ee(je("purple")), Ee(je("purple"))), {
          animateFrom: te,
          maxValue: qe,
          minValue: Ge,
          nextAnimateTo: Re,
          nextValue: rt,
          offsetHeight: ae,
          rawNextValue: gt,
          scrollHeight: ce,
          scrollTop: he
        }];
      }), se(Re, {
        behavior: "smooth"
      });
    }
  }, [T, c, s, u, se, E]), nt = Oe(function(F) {
    var te, ae = F.timeStampLow, ce = m.current, he = E.current, qe = ce !== null;
    if (!(ae <= f.current || !he)) {
      var Ge = cy({
        mode: s,
        target: he
      }), gt = Ge.atBottom, rt = Ge.atEnd, Re = Ge.atStart, it = Ge.atTop;
      L(gt), q(rt), Y(Re), D(it);
      var Qe = he.offsetHeight, qt = he.scrollHeight, Si = N.current, Rn = j.current, or = Qe !== Si, ar = qt !== Rn;
      if (or && (N.current = Qe), ar && (j.current = qt), !or && !ar) {
        var sr = qe && Li(ce, s) || rt;
        X.current !== sr && (c(function() {
          var hn, Fo, Ei, ki;
          return [Xe(hn = ["%conScroll%c: %csetSticky%c(%c".concat(sr, "%c)")]).call(hn, Ee(je("red")), Ee(je("red")), Ee(je("purple"))), Xe(Fo = [Xe(Ei = Xe(ki = "(animating = %c".concat(qe, "%c && isEnd = %c")).call(ki, Li(ce, s), "%c) || atEnd = %c")).call(Ei, rt, "%c")]).call(Fo, Ee(je("purple")), Ee(je("purple")), Ee(je("purple")), [{
            animating: qe,
            animateTo: ce,
            atEnd: rt,
            mode: s,
            offsetHeight: he.offsetHeight,
            scrollHeight: he.scrollHeight,
            sticky: X.current,
            nextSticky: sr
          }])];
        }), Q(sr));
      } else X.current && (c(function() {
        var hn;
        return [Xe(hn = ["%conScroll%c: Size changed while sticky, calling %cscrollToSticky()%c"]).call(hn, Ee(je("red")), Ee(je("orange")), [{
          offsetHeightChanged: or,
          scrollHeightChanged: ar
        }]), {
          nextOffsetHeight: Qe,
          prevOffsetHeight: Si,
          nextScrollHeight: qt,
          prevScrollHeight: Rn
        }];
      }), Ie());
      var il = he.scrollTop;
      as(te = J.current).call(te, function(hn) {
        return hn({
          scrollTop: il
        });
      });
    }
  }, [m, c, f, s, N, j, J, Ie, L, q, Y, D, Q, X, E]);
  ft(function() {
    if (C) {
      var F = !1, te = F8(function() {
        var ae = E.current, ce = m.current !== null;
        X.current ? cy({
          mode: s,
          target: ae
        }).atEnd ? F = !1 : F ? Jn() - F > L8 && (ce || (T.current = ae.scrollTop, c(function() {
          var he;
          return Xe(he = ["%cInterval check%c: Should sticky but not at end, calling %cscrollToSticky()%c to scroll"]).call(he, Ee(je("navy")), Ee(je("orange")));
        }), Ie()), F = !1) : F = Jn() : ae.scrollHeight <= ae.offsetHeight && !X.current && (c(function() {
          var he;
          return [Xe(he = ["%cInterval check%c: Container is emptied, setting sticky back to %ctrue%c"]).call(he, Ee(je("navy")), Ee(je("purple"))), [{
            offsetHeight: ae.offsetHeight,
            scrollHeight: ae.scrollHeight,
            sticky: X.current
          }]];
        }), Q(!0));
      }, Math.max(sy, n) || sy);
      return function() {
        return clearInterval(te);
      };
    }
  }, [m, n, c, s, Ie, Q, X, C, E]);
  var St = ut(function() {
    var F = uy[l] || (uy[l] = Hq({
      key: "react-scroll-to-bottom--css-" + f8(),
      nonce: l
    }));
    return function(te) {
      return F.css(te) + "";
    };
  }, [l]), Et = ut(function() {
    return {
      observeScrollPosition: H,
      setTarget: S,
      styleToClassName: St
    };
  }, [H, S, St]), kt = ut(function() {
    return {
      atBottom: V,
      atEnd: M,
      atStart: U,
      atTop: y,
      mode: s
    };
  }, [V, M, U, y, s]), ie = ut(function() {
    var F = h !== null;
    return {
      animating: F,
      animatingToEnd: F && Li(h, s),
      sticky: Z
    };
  }, [h, s, Z]), ue = ut(function() {
    return ay(ay({}, kt), ie);
  }, [kt, ie]), z = ut(function() {
    return {
      scrollTo: se,
      scrollToBottom: fe,
      scrollToEnd: me,
      scrollToStart: we,
      scrollToTop: oe
    };
  }, [se, fe, me, we, oe]);
  return ft(function() {
    if (C) {
      var F = function() {
        j.current = C.scrollHeight;
      };
      return C.addEventListener("focus", F, {
        capture: !0,
        passive: !0
      }), function() {
        return C.removeEventListener("focus", F);
      };
    }
  }, [C]), c(function() {
    var F;
    return [Xe(F = ["%cRender%c: Render"]).call(F, Ee(je("cyan", ""))), {
      animateTo: h,
      animating: h !== null,
      sticky: Z,
      target: C
    }];
  }), /* @__PURE__ */ Ne.createElement(qs.Provider, {
    value: Et
  }, /* @__PURE__ */ Ne.createElement(Nd.Provider, {
    value: z
  }, /* @__PURE__ */ Ne.createElement(Bd.Provider, {
    value: ue
  }, /* @__PURE__ */ Ne.createElement(Ld.Provider, {
    value: kt
  }, /* @__PURE__ */ Ne.createElement(Fd.Provider, {
    value: ie
  }, r, C && /* @__PURE__ */ Ne.createElement(o0, {
    debounce: i,
    name: "scroll",
    onEvent: nt,
    target: C
  }), C && h !== null && /* @__PURE__ */ Ne.createElement(a0, {
    name: "scrollTop",
    onEnd: re,
    target: C,
    value: h
  }))))));
};
sp.defaultProps = {
  checkInterval: 100,
  children: void 0,
  debounce: 17,
  debug: void 0,
  initialScrollBehavior: "smooth",
  mode: void 0,
  nonce: void 0,
  scroller: j8
};
sp.propTypes = {
  checkInterval: $e.number,
  children: $e.any,
  debounce: $e.number,
  debug: $e.bool,
  initialScrollBehavior: $e.oneOf(["auto", "smooth"]),
  mode: $e.oneOf(["bottom", "top"]),
  nonce: $e.string,
  scroller: $e.func
};
var B8 = {
  height: "100%",
  overflowY: "auto",
  width: "100%"
}, lp = function(t) {
  var n = t.children, r = t.className, i = li(qs), o = i.setTarget, a = zd()(B8);
  return /* @__PURE__ */ Ne.createElement("div", {
    className: Md(a, (r || "") + ""),
    ref: o
  }, n);
};
lp.defaultProps = {
  children: void 0,
  className: void 0
};
lp.propTypes = {
  children: $e.any,
  className: $e.string
};
var z8 = {
  position: "relative"
}, up = function(t) {
  var n = t.children, r = t.className, i = t.followButtonClassName, o = t.scrollViewClassName, a = zd()(z8);
  return /* @__PURE__ */ Ne.createElement("div", {
    className: Md(a, (r || "") + "")
  }, /* @__PURE__ */ Ne.createElement(lp, {
    className: (o || "") + ""
  }, n), /* @__PURE__ */ Ne.createElement(Wd, {
    className: (i || "") + ""
  }));
};
up.defaultProps = {
  children: void 0,
  className: void 0,
  followButtonClassName: void 0,
  scrollViewClassName: void 0
};
up.propTypes = {
  children: $e.any,
  className: $e.string,
  followButtonClassName: $e.string,
  scrollViewClassName: $e.string
};
var cp = function(t) {
  var n = t.checkInterval, r = t.children, i = t.className, o = t.debounce, a = t.debug, s = t.followButtonClassName, l = t.initialScrollBehavior, u = t.mode, c = t.nonce, f = t.scroller, p = t.scrollViewClassName;
  return /* @__PURE__ */ Ne.createElement(sp, {
    checkInterval: n,
    debounce: o,
    debug: a,
    initialScrollBehavior: l,
    mode: u,
    nonce: c,
    scroller: f
  }, /* @__PURE__ */ Ne.createElement(up, {
    className: i,
    followButtonClassName: s,
    scrollViewClassName: p
  }, r));
};
cp.defaultProps = {
  checkInterval: void 0,
  children: void 0,
  className: void 0,
  debounce: void 0,
  debug: void 0,
  followButtonClassName: void 0,
  initialScrollBehavior: "smooth",
  mode: void 0,
  nonce: void 0,
  scroller: void 0,
  scrollViewClassName: void 0
};
cp.propTypes = {
  checkInterval: $e.number,
  children: $e.any,
  className: $e.string,
  debounce: $e.number,
  debug: $e.bool,
  followButtonClassName: $e.string,
  initialScrollBehavior: $e.oneOf(["auto", "smooth"]),
  mode: $e.oneOf(["bottom", "top"]),
  nonce: $e.string,
  scroller: $e.func,
  scrollViewClassName: $e.string
};
sj();
let s0 = (e = 21) => crypto.getRandomValues(new Uint8Array(e)).reduce((t, n) => (n &= 63, n < 36 ? t += n.toString(36) : n < 62 ? t += (n - 26).toString(36).toUpperCase() : n > 62 ? t += "-" : t += "_", t), "");
const l0 = fs(
  ({
    className: e,
    messages: t = [],
    isTyping: n,
    headerMessage: r,
    renderers: i,
    botAvatar: o,
    botDescription: a,
    botName: s,
    sendMessage: l,
    addMessageFeedback: u,
    showMarquee: c = !0,
    ...f
  }) => {
    const { messageList: p } = Te, d = ut(() => GE(t), [t]);
    return /* @__PURE__ */ $.jsxs(
      cp,
      {
        ...f,
        className: no(p.container.className, e),
        followButtonClassName: p.scrollDownButton.className,
        scrollViewClassName: p.viewPort.className,
        children: [
          r && /* @__PURE__ */ $.jsx("span", { ...p.headerMessage, children: r }),
          c && /* @__PURE__ */ $.jsx(oj, { botAvatar: o, botDescription: a, botName: s }),
          d.map((v) => {
            var h;
            return /* @__PURE__ */ $.jsx(
              Pv,
              {
                renderers: i,
                sendMessage: l,
                addMessageFeedback: u,
                ...v
              },
              ((h = v.metadata) == null ? void 0 : h.clientMessageId) || v.id
            );
          }),
          n && /* @__PURE__ */ $.jsx(
            Pv,
            {
              id: s0(),
              renderers: i,
              sendMessage: l,
              direction: "incoming",
              timestamp: /* @__PURE__ */ new Date(),
              block: void 0,
              sender: { name: s || "Bot", avatar: o },
              children: /* @__PURE__ */ $.jsx($w, {})
            }
          )
        ]
      }
    );
  }
);
l0.displayName = "MessageList";
const W8 = ({ className: e, ...t }) => {
  const { className: n } = Te.loader;
  return /* @__PURE__ */ $.jsx("div", { ...t, className: no(e, n) });
}, U8 = ({
  connected: e,
  configuration: t,
  closeWindow: n,
  isTyping: r,
  messages: i,
  user: o,
  sendMessage: a,
  uploadFile: s,
  addMessageFeedback: l,
  isLoading: u,
  renderers: c,
  isReadOnly: f,
  disableComposer: p,
  restartConversation: d,
  allowFileUpload: v,
  ...h
}) => {
  const {
    color: g,
    fontFamily: m,
    radius: b,
    themeMode: x,
    variant: C,
    headerVariant: S,
    botAvatar: E,
    botDescription: T,
    botName: N,
    composerPlaceholder: j,
    footer: O,
    feedbackEnabled: _
  } = t, V = { color: g, fontFamily: m, radius: b, themeMode: x, variant: C, headerVariant: S }, L = ut(
    () => i.map((I) => {
      const { authorId: A } = I, M = A === (o == null ? void 0 : o.id) ? "outgoing" : "incoming";
      return {
        ...I,
        direction: M,
        sender: M === "outgoing" ? { name: "You" } : { name: N || "Bot", avatar: E }
      };
    }),
    [E, N, i, o == null ? void 0 : o.id]
  );
  return _ || (l = void 0), /* @__PURE__ */ $.jsxs($.Fragment, { children: [
    /* @__PURE__ */ $.jsx(MM, { ...V }),
    /* @__PURE__ */ $.jsxs(yw, { connected: e, allowFileUpload: v, uploadFile: s, ...h, children: [
      /* @__PURE__ */ $.jsx(ij, { closeWindow: n, configuration: t, restartConversation: d }),
      u ? /* @__PURE__ */ $.jsx(W8, {}) : /* @__PURE__ */ $.jsx(
        l0,
        {
          botAvatar: E,
          botDescription: T,
          botName: N,
          renderers: c,
          isTyping: r,
          sendMessage: a,
          addMessageFeedback: l,
          messages: L
        }
      ),
      /* @__PURE__ */ $.jsx(
        A_,
        {
          sendMessage: a,
          uploadFile: s,
          connected: e,
          isReadOnly: f,
          disableComposer: p,
          footer: O,
          composerPlaceholder: j,
          allowFileUpload: v
        }
      )
    ] })
  ] });
};
function H8() {
  const [e, t] = ge(!1), n = Ve(null);
  return {
    isTyping: e,
    setIsTyping: (r, i) => {
      if (t(r), !r)
        return () => {
        };
      if (n.current = /* @__PURE__ */ new Date(), !i)
        return () => {
        };
      const o = setTimeout(() => {
        const a = n.current;
        a && (/* @__PURE__ */ new Date()).getTime() - a.getTime() > i && t(!1);
      }, i + 100);
      return () => clearTimeout(o);
    }
  };
}
var V8 = Object.defineProperty, K8 = (e, t, n) => t in e ? V8(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, q8 = (e, t, n) => K8(e, t + "", n), G8 = async (e, t) => {
  let n = typeof t == "function" ? await t(e) : t;
  if (n) return e.scheme === "bearer" ? `Bearer ${n}` : e.scheme === "basic" ? `Basic ${btoa(n)}` : n;
}, Y8 = { bodySerializer: (e) => JSON.stringify(e, (t, n) => typeof n == "bigint" ? n.toString() : n) }, X8 = (e) => {
  switch (e) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
}, J8 = (e) => {
  switch (e) {
    case "form":
      return ",";
    case "pipeDelimited":
      return "|";
    case "spaceDelimited":
      return "%20";
    default:
      return ",";
  }
}, Z8 = (e) => {
  switch (e) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
}, u0 = ({ allowReserved: e, explode: t, name: n, style: r, value: i }) => {
  if (!t) {
    let s = (e ? i : i.map((l) => encodeURIComponent(l))).join(J8(r));
    switch (r) {
      case "label":
        return `.${s}`;
      case "matrix":
        return `;${n}=${s}`;
      case "simple":
        return s;
      default:
        return `${n}=${s}`;
    }
  }
  let o = X8(r), a = i.map((s) => r === "label" || r === "simple" ? e ? s : encodeURIComponent(s) : nl({ allowReserved: e, name: n, value: s })).join(o);
  return r === "label" || r === "matrix" ? o + a : a;
}, nl = ({ allowReserved: e, name: t, value: n }) => {
  if (n == null) return "";
  if (typeof n == "object") throw new Error("Deeply-nested arrays/objects aren’t supported. Provide your own `querySerializer()` to handle these.");
  return `${t}=${e ? n : encodeURIComponent(n)}`;
}, c0 = ({ allowReserved: e, explode: t, name: n, style: r, value: i }) => {
  if (i instanceof Date) return `${n}=${i.toISOString()}`;
  if (r !== "deepObject" && !t) {
    let s = [];
    Object.entries(i).forEach(([u, c]) => {
      s = [...s, u, e ? c : encodeURIComponent(c)];
    });
    let l = s.join(",");
    switch (r) {
      case "form":
        return `${n}=${l}`;
      case "label":
        return `.${l}`;
      case "matrix":
        return `;${n}=${l}`;
      default:
        return l;
    }
  }
  let o = Z8(r), a = Object.entries(i).map(([s, l]) => nl({ allowReserved: e, name: r === "deepObject" ? `${n}[${s}]` : s, value: l })).join(o);
  return r === "label" || r === "matrix" ? o + a : a;
}, Q8 = /\{[^{}]+\}/g, eG = ({ path: e, url: t }) => {
  let n = t, r = t.match(Q8);
  if (r) for (let i of r) {
    let o = !1, a = i.substring(1, i.length - 1), s = "simple";
    a.endsWith("*") && (o = !0, a = a.substring(0, a.length - 1)), a.startsWith(".") ? (a = a.substring(1), s = "label") : a.startsWith(";") && (a = a.substring(1), s = "matrix");
    let l = e[a];
    if (l == null) continue;
    if (Array.isArray(l)) {
      n = n.replace(i, u0({ explode: o, name: a, style: s, value: l }));
      continue;
    }
    if (typeof l == "object") {
      n = n.replace(i, c0({ explode: o, name: a, style: s, value: l }));
      continue;
    }
    if (s === "matrix") {
      n = n.replace(i, `;${nl({ name: a, value: l })}`);
      continue;
    }
    let u = encodeURIComponent(s === "label" ? `.${l}` : l);
    n = n.replace(i, u);
  }
  return n;
}, f0 = ({ allowReserved: e, array: t, object: n } = {}) => (r) => {
  let i = [];
  if (r && typeof r == "object") for (let o in r) {
    let a = r[o];
    if (a != null) {
      if (Array.isArray(a)) {
        i = [...i, u0({ allowReserved: e, explode: !0, name: o, style: "form", value: a, ...t })];
        continue;
      }
      if (typeof a == "object") {
        i = [...i, c0({ allowReserved: e, explode: !0, name: o, style: "deepObject", value: a, ...n })];
        continue;
      }
      i = [...i, nl({ allowReserved: e, name: o, value: a })];
    }
  }
  return i.join("&");
}, tG = (e) => {
  var t;
  if (!e) return "stream";
  let n = (t = e.split(";")[0]) == null ? void 0 : t.trim();
  if (n) {
    if (n.startsWith("application/json") || n.endsWith("+json")) return "json";
    if (n === "multipart/form-data") return "formData";
    if (["application/", "audio/", "image/", "video/"].some((r) => n.startsWith(r))) return "blob";
    if (n.startsWith("text/")) return "text";
  }
}, nG = async ({ security: e, ...t }) => {
  for (let n of e) {
    let r = await G8(n, t.auth);
    if (!r) continue;
    let i = n.name ?? "Authorization";
    switch (n.in) {
      case "query":
        t.query || (t.query = {}), t.query[i] = r;
        break;
      case "cookie":
        t.headers.append("Cookie", `${i}=${r}`);
        break;
      case "header":
      default:
        t.headers.set(i, r);
        break;
    }
    return;
  }
}, fy = (e) => rG({ baseUrl: e.baseUrl, path: e.path, query: e.query, querySerializer: typeof e.querySerializer == "function" ? e.querySerializer : f0(e.querySerializer), url: e.url }), rG = ({ baseUrl: e, path: t, query: n, querySerializer: r, url: i }) => {
  let o = i.startsWith("/") ? i : `/${i}`, a = (e ?? "") + o;
  t && (a = eG({ path: t, url: a }));
  let s = n ? r(n) : "";
  return s.startsWith("?") && (s = s.substring(1)), s && (a += `?${s}`), a;
}, dy = (e, t) => {
  var n;
  let r = { ...e, ...t };
  return (n = r.baseUrl) != null && n.endsWith("/") && (r.baseUrl = r.baseUrl.substring(0, r.baseUrl.length - 1)), r.headers = d0(e.headers, t.headers), r;
}, d0 = (...e) => {
  let t = new Headers();
  for (let n of e) {
    if (!n || typeof n != "object") continue;
    let r = n instanceof Headers ? n.entries() : Object.entries(n);
    for (let [i, o] of r) if (o === null) t.delete(i);
    else if (Array.isArray(o)) for (let a of o) t.append(i, a);
    else o !== void 0 && t.set(i, typeof o == "object" ? JSON.stringify(o) : o);
  }
  return t;
}, Bu = class {
  constructor() {
    q8(this, "_fns"), this._fns = [];
  }
  clear() {
    this._fns = [];
  }
  exists(t) {
    return this._fns.indexOf(t) !== -1;
  }
  eject(t) {
    let n = this._fns.indexOf(t);
    n !== -1 && (this._fns = [...this._fns.slice(0, n), ...this._fns.slice(n + 1)]);
  }
  use(t) {
    this._fns = [...this._fns, t];
  }
}, iG = () => ({ error: new Bu(), request: new Bu(), response: new Bu() }), oG = /* @__PURE__ */ f0({ allowReserved: !1, array: { explode: !0, style: "form" }, object: { explode: !0, style: "deepObject" } }), aG = { "Content-Type": "application/json" }, p0 = (e = {}) => ({ ...Y8, headers: aG, parseAs: "auto", querySerializer: oG, ...e }), sG = (e = {}) => {
  let t = dy(p0(), e), n = () => ({ ...t }), r = (a) => (t = dy(t, a), n()), i = iG(), o = async (a) => {
    let s = { ...t, ...a, fetch: a.fetch ?? t.fetch ?? globalThis.fetch, headers: d0(t.headers, a.headers) };
    s.security && await nG({ ...s, security: s.security }), s.body && s.bodySerializer && (s.body = s.bodySerializer(s.body)), (s.body === void 0 || s.body === "") && s.headers.delete("Content-Type");
    let l = fy(s), u = { redirect: "follow", ...s }, c = new Request(l, u);
    for (let g of i.request._fns) c = await g(c, s);
    let f = s.fetch, p = await f(c);
    for (let g of i.response._fns) p = await g(p, c, s);
    let d = { request: c, response: p };
    if (p.ok) {
      if (p.status === 204 || p.headers.get("Content-Length") === "0") return { data: {}, ...d };
      let g = (s.parseAs === "auto" ? tG(p.headers.get("Content-Type")) : s.parseAs) ?? "json";
      if (g === "stream") return { data: p.body, ...d };
      let m = await p[g]();
      return g === "json" && (s.responseValidator && await s.responseValidator(m), s.responseTransformer && (m = await s.responseTransformer(m))), { data: m, ...d };
    }
    let v = await p.text();
    try {
      v = JSON.parse(v);
    } catch {
    }
    let h = v;
    for (let g of i.error._fns) h = await g(v, p, c, s);
    if (h = h || {}, s.throwOnError) throw h;
    return { error: h, ...d };
  };
  return { buildUrl: fy, connect: (a) => o({ ...a, method: "CONNECT" }), delete: (a) => o({ ...a, method: "DELETE" }), get: (a) => o({ ...a, method: "GET" }), getConfig: n, head: (a) => o({ ...a, method: "HEAD" }), interceptors: i, options: (a) => o({ ...a, method: "OPTIONS" }), patch: (a) => o({ ...a, method: "PATCH" }), post: (a) => o({ ...a, method: "POST" }), put: (a) => o({ ...a, method: "PUT" }), request: o, setConfig: r, trace: (a) => o({ ...a, method: "TRACE" }) };
}, lG = sG, uG = p0;
const cG = (e) => ({
  ...e,
  withCredentials: !0,
  timeout: 6e4,
  maxBodyLength: 104857600,
  maxContentLength: 104857600,
  throwOnError: !0
}), Ke = /* @__PURE__ */ lG(/* @__PURE__ */ cG(/* @__PURE__ */ uG({
  baseUrl: "https://webchat.botpress.cloud/"
}))), fG = (e) => (e.client ?? Ke).delete({
  url: "/conversations/{id}",
  ...e
}), dG = (e) => (e.client ?? Ke).get({
  url: "/conversations/{id}",
  ...e
}), pG = (e) => (e.client ?? Ke).get({
  url: "/conversations",
  ...e
}), hG = (e) => (e.client ?? Ke).post({
  url: "/conversations",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), vG = (e) => (e.client ?? Ke).get({
  url: "/conversations/{id}/messages",
  ...e
}), mG = (e) => (e.client ?? Ke).get({
  url: "/conversations/{id}/participants",
  ...e
}), gG = (e) => (e.client ?? Ke).post({
  url: "/conversations/{id}/participants",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), yG = (e) => (e.client ?? Ke).delete({
  url: "/conversations/{id}/participants/{userId}",
  ...e
}), bG = (e) => (e.client ?? Ke).get({
  url: "/conversations/{id}/participants/{userId}",
  ...e
}), xG = (e) => (e.client ?? Ke).delete({
  url: "/messages/{id}",
  ...e
}), wG = (e) => (e.client ?? Ke).get({
  url: "/messages/{id}",
  ...e
}), SG = (e) => (e.client ?? Ke).put({
  url: "/messages/{id}",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), EG = (e) => (e.client ?? Ke).post({
  url: "/messages",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), kG = (e) => (e.client ?? Ke).delete({
  url: "/messages/{id}/feedback",
  ...e
}), CG = (e) => (e.client ?? Ke).put({
  url: "/messages/{id}/feedback",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), $G = (e) => (e.client ?? Ke).delete({
  url: "/users/me",
  ...e
}), TG = (e) => (e.client ?? Ke).get({
  url: "/users/me",
  ...e
}), OG = (e) => (e.client ?? Ke).put({
  url: "/users/me",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), h0 = (e) => ((e == null ? void 0 : e.client) ?? Ke).post({
  url: "/users",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), IG = (e) => (e.client ?? Ke).get({
  url: "/events/{id}",
  ...e
}), RG = (e) => (e.client ?? Ke).post({
  url: "/events",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), PG = (e) => (e.client ?? Ke).post({
  url: "/files",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
});
let py = class extends Error {
  constructor(t, n) {
    super(t), this.name = "ParseError", this.type = n.type, this.field = n.field, this.value = n.value, this.line = n.line;
  }
};
function zu(e) {
}
function AG(e) {
  if (typeof e == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent: t = zu, onError: n = zu, onRetry: r = zu, onComment: i } = e;
  let o = "", a = !0, s, l = "", u = "";
  function c(h) {
    const g = a ? h.replace(/^\xEF\xBB\xBF/, "") : h, [m, b] = DG(`${o}${g}`);
    for (const x of m)
      f(x);
    o = b, a = !1;
  }
  function f(h) {
    if (h === "") {
      d();
      return;
    }
    if (h.startsWith(":")) {
      i && i(h.slice(h.startsWith(": ") ? 2 : 1));
      return;
    }
    const g = h.indexOf(":");
    if (g !== -1) {
      const m = h.slice(0, g), b = h[g + 1] === " " ? 2 : 1, x = h.slice(g + b);
      p(m, x, h);
      return;
    }
    p(h, "", h);
  }
  function p(h, g, m) {
    switch (h) {
      case "event":
        u = g;
        break;
      case "data":
        l = `${l}${g}
`;
        break;
      case "id":
        s = g.includes("\0") ? void 0 : g;
        break;
      case "retry":
        /^\d+$/.test(g) ? r(parseInt(g, 10)) : n(
          new py(`Invalid \`retry\` value: "${g}"`, {
            type: "invalid-retry",
            value: g,
            line: m
          })
        );
        break;
      default:
        n(
          new py(
            `Unknown field "${h.length > 20 ? `${h.slice(0, 20)}…` : h}"`,
            { type: "unknown-field", field: h, value: g, line: m }
          )
        );
        break;
    }
  }
  function d() {
    l.length > 0 && t({
      id: s,
      event: u || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: l.endsWith(`
`) ? l.slice(0, -1) : l
    }), s = void 0, l = "", u = "";
  }
  function v(h = {}) {
    o && h.consume && f(o), a = !0, s = void 0, l = "", u = "", o = "";
  }
  return { feed: c, reset: v };
}
function DG(e) {
  const t = [];
  let n = "", r = 0;
  for (; r < e.length; ) {
    const i = e.indexOf("\r", r), o = e.indexOf(`
`, r);
    let a = -1;
    if (i !== -1 && o !== -1 ? a = Math.min(i, o) : i !== -1 ? a = i : o !== -1 && (a = o), a === -1) {
      n = e.slice(r);
      break;
    } else {
      const s = e.slice(r, a);
      t.push(s), r = a + 1, e[r - 1] === "\r" && e[r] === `
` && r++;
    }
  }
  return [t, n];
}
class hy extends Event {
  /**
   * Constructs a new `ErrorEvent` instance. This is typically not called directly,
   * but rather emitted by the `EventSource` object when an error occurs.
   *
   * @param type - The type of the event (should be "error")
   * @param errorEventInitDict - Optional properties to include in the error event
   */
  constructor(t, n) {
    var r, i;
    super(t), this.code = (r = n == null ? void 0 : n.code) != null ? r : void 0, this.message = (i = n == null ? void 0 : n.message) != null ? i : void 0;
  }
  /**
   * Node.js "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Node.js when you `console.log` an instance of this class.
   *
   * @param _depth - The current depth
   * @param options - The options passed to `util.inspect`
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @returns A string representation of the error
   */
  [Symbol.for("nodejs.util.inspect.custom")](t, n, r) {
    return r(vy(this), n);
  }
  /**
   * Deno "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Deno when you `console.log` an instance of this class.
   *
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @param options - The options passed to `Deno.inspect`
   * @returns A string representation of the error
   */
  [Symbol.for("Deno.customInspect")](t, n) {
    return t(vy(this), n);
  }
}
function _G(e) {
  const t = globalThis.DOMException;
  return typeof t == "function" ? new t(e, "SyntaxError") : new SyntaxError(e);
}
function Qc(e) {
  return e instanceof Error ? "errors" in e && Array.isArray(e.errors) ? e.errors.map(Qc).join(", ") : "cause" in e && e.cause instanceof Error ? `${e}: ${Qc(e.cause)}` : e.message : `${e}`;
}
function vy(e) {
  return {
    type: e.type,
    message: e.message,
    code: e.code,
    defaultPrevented: e.defaultPrevented,
    cancelable: e.cancelable,
    timeStamp: e.timeStamp
  };
}
var v0 = (e) => {
  throw TypeError(e);
}, fp = (e, t, n) => t.has(e) || v0("Cannot " + n), ye = (e, t, n) => (fp(e, t, "read from private field"), n ? n.call(e) : t.get(e)), lt = (e, t, n) => t.has(e) ? v0("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), He = (e, t, n, r) => (fp(e, t, "write to private field"), t.set(e, n), n), Pn = (e, t, n) => (fp(e, t, "access private method"), n), Nt, pr, Lr, Aa, us, Gi, Ur, Yi, Vn, Fr, Yr, Br, zi, tn, ef, tf, nf, my, rf, of, Wi, af, sf;
class Da extends EventTarget {
  constructor(t, n) {
    var r, i;
    super(), lt(this, tn), this.CONNECTING = 0, this.OPEN = 1, this.CLOSED = 2, lt(this, Nt), lt(this, pr), lt(this, Lr), lt(this, Aa), lt(this, us), lt(this, Gi), lt(this, Ur), lt(this, Yi, null), lt(this, Vn), lt(this, Fr), lt(this, Yr, null), lt(this, Br, null), lt(this, zi, null), lt(this, tf, async (o) => {
      var a;
      ye(this, Fr).reset();
      const { body: s, redirected: l, status: u, headers: c } = o;
      if (u === 204) {
        Pn(this, tn, Wi).call(this, "Server sent HTTP 204, not reconnecting", 204), this.close();
        return;
      }
      if (l ? He(this, Lr, new URL(o.url)) : He(this, Lr, void 0), u !== 200) {
        Pn(this, tn, Wi).call(this, `Non-200 status code (${u})`, u);
        return;
      }
      if (!(c.get("content-type") || "").startsWith("text/event-stream")) {
        Pn(this, tn, Wi).call(this, 'Invalid content type, expected "text/event-stream"', u);
        return;
      }
      if (ye(this, Nt) === this.CLOSED)
        return;
      He(this, Nt, this.OPEN);
      const f = new Event("open");
      if ((a = ye(this, zi)) == null || a.call(this, f), this.dispatchEvent(f), typeof s != "object" || !s || !("getReader" in s)) {
        Pn(this, tn, Wi).call(this, "Invalid response body, expected a web ReadableStream", u), this.close();
        return;
      }
      const p = new TextDecoder(), d = s.getReader();
      let v = !0;
      do {
        const { done: h, value: g } = await d.read();
        g && ye(this, Fr).feed(p.decode(g, { stream: !h })), h && (v = !1, ye(this, Fr).reset(), Pn(this, tn, af).call(this));
      } while (v);
    }), lt(this, nf, (o) => {
      He(this, Vn, void 0), !(o.name === "AbortError" || o.type === "aborted") && Pn(this, tn, af).call(this, Qc(o));
    }), lt(this, rf, (o) => {
      typeof o.id == "string" && He(this, Yi, o.id);
      const a = new MessageEvent(o.event || "message", {
        data: o.data,
        origin: ye(this, Lr) ? ye(this, Lr).origin : ye(this, pr).origin,
        lastEventId: o.id || ""
      });
      ye(this, Br) && (!o.event || o.event === "message") && ye(this, Br).call(this, a), this.dispatchEvent(a);
    }), lt(this, of, (o) => {
      He(this, Gi, o);
    }), lt(this, sf, () => {
      He(this, Ur, void 0), ye(this, Nt) === this.CONNECTING && Pn(this, tn, ef).call(this);
    });
    try {
      if (t instanceof URL)
        He(this, pr, t);
      else if (typeof t == "string")
        He(this, pr, new URL(t, MG()));
      else
        throw new Error("Invalid URL");
    } catch {
      throw _G("An invalid or illegal string was specified");
    }
    He(this, Fr, AG({
      onEvent: ye(this, rf),
      onRetry: ye(this, of)
    })), He(this, Nt, this.CONNECTING), He(this, Gi, 3e3), He(this, us, (r = n == null ? void 0 : n.fetch) != null ? r : globalThis.fetch), He(this, Aa, (i = n == null ? void 0 : n.withCredentials) != null ? i : !1), Pn(this, tn, ef).call(this);
  }
  /**
   * Returns the state of this EventSource object's connection. It can have the values described below.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)
   *
   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,
   * defined in the TypeScript `dom` library.
   *
   * @public
   */
  get readyState() {
    return ye(this, Nt);
  }
  /**
   * Returns the URL providing the event stream.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)
   *
   * @public
   */
  get url() {
    return ye(this, pr).href;
  }
  /**
   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)
   */
  get withCredentials() {
    return ye(this, Aa);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */
  get onerror() {
    return ye(this, Yr);
  }
  set onerror(t) {
    He(this, Yr, t);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */
  get onmessage() {
    return ye(this, Br);
  }
  set onmessage(t) {
    He(this, Br, t);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */
  get onopen() {
    return ye(this, zi);
  }
  set onopen(t) {
    He(this, zi, t);
  }
  addEventListener(t, n, r) {
    const i = n;
    super.addEventListener(t, i, r);
  }
  removeEventListener(t, n, r) {
    const i = n;
    super.removeEventListener(t, i, r);
  }
  /**
   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)
   *
   * @public
   */
  close() {
    ye(this, Ur) && clearTimeout(ye(this, Ur)), ye(this, Nt) !== this.CLOSED && (ye(this, Vn) && ye(this, Vn).abort(), He(this, Nt, this.CLOSED), He(this, Vn, void 0));
  }
}
Nt = /* @__PURE__ */ new WeakMap(), pr = /* @__PURE__ */ new WeakMap(), Lr = /* @__PURE__ */ new WeakMap(), Aa = /* @__PURE__ */ new WeakMap(), us = /* @__PURE__ */ new WeakMap(), Gi = /* @__PURE__ */ new WeakMap(), Ur = /* @__PURE__ */ new WeakMap(), Yi = /* @__PURE__ */ new WeakMap(), Vn = /* @__PURE__ */ new WeakMap(), Fr = /* @__PURE__ */ new WeakMap(), Yr = /* @__PURE__ */ new WeakMap(), Br = /* @__PURE__ */ new WeakMap(), zi = /* @__PURE__ */ new WeakMap(), tn = /* @__PURE__ */ new WeakSet(), /**
* Connect to the given URL and start receiving events
*
* @internal
*/
ef = function() {
  He(this, Nt, this.CONNECTING), He(this, Vn, new AbortController()), ye(this, us)(ye(this, pr), Pn(this, tn, my).call(this)).then(ye(this, tf)).catch(ye(this, nf));
}, tf = /* @__PURE__ */ new WeakMap(), nf = /* @__PURE__ */ new WeakMap(), /**
* Get request options for the `fetch()` request
*
* @returns The request options
* @internal
*/
my = function() {
  var e;
  const t = {
    // [spec] Let `corsAttributeState` be `Anonymous`…
    // [spec] …will have their mode set to "cors"…
    mode: "cors",
    redirect: "follow",
    headers: { Accept: "text/event-stream", ...ye(this, Yi) ? { "Last-Event-ID": ye(this, Yi) } : void 0 },
    cache: "no-store",
    signal: (e = ye(this, Vn)) == null ? void 0 : e.signal
  };
  return "window" in globalThis && (t.credentials = this.withCredentials ? "include" : "same-origin"), t;
}, rf = /* @__PURE__ */ new WeakMap(), of = /* @__PURE__ */ new WeakMap(), /**
* Handles the process referred to in the EventSource specification as "failing a connection".
*
* @param error - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
Wi = function(e, t) {
  var n;
  ye(this, Nt) !== this.CLOSED && He(this, Nt, this.CLOSED);
  const r = new hy("error", { code: t, message: e });
  (n = ye(this, Yr)) == null || n.call(this, r), this.dispatchEvent(r);
}, /**
* Schedules a reconnection attempt against the EventSource endpoint.
*
* @param message - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
af = function(e, t) {
  var n;
  if (ye(this, Nt) === this.CLOSED)
    return;
  He(this, Nt, this.CONNECTING);
  const r = new hy("error", { code: t, message: e });
  (n = ye(this, Yr)) == null || n.call(this, r), this.dispatchEvent(r), He(this, Ur, setTimeout(ye(this, sf), ye(this, Gi)));
}, sf = /* @__PURE__ */ new WeakMap(), /**
* ReadyState representing an EventSource currently trying to connect
*
* @public
*/
Da.CONNECTING = 0, /**
* ReadyState representing an EventSource connection that is open (eg connected)
*
* @public
*/
Da.OPEN = 1, /**
* ReadyState representing an EventSource connection that is closed (eg disconnected)
*
* @public
*/
Da.CLOSED = 2;
function MG() {
  const e = "document" in globalThis ? globalThis.document : void 0;
  return e && typeof e == "object" && "baseURI" in e && typeof e.baseURI == "string" ? e.baseURI : void 0;
}
class jG {
  constructor() {
    this.eventMap = {};
  }
  on(t, n) {
    var r;
    return this.eventMap[t] || (this.eventMap[t] = /* @__PURE__ */ new Set()), (r = this.eventMap[t]) == null || r.add(n), () => {
      var i;
      (i = this.eventMap[t]) == null || i.delete(n);
    };
  }
  emit(t, n) {
    var r, i;
    (r = this.eventMap[t]) == null || r.forEach((o) => {
      o(n);
    }), (i = this.eventMap["*"]) == null || i.forEach((o) => {
      o({ type: t, payload: n });
    });
  }
}
const Ye = (e) => e.data, m0 = {
  throwOnError: !0
}, NG = ({ clientId: e, apiUrl: t }) => {
  const n = `${t || Ke.getConfig().baseUrl}/${e}`, r = {
    ...m0,
    baseUrl: n
  };
  return h0({ ...r, body: {} }).then(Ye);
}, LG = ({
  userKey: e,
  clientId: t,
  apiUrl: n
}) => {
  const r = {
    "x-user-key": e
  }, i = `${n || Ke.getConfig().baseUrl}/${t}`, o = {
    ...m0,
    baseUrl: i
  };
  return {
    createConversation: () => hG({ ...o, headers: r, body: {} }).then(Ye),
    getConversation: ({ conversationId: a }) => dG({ ...o, headers: r, path: { id: a } }).then(Ye),
    deleteConversation: ({ conversationId: a }) => fG({ ...o, headers: r, path: { id: a } }).then(Ye),
    listConversations: ({ nextToken: a }) => pG({ ...o, headers: r, query: { nextToken: a } }).then(Ye),
    listConversationMessages: ({ conversationId: a, nextToken: s }) => vG({
      ...o,
      headers: r,
      path: { id: a },
      query: { nextToken: s }
    }).then(Ye),
    addParticipant: ({ conversationId: a, userId: s }) => gG({ ...o, headers: r, path: { id: a }, body: { userId: s } }).then(Ye),
    removeParticipant: ({ conversationId: a, userId: s }) => yG({ ...o, headers: r, path: { id: a, userId: s } }).then(Ye),
    getParticipant: ({ conversationId: a, userId: s }) => bG({ ...o, headers: r, path: { id: a, userId: s } }).then(Ye),
    listParticipants: ({ conversationId: a, nextToken: s }) => mG({ ...o, headers: r, path: { id: a }, query: { nextToken: s } }).then(Ye),
    createMessage: (a) => EG({ ...o, headers: r, body: a }).then(Ye),
    updateMessage: ({ messageId: a, ...s }) => SG({ ...o, headers: r, path: { id: a }, body: s }).then(Ye),
    getMessage: ({ messageId: a }) => wG({ ...o, headers: r, path: { id: a } }).then(Ye),
    deleteMessage: ({ messageId: a }) => xG({ ...o, headers: r, path: { id: a } }).then(Ye),
    createFile: (a) => PG({ ...o, headers: r, body: a }).then(Ye),
    createUser: (a) => h0({ ...o, headers: r, body: a }).then(Ye),
    getUser: () => TG({ ...o, headers: r }).then(Ye),
    updateUser: (a) => OG({ ...o, headers: r, body: a }).then(Ye),
    deleteUser: () => $G({ ...o, headers: r }).then(Ye),
    createEvent: (a) => RG({ ...o, headers: r, body: a }).then(Ye),
    getEvent: ({ eventId: a }) => IG({ ...o, headers: r, path: { id: a } }).then(Ye),
    addMessageFeedback: ({ messageId: a, ...s }) => CG({ ...o, headers: r, path: { id: a }, body: s }).then(Ye),
    removeMessageFeedback: ({ messageId: a }) => kG({ ...o, headers: r, path: { id: a } }).then(Ye),
    listenConversation: ({ conversationId: a }) => {
      let s = 0, l = null;
      const u = new jG(), c = () => {
        l && l.close();
        const f = `${i}/conversations/${a}/listen`;
        l = new Da(f, {
          fetch: (p, d) => fetch(p, {
            ...d,
            headers: {
              ...d == null ? void 0 : d.headers,
              ...r,
              timeout: "60_000"
            }
          })
        }), l.onopen = () => u.emit("open"), l.onerror = (p) => {
          u.emit("error", p), s < 10 && (s++, setTimeout(() => c(), 3e3));
        }, l.onmessage = (p) => {
          const d = FG(p.data);
          u.emit(d.type, d.data);
        };
      };
      return c(), u.on.bind(u);
    }
  };
}, FG = (e) => {
  try {
    return JSON.parse(e);
  } catch {
    return e;
  }
}, BG = ["audio", "file", "image", "video"], zG = (e) => BG.includes(e);
async function WG({
  conversationId: e,
  userCredentials: t,
  clientId: n,
  apiUrl: r
}) {
  let i = t, o = e;
  if (!i) {
    const { key: s, user: l } = await NG({ clientId: n, apiUrl: r });
    i = { userId: l.id, userToken: s };
  }
  const a = LG({
    userKey: i.userToken,
    clientId: n,
    apiUrl: r
  });
  return (!o || !t) && (o = await g0(a)), {
    client: a,
    conversationId: o,
    userCredentials: i
  };
}
function UG({
  apiUrl: e = "https://webchat.botpress.cloud",
  clientId: t,
  storageKey: n,
  storageLocation: r,
  ...i
}) {
  const o = jP(n, r), a = o((I) => I.conversationId), s = o((I) => I.user), l = o((I) => I.setConversationId), u = o((I) => I.setUser), c = Tr((I) => I.messages), f = Tr((I) => I.saveMessage), p = Tr((I) => I.updateMessage), d = Tr((I) => I.fetchMessages), v = Tr((I) => I.setMessages), h = Tr((I) => I.isFetching), [g, m] = ge("connecting"), { isTyping: b, setIsTyping: x } = H8(), C = ut(() => new My(), []), [S, E] = ge(!!i.conversationId || !!a), [T, N] = ge(i.conversationId), [j, O] = ge(i.user), [_, V] = ge(void 0);
  if (ft(() => {
    async function I() {
      try {
        const A = i.conversationId || a;
        A && E(!0);
        const { client: M, conversationId: q, userCredentials: W } = await WG({
          clientId: t,
          apiUrl: e,
          userCredentials: i.user || s,
          conversationId: A
        });
        V(M), N(q), l(q), O(W), u(W), m("connected");
      } catch (A) {
        console.error("Failed to initialize webchat:", A), m("error");
      }
    }
    I();
  }, [i.user, i.conversationId]), ft(() => {
    async function I() {
      if (S && _ && T) {
        const A = await d({ client: _, conversationId: T });
        v(A), E(!1);
      }
    }
    I();
  }, [S, _, T]), ft(() => {
    if (!_ || !T) return;
    const I = _.listenConversation({ conversationId: T }), A = [
      I("open", () => m("connected")),
      I("error", (M) => {
        C.emit("error", new Error(`Connection to conversation lost: ${M.message}`)), m("error");
      }),
      I("message_created", (M) => {
        const q = fc(M);
        f(q), C.emit("message", q), (j == null ? void 0 : j.userId) !== q.authorId ? x(!1) : setTimeout(() => x(!0, 5e3), 500);
      }),
      I("webchat_visibility", (M) => C.emit("webchatVisibility", M.visibility)),
      I("webchat_config", (M) => C.emit("webchatConfig", M.config)),
      I("typing_started", (M) => {
        const q = M.timeout ?? 5e3;
        x(!0, q), C.emit("isTyping", { isTyping: !0, timeout: q });
      }),
      I("typing_stopped", () => {
        x(!1), C.emit("isTyping", { isTyping: !1, timeout: 0 });
      }),
      I("custom", (M) => C.emit("customEvent", M.event))
    ];
    return () => {
      A.forEach((M) => M());
    };
  }, [T, _]), g === "connecting" || !j || !T || !_)
    return {
      clientState: "connecting",
      on: C.on.bind(C),
      client: void 0,
      messages: [],
      conversationId: void 0,
      newConversation: async () => {
      },
      user: void 0,
      isTyping: void 0,
      isFetchingMessages: h
    };
  const L = {
    sendMessage: async (I) => {
      const A = s0(), M = {
        id: A,
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        userId: j.userId,
        conversationId: T,
        payload: I,
        metadata: {
          clientMessageId: A,
          delivered: !1
        }
      }, q = fc(M);
      f(q), await _.createMessage({
        conversationId: T,
        payload: I,
        metadata: {
          clientMessageId: A
        }
      }).catch((W) => C.emit("error", W));
    },
    sendEvent: async (I) => {
      await _.createEvent({
        conversationId: T,
        payload: {
          type: "custom",
          data: I
        }
      });
    },
    uploadFile: async (I) => {
      const { size: A, name: M } = I, W = await ((Y) => new Promise((K, G) => {
        const Z = new FileReader();
        Z.onload = (Q) => {
          var X;
          return K((X = Q.target) == null ? void 0 : X.result);
        }, Z.onerror = (Q) => {
          var X;
          return G((X = Q.target) == null ? void 0 : X.error);
        }, Z.readAsArrayBuffer(Y);
      }))(I), P = /* @__PURE__ */ new Date();
      P.setDate(P.getDate() + 30);
      const {
        file: { uploadUrl: y, contentType: D, url: B }
      } = await _.createFile({
        size: A,
        key: M,
        accessPolicies: ["public_content"],
        index: !1,
        tags: { source: "integration", integrationName: "webchat" },
        expiresAt: P.toISOString()
      });
      await fetch(y, {
        method: "PUT",
        headers: {
          "x-amz-tagging": "public=true"
        },
        body: W
      });
      const w = D.split("/").shift() ?? "", U = zG(w) ? w : "file";
      return { fileUrl: B, name: M, type: U };
    },
    addMessageFeedback: async (I, A) => {
      p(I, { feedback: A.value }), await _.addMessageFeedback({
        messageId: I,
        ...A
      });
    },
    getUser: async () => {
      const { user: I } = await _.getUser();
      return I;
    },
    updateUser: async (I) => {
      const { user: A } = await _.updateUser({
        name: I.name,
        pictureUrl: I.pictureUrl,
        userData: I.data
      });
      return A;
    }
  };
  return {
    clientState: g,
    on: C.on.bind(C),
    client: L,
    messages: c,
    conversationId: T,
    newConversation: async () => {
      v([]);
      const I = await g0(_);
      N(I), l(I);
    },
    user: s,
    isTyping: b,
    isFetchingMessages: h
  };
}
const g0 = async (e) => {
  const { conversation: t } = await e.createConversation();
  return await e.createEvent({
    conversationId: t.id,
    payload: {
      type: "conversation_started",
      data: {}
    }
  }), t.id;
}, hX = ({
  clientId: e,
  storageKey: t,
  configuration: n,
  allowFileUpload: r,
  apiUrl: i,
  user: o,
  conversationId: a,
  ...s
}) => {
  const l = t || `bp-webchat-${e}`, {
    clientState: u,
    client: c,
    isFetchingMessages: f,
    isTyping: p,
    newConversation: d,
    messages: v,
    user: h
  } = UG({
    clientId: e,
    apiUrl: i,
    conversationId: a,
    user: o,
    storageKey: l,
    storageLocation: n == null ? void 0 : n.storageLocation
  }), { sendMessage: g, uploadFile: m, addMessageFeedback: b } = c ?? {};
  return /* @__PURE__ */ $.jsx(
    U8,
    {
      configuration: n ?? {},
      user: h != null && h.userId ? { id: h == null ? void 0 : h.userId } : void 0,
      isLoading: f || u === "connecting",
      isTyping: p,
      connected: u === "connected" ? !0 : u === "disconnected" ? !1 : void 0,
      messages: v,
      sendMessage: g,
      uploadFile: m,
      addMessageFeedback: b,
      allowFileUpload: r,
      restartConversation: d,
      ...s
    }
  );
};
function HG(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Zn(e);
  k.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var VG = "DismissableLayer", lf = "dismissableLayer.update", KG = "dismissableLayer.pointerDownOutside", qG = "dismissableLayer.focusOutside", gy, y0 = k.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), b0 = k.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: i,
      onFocusOutside: o,
      onInteractOutside: a,
      onDismiss: s,
      ...l
    } = e, u = k.useContext(y0), [c, f] = k.useState(null), p = (c == null ? void 0 : c.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, d] = k.useState({}), v = nr(t, (T) => f(T)), h = Array.from(u.layers), [g] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), m = h.indexOf(g), b = c ? h.indexOf(c) : -1, x = u.layersWithOutsidePointerEventsDisabled.size > 0, C = b >= m, S = XG((T) => {
      const N = T.target, j = [...u.branches].some((O) => O.contains(N));
      !C || j || (i == null || i(T), a == null || a(T), T.defaultPrevented || s == null || s());
    }, p), E = JG((T) => {
      const N = T.target;
      [...u.branches].some((O) => O.contains(N)) || (o == null || o(T), a == null || a(T), T.defaultPrevented || s == null || s());
    }, p);
    return HG((T) => {
      b === u.layers.size - 1 && (r == null || r(T), !T.defaultPrevented && s && (T.preventDefault(), s()));
    }, p), k.useEffect(() => {
      if (c)
        return n && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (gy = p.body.style.pointerEvents, p.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(c)), u.layers.add(c), yy(), () => {
          n && u.layersWithOutsidePointerEventsDisabled.size === 1 && (p.body.style.pointerEvents = gy);
        };
    }, [c, p, n, u]), k.useEffect(() => () => {
      c && (u.layers.delete(c), u.layersWithOutsidePointerEventsDisabled.delete(c), yy());
    }, [c, u]), k.useEffect(() => {
      const T = () => d({});
      return document.addEventListener(lf, T), () => document.removeEventListener(lf, T);
    }, []), /* @__PURE__ */ $.jsx(
      fn.div,
      {
        ...l,
        ref: v,
        style: {
          pointerEvents: x ? C ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: _n(e.onFocusCapture, E.onFocusCapture),
        onBlurCapture: _n(e.onBlurCapture, E.onBlurCapture),
        onPointerDownCapture: _n(
          e.onPointerDownCapture,
          S.onPointerDownCapture
        )
      }
    );
  }
);
b0.displayName = VG;
var GG = "DismissableLayerBranch", YG = k.forwardRef((e, t) => {
  const n = k.useContext(y0), r = k.useRef(null), i = nr(t, r);
  return k.useEffect(() => {
    const o = r.current;
    if (o)
      return n.branches.add(o), () => {
        n.branches.delete(o);
      };
  }, [n.branches]), /* @__PURE__ */ $.jsx(fn.div, { ...e, ref: i });
});
YG.displayName = GG;
function XG(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Zn(e), r = k.useRef(!1), i = k.useRef(() => {
  });
  return k.useEffect(() => {
    const o = (s) => {
      if (s.target && !r.current) {
        let l = function() {
          x0(
            KG,
            n,
            u,
            { discrete: !0 }
          );
        };
        const u = { originalEvent: s };
        s.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = l, t.addEventListener("click", i.current, { once: !0 })) : l();
      } else
        t.removeEventListener("click", i.current);
      r.current = !1;
    }, a = window.setTimeout(() => {
      t.addEventListener("pointerdown", o);
    }, 0);
    return () => {
      window.clearTimeout(a), t.removeEventListener("pointerdown", o), t.removeEventListener("click", i.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function JG(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Zn(e), r = k.useRef(!1);
  return k.useEffect(() => {
    const i = (o) => {
      o.target && !r.current && x0(qG, n, { originalEvent: o }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function yy() {
  const e = new CustomEvent(lf);
  document.dispatchEvent(e);
}
function x0(e, t, n, { discrete: r }) {
  const i = n.originalEvent.target, o = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && i.addEventListener(e, t, { once: !0 }), r ? VM(i, o) : i.dispatchEvent(o);
}
var Wu = "focusScope.autoFocusOnMount", Uu = "focusScope.autoFocusOnUnmount", by = { bubbles: !1, cancelable: !0 }, ZG = "FocusScope", w0 = k.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: o,
    ...a
  } = e, [s, l] = k.useState(null), u = Zn(i), c = Zn(o), f = k.useRef(null), p = nr(t, (h) => l(h)), d = k.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  k.useEffect(() => {
    if (r) {
      let h = function(x) {
        if (d.paused || !s) return;
        const C = x.target;
        s.contains(C) ? f.current = C : Un(f.current, { select: !0 });
      }, g = function(x) {
        if (d.paused || !s) return;
        const C = x.relatedTarget;
        C !== null && (s.contains(C) || Un(f.current, { select: !0 }));
      }, m = function(x) {
        if (document.activeElement === document.body)
          for (const S of x)
            S.removedNodes.length > 0 && Un(s);
      };
      document.addEventListener("focusin", h), document.addEventListener("focusout", g);
      const b = new MutationObserver(m);
      return s && b.observe(s, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", h), document.removeEventListener("focusout", g), b.disconnect();
      };
    }
  }, [r, s, d.paused]), k.useEffect(() => {
    if (s) {
      wy.add(d);
      const h = document.activeElement;
      if (!s.contains(h)) {
        const m = new CustomEvent(Wu, by);
        s.addEventListener(Wu, u), s.dispatchEvent(m), m.defaultPrevented || (QG(iY(S0(s)), { select: !0 }), document.activeElement === h && Un(s));
      }
      return () => {
        s.removeEventListener(Wu, u), setTimeout(() => {
          const m = new CustomEvent(Uu, by);
          s.addEventListener(Uu, c), s.dispatchEvent(m), m.defaultPrevented || Un(h ?? document.body, { select: !0 }), s.removeEventListener(Uu, c), wy.remove(d);
        }, 0);
      };
    }
  }, [s, u, c, d]);
  const v = k.useCallback(
    (h) => {
      if (!n && !r || d.paused) return;
      const g = h.key === "Tab" && !h.altKey && !h.ctrlKey && !h.metaKey, m = document.activeElement;
      if (g && m) {
        const b = h.currentTarget, [x, C] = eY(b);
        x && C ? !h.shiftKey && m === C ? (h.preventDefault(), n && Un(x, { select: !0 })) : h.shiftKey && m === x && (h.preventDefault(), n && Un(C, { select: !0 })) : m === b && h.preventDefault();
      }
    },
    [n, r, d.paused]
  );
  return /* @__PURE__ */ $.jsx(fn.div, { tabIndex: -1, ...a, ref: p, onKeyDown: v });
});
w0.displayName = ZG;
function QG(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (Un(r, { select: t }), document.activeElement !== n) return;
}
function eY(e) {
  const t = S0(e), n = xy(t, e), r = xy(t.reverse(), e);
  return [n, r];
}
function S0(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function xy(e, t) {
  for (const n of e)
    if (!tY(n, { upTo: t })) return n;
}
function tY(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function nY(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Un(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && nY(e) && t && e.select();
  }
}
var wy = rY();
function rY() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), e = Sy(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = Sy(e, t), (n = e[0]) == null || n.resume();
    }
  };
}
function Sy(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function iY(e) {
  return e.filter((t) => t.tagName !== "A");
}
var Hu = 0;
function oY() {
  k.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? Ey()), document.body.insertAdjacentElement("beforeend", e[1] ?? Ey()), Hu++, () => {
      Hu === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), Hu--;
    };
  }, []);
}
function Ey() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var _a = "right-scroll-bar-position", Ma = "width-before-scroll-bar", aY = "with-scroll-bars-hidden", sY = "--removed-body-scroll-bar-size";
function Vu(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function lY(e, t) {
  var n = ge(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && (n.value = r, n.callback(r, i));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var uY = typeof window < "u" ? k.useLayoutEffect : k.useEffect, ky = /* @__PURE__ */ new WeakMap();
function cY(e, t) {
  var n = lY(null, function(r) {
    return e.forEach(function(i) {
      return Vu(i, r);
    });
  });
  return uY(function() {
    var r = ky.get(n);
    if (r) {
      var i = new Set(r), o = new Set(e), a = n.current;
      i.forEach(function(s) {
        o.has(s) || Vu(s, null);
      }), o.forEach(function(s) {
        i.has(s) || Vu(s, a);
      });
    }
    ky.set(n, e);
  }, [e]), n;
}
function fY(e) {
  return e;
}
function dY(e, t) {
  t === void 0 && (t = fY);
  var n = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(o) {
      var a = t(o, r);
      return n.push(a), function() {
        n = n.filter(function(s) {
          return s !== a;
        });
      };
    },
    assignSyncMedium: function(o) {
      for (r = !0; n.length; ) {
        var a = n;
        n = [], a.forEach(o);
      }
      n = {
        push: function(s) {
          return o(s);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(o) {
      r = !0;
      var a = [];
      if (n.length) {
        var s = n;
        n = [], s.forEach(o), a = n;
      }
      var l = function() {
        var c = a;
        a = [], c.forEach(o);
      }, u = function() {
        return Promise.resolve().then(l);
      };
      u(), n = {
        push: function(c) {
          a.push(c), u();
        },
        filter: function(c) {
          return a = a.filter(c), n;
        }
      };
    }
  };
  return i;
}
function pY(e) {
  e === void 0 && (e = {});
  var t = dY(null);
  return t.options = Jt({ async: !0, ssr: !1 }, e), t;
}
var E0 = function(e) {
  var t = e.sideCar, n = vx(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return k.createElement(r, Jt({}, n));
};
E0.isSideCarExport = !0;
function hY(e, t) {
  return e.useMedium(t), E0;
}
var k0 = pY(), Ku = function() {
}, rl = k.forwardRef(function(e, t) {
  var n = k.useRef(null), r = k.useState({
    onScrollCapture: Ku,
    onWheelCapture: Ku,
    onTouchMoveCapture: Ku
  }), i = r[0], o = r[1], a = e.forwardProps, s = e.children, l = e.className, u = e.removeScrollBar, c = e.enabled, f = e.shards, p = e.sideCar, d = e.noIsolation, v = e.inert, h = e.allowPinchZoom, g = e.as, m = g === void 0 ? "div" : g, b = e.gapMode, x = vx(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), C = p, S = cY([n, t]), E = Jt(Jt({}, x), i);
  return k.createElement(
    k.Fragment,
    null,
    c && k.createElement(C, { sideCar: k0, removeScrollBar: u, shards: f, noIsolation: d, inert: v, setCallbacks: o, allowPinchZoom: !!h, lockRef: n, gapMode: b }),
    a ? k.cloneElement(k.Children.only(s), Jt(Jt({}, E), { ref: S })) : k.createElement(m, Jt({}, E, { className: l, ref: S }), s)
  );
});
rl.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
rl.classNames = {
  fullWidth: Ma,
  zeroRight: _a
};
var vY = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function mY() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = vY();
  return t && e.setAttribute("nonce", t), e;
}
function gY(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function yY(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var bY = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = mY()) && (gY(t, n), yY(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, xY = function() {
  var e = bY();
  return function(t, n) {
    k.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, C0 = function() {
  var e = xY(), t = function(n) {
    var r = n.styles, i = n.dynamic;
    return e(r, i), null;
  };
  return t;
}, wY = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, qu = function(e) {
  return parseInt(e || "", 10) || 0;
}, SY = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [qu(n), qu(r), qu(i)];
}, EY = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return wY;
  var t = SY(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, kY = C0(), Xr = "data-scroll-locked", CY = function(e, t, n, r) {
  var i = e.left, o = e.top, a = e.right, s = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(aY, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(s, "px ").concat(r, `;
  }
  body[`).concat(Xr, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(o, `px;
    padding-right: `).concat(a, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(s, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(s, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(_a, ` {
    right: `).concat(s, "px ").concat(r, `;
  }
  
  .`).concat(Ma, ` {
    margin-right: `).concat(s, "px ").concat(r, `;
  }
  
  .`).concat(_a, " .").concat(_a, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Ma, " .").concat(Ma, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Xr, `] {
    `).concat(sY, ": ").concat(s, `px;
  }
`);
}, Cy = function() {
  var e = parseInt(document.body.getAttribute(Xr) || "0", 10);
  return isFinite(e) ? e : 0;
}, $Y = function() {
  k.useEffect(function() {
    return document.body.setAttribute(Xr, (Cy() + 1).toString()), function() {
      var e = Cy() - 1;
      e <= 0 ? document.body.removeAttribute(Xr) : document.body.setAttribute(Xr, e.toString());
    };
  }, []);
}, TY = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, i = r === void 0 ? "margin" : r;
  $Y();
  var o = k.useMemo(function() {
    return EY(i);
  }, [i]);
  return k.createElement(kY, { styles: CY(o, !t, i, n ? "" : "!important") });
}, uf = !1;
if (typeof window < "u")
  try {
    var ha = Object.defineProperty({}, "passive", {
      get: function() {
        return uf = !0, !0;
      }
    });
    window.addEventListener("test", ha, ha), window.removeEventListener("test", ha, ha);
  } catch {
    uf = !1;
  }
var _r = uf ? { passive: !1 } : !1, OY = function(e) {
  return e.tagName === "TEXTAREA";
}, $0 = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !OY(e) && n[t] === "visible")
  );
}, IY = function(e) {
  return $0(e, "overflowY");
}, RY = function(e) {
  return $0(e, "overflowX");
}, $y = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var i = T0(e, r);
    if (i) {
      var o = O0(e, r), a = o[1], s = o[2];
      if (a > s)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, PY = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, AY = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, T0 = function(e, t) {
  return e === "v" ? IY(t) : RY(t);
}, O0 = function(e, t) {
  return e === "v" ? PY(t) : AY(t);
}, DY = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, _Y = function(e, t, n, r, i) {
  var o = DY(e, window.getComputedStyle(t).direction), a = o * r, s = n.target, l = t.contains(s), u = !1, c = a > 0, f = 0, p = 0;
  do {
    var d = O0(e, s), v = d[0], h = d[1], g = d[2], m = h - g - o * v;
    (v || m) && T0(e, s) && (f += m, p += v), s instanceof ShadowRoot ? s = s.host : s = s.parentNode;
  } while (
    // portaled content
    !l && s !== document.body || // self content
    l && (t.contains(s) || t === s)
  );
  return (c && (Math.abs(f) < 1 || !i) || !c && (Math.abs(p) < 1 || !i)) && (u = !0), u;
}, va = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, Ty = function(e) {
  return [e.deltaX, e.deltaY];
}, Oy = function(e) {
  return e && "current" in e ? e.current : e;
}, MY = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, jY = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, NY = 0, Mr = [];
function LY(e) {
  var t = k.useRef([]), n = k.useRef([0, 0]), r = k.useRef(), i = k.useState(NY++)[0], o = k.useState(C0)[0], a = k.useRef(e);
  k.useEffect(function() {
    a.current = e;
  }, [e]), k.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var h = pc([e.lockRef.current], (e.shards || []).map(Oy), !0).filter(Boolean);
      return h.forEach(function(g) {
        return g.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), h.forEach(function(g) {
          return g.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var s = k.useCallback(function(h, g) {
    if ("touches" in h && h.touches.length === 2 || h.type === "wheel" && h.ctrlKey)
      return !a.current.allowPinchZoom;
    var m = va(h), b = n.current, x = "deltaX" in h ? h.deltaX : b[0] - m[0], C = "deltaY" in h ? h.deltaY : b[1] - m[1], S, E = h.target, T = Math.abs(x) > Math.abs(C) ? "h" : "v";
    if ("touches" in h && T === "h" && E.type === "range")
      return !1;
    var N = $y(T, E);
    if (!N)
      return !0;
    if (N ? S = T : (S = T === "v" ? "h" : "v", N = $y(T, E)), !N)
      return !1;
    if (!r.current && "changedTouches" in h && (x || C) && (r.current = S), !S)
      return !0;
    var j = r.current || S;
    return _Y(j, g, h, j === "h" ? x : C, !0);
  }, []), l = k.useCallback(function(h) {
    var g = h;
    if (!(!Mr.length || Mr[Mr.length - 1] !== o)) {
      var m = "deltaY" in g ? Ty(g) : va(g), b = t.current.filter(function(S) {
        return S.name === g.type && (S.target === g.target || g.target === S.shadowParent) && MY(S.delta, m);
      })[0];
      if (b && b.should) {
        g.cancelable && g.preventDefault();
        return;
      }
      if (!b) {
        var x = (a.current.shards || []).map(Oy).filter(Boolean).filter(function(S) {
          return S.contains(g.target);
        }), C = x.length > 0 ? s(g, x[0]) : !a.current.noIsolation;
        C && g.cancelable && g.preventDefault();
      }
    }
  }, []), u = k.useCallback(function(h, g, m, b) {
    var x = { name: h, delta: g, target: m, should: b, shadowParent: FY(m) };
    t.current.push(x), setTimeout(function() {
      t.current = t.current.filter(function(C) {
        return C !== x;
      });
    }, 1);
  }, []), c = k.useCallback(function(h) {
    n.current = va(h), r.current = void 0;
  }, []), f = k.useCallback(function(h) {
    u(h.type, Ty(h), h.target, s(h, e.lockRef.current));
  }, []), p = k.useCallback(function(h) {
    u(h.type, va(h), h.target, s(h, e.lockRef.current));
  }, []);
  k.useEffect(function() {
    return Mr.push(o), e.setCallbacks({
      onScrollCapture: f,
      onWheelCapture: f,
      onTouchMoveCapture: p
    }), document.addEventListener("wheel", l, _r), document.addEventListener("touchmove", l, _r), document.addEventListener("touchstart", c, _r), function() {
      Mr = Mr.filter(function(h) {
        return h !== o;
      }), document.removeEventListener("wheel", l, _r), document.removeEventListener("touchmove", l, _r), document.removeEventListener("touchstart", c, _r);
    };
  }, []);
  var d = e.removeScrollBar, v = e.inert;
  return k.createElement(
    k.Fragment,
    null,
    v ? k.createElement(o, { styles: jY(i) }) : null,
    d ? k.createElement(TY, { gapMode: e.gapMode }) : null
  );
}
function FY(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const BY = hY(k0, LY);
var I0 = k.forwardRef(function(e, t) {
  return k.createElement(rl, Jt({}, e, { ref: t, sideCar: BY }));
});
I0.classNames = rl.classNames;
var zY = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, jr = /* @__PURE__ */ new WeakMap(), ma = /* @__PURE__ */ new WeakMap(), ga = {}, Gu = 0, R0 = function(e) {
  return e && (e.host || R0(e.parentNode));
}, WY = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = R0(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, UY = function(e, t, n, r) {
  var i = WY(t, Array.isArray(e) ? e : [e]);
  ga[n] || (ga[n] = /* @__PURE__ */ new WeakMap());
  var o = ga[n], a = [], s = /* @__PURE__ */ new Set(), l = new Set(i), u = function(f) {
    !f || s.has(f) || (s.add(f), u(f.parentNode));
  };
  i.forEach(u);
  var c = function(f) {
    !f || l.has(f) || Array.prototype.forEach.call(f.children, function(p) {
      if (s.has(p))
        c(p);
      else
        try {
          var d = p.getAttribute(r), v = d !== null && d !== "false", h = (jr.get(p) || 0) + 1, g = (o.get(p) || 0) + 1;
          jr.set(p, h), o.set(p, g), a.push(p), h === 1 && v && ma.set(p, !0), g === 1 && p.setAttribute(n, "true"), v || p.setAttribute(r, "true");
        } catch (m) {
          console.error("aria-hidden: cannot operate on ", p, m);
        }
    });
  };
  return c(t), s.clear(), Gu++, function() {
    a.forEach(function(f) {
      var p = jr.get(f) - 1, d = o.get(f) - 1;
      jr.set(f, p), o.set(f, d), p || (ma.has(f) || f.removeAttribute(r), ma.delete(f)), d || f.removeAttribute(n);
    }), Gu--, Gu || (jr = /* @__PURE__ */ new WeakMap(), jr = /* @__PURE__ */ new WeakMap(), ma = /* @__PURE__ */ new WeakMap(), ga = {});
  };
}, HY = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), i = zY(e);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))), UY(r, i, n, "aria-hidden")) : function() {
    return null;
  };
}, dp = "Dialog", [P0, vX] = bw(dp), [VY, In] = P0(dp), A0 = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: o,
    modal: a = !0
  } = e, s = k.useRef(null), l = k.useRef(null), [u = !1, c] = xw({
    prop: r,
    defaultProp: i,
    onChange: o
  });
  return /* @__PURE__ */ $.jsx(
    VY,
    {
      scope: t,
      triggerRef: s,
      contentRef: l,
      contentId: ka(),
      titleId: ka(),
      descriptionId: ka(),
      open: u,
      onOpenChange: c,
      onOpenToggle: k.useCallback(() => c((f) => !f), [c]),
      modal: a,
      children: n
    }
  );
};
A0.displayName = dp;
var D0 = "DialogTrigger", _0 = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = In(D0, n), o = nr(t, i.triggerRef);
    return /* @__PURE__ */ $.jsx(
      fn.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": hp(i.open),
        ...r,
        ref: o,
        onClick: _n(e.onClick, i.onOpenToggle)
      }
    );
  }
);
_0.displayName = D0;
var KY = "DialogPortal", [mX, M0] = P0(KY, {
  forceMount: void 0
}), cs = "DialogOverlay", j0 = k.forwardRef(
  (e, t) => {
    const n = M0(cs, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, o = In(cs, e.__scopeDialog);
    return o.modal ? /* @__PURE__ */ $.jsx(Is, { present: r || o.open, children: /* @__PURE__ */ $.jsx(qY, { ...i, ref: t }) }) : null;
  }
);
j0.displayName = cs;
var qY = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = In(cs, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ $.jsx(I0, { as: Zf, allowPinchZoom: !0, shards: [i.contentRef], children: /* @__PURE__ */ $.jsx(
        fn.div,
        {
          "data-state": hp(i.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), yr = "DialogContent", N0 = k.forwardRef(
  (e, t) => {
    const n = M0(yr, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, o = In(yr, e.__scopeDialog);
    return /* @__PURE__ */ $.jsx(Is, { present: r || o.open, children: o.modal ? /* @__PURE__ */ $.jsx(GY, { ...i, ref: t }) : /* @__PURE__ */ $.jsx(YY, { ...i, ref: t }) });
  }
);
N0.displayName = yr;
var GY = k.forwardRef(
  (e, t) => {
    const n = In(yr, e.__scopeDialog), r = k.useRef(null), i = nr(t, n.contentRef, r);
    return k.useEffect(() => {
      const o = r.current;
      if (o) return HY(o);
    }, []), /* @__PURE__ */ $.jsx(
      L0,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: _n(e.onCloseAutoFocus, (o) => {
          var a;
          o.preventDefault(), (a = n.triggerRef.current) == null || a.focus();
        }),
        onPointerDownOutside: _n(e.onPointerDownOutside, (o) => {
          const a = o.detail.originalEvent, s = a.button === 0 && a.ctrlKey === !0;
          (a.button === 2 || s) && o.preventDefault();
        }),
        onFocusOutside: _n(
          e.onFocusOutside,
          (o) => o.preventDefault()
        )
      }
    );
  }
), YY = k.forwardRef(
  (e, t) => {
    const n = In(yr, e.__scopeDialog), r = k.useRef(!1), i = k.useRef(!1);
    return /* @__PURE__ */ $.jsx(
      L0,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (o) => {
          var a, s;
          (a = e.onCloseAutoFocus) == null || a.call(e, o), o.defaultPrevented || (r.current || (s = n.triggerRef.current) == null || s.focus(), o.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (o) => {
          var l, u;
          (l = e.onInteractOutside) == null || l.call(e, o), o.defaultPrevented || (r.current = !0, o.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const a = o.target;
          ((u = n.triggerRef.current) == null ? void 0 : u.contains(a)) && o.preventDefault(), o.detail.originalEvent.type === "focusin" && i.current && o.preventDefault();
        }
      }
    );
  }
), L0 = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: o, ...a } = e, s = In(yr, n), l = k.useRef(null), u = nr(t, l);
    return oY(), /* @__PURE__ */ $.jsxs($.Fragment, { children: [
      /* @__PURE__ */ $.jsx(
        w0,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: i,
          onUnmountAutoFocus: o,
          children: /* @__PURE__ */ $.jsx(
            b0,
            {
              role: "dialog",
              id: s.contentId,
              "aria-describedby": s.descriptionId,
              "aria-labelledby": s.titleId,
              "data-state": hp(s.open),
              ...a,
              ref: u,
              onDismiss: () => s.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ $.jsxs($.Fragment, { children: [
        /* @__PURE__ */ $.jsx(XY, { titleId: s.titleId }),
        /* @__PURE__ */ $.jsx(ZY, { contentRef: l, descriptionId: s.descriptionId })
      ] })
    ] });
  }
), pp = "DialogTitle", F0 = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = In(pp, n);
    return /* @__PURE__ */ $.jsx(fn.h2, { id: i.titleId, ...r, ref: t });
  }
);
F0.displayName = pp;
var B0 = "DialogDescription", z0 = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = In(B0, n);
    return /* @__PURE__ */ $.jsx(fn.p, { id: i.descriptionId, ...r, ref: t });
  }
);
z0.displayName = B0;
var W0 = "DialogClose", U0 = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = In(W0, n);
    return /* @__PURE__ */ $.jsx(
      fn.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: _n(e.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
U0.displayName = W0;
function hp(e) {
  return e ? "open" : "closed";
}
var H0 = "DialogTitleWarning", [gX, V0] = NM(H0, {
  contentName: yr,
  titleName: pp,
  docsSlug: "dialog"
}), XY = ({ titleId: e }) => {
  const t = V0(H0), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return k.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, JY = "DialogDescriptionWarning", ZY = ({ contentRef: e, descriptionId: t }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${V0(JY).contentName}}.`;
  return k.useEffect(() => {
    var o;
    const i = (o = e.current) == null ? void 0 : o.getAttribute("aria-describedby");
    t && i && (document.getElementById(t) || console.warn(r));
  }, [r, e, t]), null;
}, QY = A0, eX = _0, tX = j0, nX = N0, rX = F0, iX = z0, oX = U0;
function co({
  open: e,
  onOpenChange: t,
  children: n
}) {
  const { modal: r } = Te;
  return /* @__PURE__ */ $.jsxs(QY, { open: e, onOpenChange: t, children: [
    /* @__PURE__ */ $.jsx(tX, { ...r == null ? void 0 : r.overlay }),
    n
  ] });
}
function aX({
  children: e,
  title: t,
  description: n,
  confirmButton: r,
  onConfirm: i,
  cancelButton: o,
  hideModal: a
}) {
  const { modal: s } = Te;
  return /* @__PURE__ */ $.jsx($.Fragment, { children: /* @__PURE__ */ $.jsxs(nX, { ...s.dialog.container, children: [
    /* @__PURE__ */ $.jsx(rX, { ...s.dialog.title, children: t }),
    /* @__PURE__ */ $.jsx(iX, { ...s.dialog.description, children: n }),
    /* @__PURE__ */ $.jsx("div", { ...s.dialog.content.container, children: e }),
    /* @__PURE__ */ $.jsxs("div", { ...s.dialog.button.container, children: [
      /* @__PURE__ */ $.jsx("button", { ...s.dialog.button.confirm, type: "button", onClick: i, children: r }),
      /* @__PURE__ */ $.jsx("button", { ...s.dialog.button.cancel, type: "button", onClick: a, children: o })
    ] })
  ] }) });
}
co.Button = eX;
co.Close = oX;
co.Content = aX;
export {
  vf as Avatar,
  ri as Block,
  U8 as Chat,
  A_ as Composer,
  yw as Container,
  jM as Fab,
  ij as Header,
  Pv as Message,
  l0 as MessageList,
  co as Modal,
  Ov as ModalProvider,
  nj as RestartConversationButton,
  MM as StylesheetProvider,
  $w as TypingIndicator,
  hX as Webchat,
  BG as fileTypes,
  tk as generateThemeStylesheet,
  jP as getUseWebchatClientStore,
  IP as integrationMessagePayloadToBlockPayload,
  fc as integrationMessageToBlockMessage,
  zG as isFileType,
  f_ as renderers,
  UG as useWebchat,
  _f as useWebchatStore,
  Te as webchatClasses
};
